---
title: "Big_creek_genotypes_script_1"
output: html_document
  toc : true
  toc_depth : 6 
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# knitr::opts_chunk$set(echo = TRUE, message = F, warning = F)

```



                         ### WELCOME TO THE BIG CREEK SCRIPT ###


          We will try to be as reproducible as possible, so that the script will 
          be used for each analysis, and so that every manual step and every result 
          is described and explained in the script.

 



# Library

Do a quick tour in the library.
```{r}
library(tidyverse)
library(readxl)
library(vcfR)
library(esquisse)
```

# I) Introduction

Here we will run Franz and obtain the parentage data, and we will use the results in the later scripts. 

This script is quite old. 
This is called script 1, there should be more than 8 scripts for the big creek project: Normally, you can follow them in order...

# II) Import the data

This is the metadata, containing the fork length, the distance from ?, the year, the stream, the capture date, etc.

## A) Metadata for run 7 to 12 (All the first big creek runs)
```{r}
Upper_Big_Creek_fall_tisue_sample_data_2010_2017_with_distance_for_Devon_12Mar2019 <- read_excel("Data/Upper Big Creek fall tisue sample data 2010-2017 with distance_for Devon 12Mar2019.xlsx")

```

## B) Summaries of each gtSeq run!  
I don't know how they are gonna be useful yet but we will see.
There is something happening with the plates here.
```{r}
steelhead_gtseq7_summary <- read_excel("Data/steelhead_gtseq7_summary.xlsx")
steelhead_gtseq8_summary <- read_excel("Data/steelhead_gtseq8_summary.xlsx")
steelhead_gtseq9_summary <- read_excel("Data/steelhead_gtseq9_summary.xlsx")
steelhead_gtseq10_summary <- read_excel("Data/steelhead_gtseq10_summary.xlsx")
steelhead_gtseq11_summary <- read_excel("Data/steelhead_gtseq11_summary.xlsx")
steelhead_gtseq12_summary <- read_excel("Data/steelhead_gtseq12_summary.xlsx")

```

total fish in here = 288 + 96 + 384 + 384 + 384 + 480 = 2016. OK.


## C) I need the metadata sheet as well! 
```{r}

steelhead_gtseq7_meta <- read_excel("Data/steelhead_gtseq7_summary.xlsx", sheet = "meta")
steelhead_gtseq8_meta <- read_excel("Data/steelhead_gtseq8_summary.xlsx", sheet = "meta")
steelhead_gtseq9_meta <- read_excel("Data/steelhead_gtseq9_summary.xlsx", sheet = "meta")
steelhead_gtseq10_meta <- read_excel("Data/steelhead_gtseq10_summary.xlsx", sheet = "meta")
steelhead_gtseq11_meta <- read_excel("Data/steelhead_gtseq11_summary.xlsx", sheet = "meta")
steelhead_gtseq12_meta <- read_excel("Data/steelhead_gtseq12_summary.xlsx", sheet = "meta")

```


## D) The most important: The genotypes! 

I'll try the package vcfR. 
```{r}
# Some help please ?!
library(help = vcfR)
read.vcfR(file = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Data/gtseq7-12_ubc_hap2col_current_vcf")
read.vcfR(file = "Data/gtseq7-12_ubc_hap2col_current_vcf.vcf")

# Maybe read the VCF directly was not necessary... We will see 
gtseq7.12_ubc_hap2col_current_vcf.txt <- read.delim("D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Data/gtseq7-12_ubc_hap2col_current_vcf.txt.txt", header=TRUE)

```
As you can see I gave up on reading the VCF directly and I just read it as a table for now.


> Let's explore some files ! 

This is quite useless.
```{r}

head(gtseq7.12_ubc_hap2col_current_vcf.txt)
head(steelhead_gtseq7_summary)
nrow(steelhead_gtseq7_summary)
nrow(gtseq7.12_ubc_hap2col_current_vcf.txt) # 1995 fish genotyped apparently ! Wow ! 

```

There is `r nrow(gtseq7.12_ubc_hap2col_current_vcf.txt)` fish genotyped in here.

# III) Join and prepare

## A) Sample sheets

Let's do the samplesheets first, then the meta, and then combine!

```{r}
# So here the "GTSeq_Run" column is generated by bindrows() so that GtSeq7 is "1" up to GtSeq12 named "6". 
Bigmeta_samplesheets <-  bind_rows( steelhead_gtseq7_summary, steelhead_gtseq8_summary, steelhead_gtseq9_summary, steelhead_gtseq10_summary, steelhead_gtseq11_summary, steelhead_gtseq12_summary  , .id = "GtSeq_Run")

# How big is the file? 
nrow(Bigmeta_samplesheets)
# 2016 !! A few fish have been discarded ! 
# Number of fish not genotyped: 2016 - 1995 = 21 

# We want the same "Sample ID"
Bigmeta_samplesheets_V2 <- Bigmeta_samplesheets  %>%  
  rename(., indiv.ID = "Sample_Name") %>% 
  rename(., NMFS_DNA_ID = "Description")

head(Bigmeta_samplesheets_V2)
```

So we have `r nrow(Bigmeta_samplesheets)` fish in the metadata. 

Now we do a supermeta.
We do some minor arrangements on the names to make them match, to join the datasets together.

```{r}
Supermeta_V1 <- bind_rows(steelhead_gtseq7_meta, steelhead_gtseq8_meta, steelhead_gtseq9_meta, steelhead_gtseq10_meta, steelhead_gtseq11_meta, steelhead_gtseq12_meta)
nrow(Supermeta_V1)
```
There is 2496 row in Supermeta V1.


```{r}

# With a corrected name for NFMS_DNA_ID as we did earlier
Supermeta_V2 <- Supermeta_V1 %>% 
  rename(., NMFS_DNA_ID = "NMFS_DNA_ID...1")

head(Supermeta_V2)
head(Bigmeta_samplesheets_V2)
  
```

We corrected some names etc, just to make tables match together.


##  B) Add the meta 
```{r}
FullMeta_V1 <- Bigmeta_samplesheets_V2 %>% 
  left_join(., Supermeta_V2, by = "NMFS_DNA_ID")
head(FullMeta_V1)
nrow(FullMeta_V1)
```
Ok that's good.

## C) Add the genotypes

 Now we need the Fullmeta minus the 21 ungenotyped fish
```{r}
FullMeta_V2 <- FullMeta_V1 %>% 
  filter(., indiv.ID %in% gtseq7.12_ubc_hap2col_current_vcf.txt$indiv.ID )
nrow(FullMeta_V2)

```
Now it's ok, we have the good number of fish!

## D) Keep track of discarded fish

Check those 21 dicarded fish

Aren't these 21 fish just fish caught one year after the other? 
```{r}
# Here the 21 fish discarded, can be useful.
FullMeta_DicardedFish <- FullMeta_V1 %>% 
  filter(., !indiv.ID %in% gtseq7.12_ubc_hap2col_current_vcf.txt$indiv.ID )


```
## E) A couple of modifications 

### 1) Change the date format of FUllmeta_V2
```{r}
FullMeta_V3 <- FullMeta_V2 %>% 
  separate(., COLLECTION_DATE, c("Coll_year", "Coll_month", "Coll_day"))
head(FullMeta_V3)
```

### 2) Add the sex information from 2Sexy

Input the 'Greb1l_etc" sheets for all runs.
Hum, here the name of the Greb sheet changes, be aware of that.
```{r}
steelhead_gtseq7_GrebEtc <- read_excel("Data/steelhead_gtseq7_summary.xlsx", sheet = "greb_etc")
steelhead_gtseq8_GrebEtc <- read_excel("Data/steelhead_gtseq8_summary.xlsx", sheet = "greb1_etc")
steelhead_gtseq9_GrebEtc <- read_excel("Data/steelhead_gtseq9_summary.xlsx", sheet = "greb1_etc")
steelhead_gtseq10_GrebEtc <- read_excel("Data/steelhead_gtseq10_summary.xlsx", sheet = "greb_etc_10")
steelhead_gtseq11_GrebEtc <- read_excel("Data/steelhead_gtseq11_summary.xlsx", sheet = "greb_etc11")
steelhead_gtseq12_GrebEtc <- read_excel("Data/steelhead_gtseq12_summary.xlsx", sheet = "greb_etc12")

```

Unfortunately they need a bit of individual cleaning:
```{r}
# Fix run 7
head(steelhead_gtseq7_GrebEtc, n=13L)
steelhead_gtseq7_GrebEtc_fixed <- steelhead_gtseq7_GrebEtc %>% 
  select(., - c(total7, `PrI(>=10)`)) %>% 
  filter(., !is.na(loc))
head(steelhead_gtseq7_GrebEtc_fixed, n=13L)

# Fix run 8
head(steelhead_gtseq8_GrebEtc, n=15L)
steelhead_gtseq8_GrebEtc_fixed <- steelhead_gtseq8_GrebEtc %>% 
  select(., - c(total8_greb, `PrI(>=10)`)) %>% 
  filter(., !is.na(loc))
head(steelhead_gtseq8_GrebEtc_fixed, n=13L)

# Fix run 9
head(steelhead_gtseq9_GrebEtc, n=15L)
steelhead_gtseq9_GrebEtc_fixed <- steelhead_gtseq9_GrebEtc %>% 
  select(., - c(total9, `PrI(>=10)`)) %>% 
  filter(., !is.na(loc))
head(steelhead_gtseq9_GrebEtc_fixed, n=13L)

# Fix run 10
head(steelhead_gtseq10_GrebEtc, n=15L)
steelhead_gtseq10_GrebEtc_fixed <- steelhead_gtseq10_GrebEtc %>% 
  select(., - c(total10_greb, `PrI(>=10)`)) %>% 
  filter(., !is.na(loc))
head(steelhead_gtseq10_GrebEtc_fixed, n=13L)

# Fix run 11 : That one was fine already
head(steelhead_gtseq11_GrebEtc, n=15L)
steelhead_gtseq11_GrebEtc_fixed <- steelhead_gtseq11_GrebEtc %>% 
  filter(., !is.na(loc))
head(steelhead_gtseq11_GrebEtc_fixed, n=13L)

# Fix run 12 : That one was fine already
head(steelhead_gtseq12_GrebEtc, n=15L)
steelhead_gtseq12_GrebEtc_fixed <- steelhead_gtseq12_GrebEtc
head(steelhead_gtseq12_GrebEtc_fixed, n=15L)

```
Ok they are fixed now !
 

Here we arrange the table and transform the reads data in sex data, with the rule that a female should have between 0 and 5 reads.
```{r}
# Transform run 7
steelhead_gtseq7_SexInfo <- steelhead_gtseq7_GrebEtc_fixed %>% 
filter(., loc == "omyY1_2SEXY" ) %>%                      # Take Sex locus
  gather(., key = "Individuals", value = "sexreads") %>%  # Reverse the table
  filter(., !Individuals %in% c("loc")) %>%               # A stupid 'loc' row to be removed
  mutate(., sexreads = as.integer(sexreads)) %>%          # To filter them later
  arrange(., sexreads) %>% 
  mutate(., Sample_Name = str_replace_all(Individuals, "s", "SH_")) %>% 
  mutate(., Sex = case_when(sexreads <= 5 ~ 'F', sexreads > 5 ~ 'M' )) %>% 
  select(., Sex, Sample_Name, sexreads)

# Transform run 8
steelhead_gtseq8_SexInfo <- steelhead_gtseq8_GrebEtc_fixed %>% 
filter(., loc == "omyY1_2SEXY" ) %>%                      # Take Sex locus
  gather(., key = "Individuals", value = "sexreads") %>%  # Reverse the table
  filter(., !Individuals %in% c("loc")) %>%               # A stupid 'loc' row to be removed
  mutate(., sexreads = as.integer(sexreads)) %>%          # To filter them later
  arrange(., sexreads) %>% 
  mutate(., Sample_Name = str_replace_all(Individuals, "s", "SH_")) %>% 
  mutate(., Sex = case_when(sexreads <= 5 ~ 'F', sexreads > 5 ~ 'M' )) %>% 
  select(., Sex, Sample_Name, sexreads)

# Transform run 9
steelhead_gtseq9_SexInfo <- steelhead_gtseq9_GrebEtc_fixed %>% 
filter(., loc == "omyY1_2SEXY" ) %>%                      # Take Sex locus
  gather(., key = "Individuals", value = "sexreads") %>%  # Reverse the table
  filter(., !Individuals %in% c("loc")) %>%               # A stupid 'loc' row to be removed
  mutate(., sexreads = as.integer(sexreads)) %>%          # To filter them later
  arrange(., sexreads) %>% 
  mutate(., Sample_Name = str_replace_all(Individuals, "s", "SH_")) %>% 
  mutate(., Sex = case_when(sexreads <= 6 ~ 'F', sexreads > 6 ~ 'M' )) %>% 
  select(., Sex, Sample_Name, sexreads)

# Transform run 10
steelhead_gtseq10_SexInfo <- steelhead_gtseq10_GrebEtc_fixed %>% 
filter(., loc == "omyY1_2SEXY" ) %>%                      # Take Sex locus
  gather(., key = "Individuals", value = "sexreads") %>%  # Reverse the table
  filter(., !Individuals %in% c("loc")) %>%               # A stupid 'loc' row to be removed
  mutate(., sexreads = as.integer(sexreads)) %>%          # To filter them later
  arrange(., sexreads) %>% 
  mutate(., Sample_Name = str_replace_all(Individuals, "s", "SH_")) %>% 
  mutate(., Sex = case_when(sexreads <= 5 ~ 'F', sexreads > 5 ~ 'M' )) %>% 
  select(., Sex, Sample_Name, sexreads)

# Transform run 11
steelhead_gtseq11_SexInfo <- steelhead_gtseq11_GrebEtc_fixed %>% 
filter(., loc == "omyY1_2SEXY" ) %>%                      # Take Sex locus
  gather(., key = "Individuals", value = "sexreads") %>%  # Reverse the table
  filter(., !Individuals %in% c("loc")) %>%               # A stupid 'loc' row to be removed
  mutate(., sexreads = as.integer(sexreads)) %>%          # To filter them later
  arrange(., sexreads) %>% 
  mutate(., Sample_Name = str_replace_all(Individuals, "s", "SH_")) %>% 
  mutate(., Sex = case_when(sexreads <= 5 ~ 'F', sexreads > 5 ~ 'M' )) %>% 
  select(., Sex, Sample_Name, sexreads)

# Transform run 12
steelhead_gtseq12_SexInfo <- steelhead_gtseq12_GrebEtc_fixed %>% 
filter(., loc == "omyY1_2SEXY" ) %>%                      # Take Sex locus
  gather(., key = "Individuals", value = "sexreads") %>%  # Reverse the table
  filter(., !Individuals %in% c("loc")) %>%               # A stupid 'loc' row to be removed
  mutate(., sexreads = as.integer(sexreads)) %>%          # To filter them later
  arrange(., sexreads) %>% 
  mutate(., Sample_Name = str_replace_all(Individuals, "s", "SH_")) %>% 
  mutate(., Sex = case_when(sexreads <= 5 ~ 'F', sexreads > 5 ~ 'M' )) %>% 
  select(., Sex, Sample_Name, sexreads)


```
 
 
 !!!! A FILTER HERE: 5 reads is a minimum to be considered as well genotyped !!!
 
 
 Ok I made an adjustment to 6 reads as a threshold for run9, my 'feeling' is that normally males start around 10, and only a few females have over 3.

I noticed that we have samples duplicated among runs.
Finally, bind_rows all the sex info and join that to our fullmeta file.

```{r 2SexyReady_reads}
Run7to12_sex_info <- bind_rows(steelhead_gtseq7_SexInfo, steelhead_gtseq8_SexInfo, steelhead_gtseq9_SexInfo, steelhead_gtseq10_SexInfo, steelhead_gtseq11_SexInfo, steelhead_gtseq12_SexInfo)
Run7to12_sex_infoV2 <- Run7to12_sex_info %>% 
  rename(., Sample_ID = Sample_Name )

nrow(Run7to12_sex_infoV2)
# There is 2016 sex fish info, we are good! 

```

Join that sex info to our Fullmeta.
```{r}
FullMeta_V4 <- FullMeta_V3 %>% 
  left_join(., Run7to12_sex_infoV2, by = "Sample_ID") %>% 
  select(Sex, everything()) %>% 
       select(., - c(sexreads)) 
head(FullMeta_V4)
nrow(FullMeta_V4)
```
That's it, the sex info is here!

# IV) Summary

How many fish from each pop, for each year? 


```{r}
# Fish per water_name
FullMeta_V4 %>% 
  group_by(., WATER_NAME) %>% 
  count()

# Fish per year
Years <- FullMeta_V4 %>% 
  group_by(., Coll_year) %>% 
  count()
ggplot(Years, aes(Coll_year, n)) + 
  geom_bar(stat = "Identity")
head(Years)
head(FullMeta_V4)

```


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



# V) IMPORTANT steps to follow


We have to: 

  
  1) Clean the data? 
  
  * Low number of loci individual --> This is done by Franz Parameters. 
  * 

  3)
- Define groups of parents and kids troughout the years. 
- The ones under 80mm FL are juveniles (YOY) : easy.
- The big-tagged individuals are necessarily adults (>100mm). 
--> With the ALLYEARS dataset I just throwed all the fish in the dataset!

  4) Try to get the family structures
  
  - Check Sex ratio in each dataset too.
  - Family size
  - Offsprings sex-ratio
  - Effect of drought on family structure?
  - Check that there is no full-sibs families ACROSS yoy cohorts. (How though?)

  5) Go to Omy5 stuff
  
  - Check Omy5 HWE the overall population, in residents, in anadromous, in Female, in Males.
  - The big-tagged individuals that are >150mm are RESIDENTS.
  - You should see a bias towards: 
      a) RR genotypes should be residents
      b) AA genotypes should be anadromous (i.e absent in >150mm individuals)
      c) AR genotypes should be biased towards :
          1) Females anadromous
          2) Resident males
  - What is the ditribution of Omy5 genotypes in adults vs youngs ?
    --> Espect a residency effect.
  - Juvenile RR families will be rare and small (and we may find a resident mother), 
    while AR individuals and families will be excessively common.
  - Does Omy5 genotype (i.e anadromous behavior) influence family size?
  - Does Omy5 genotype influence lifetime reproductive success? 
    ** Just for individuals that we see as YOY and don't appear after (i.e dead) **
    ** Maybe mostly resident males ? ** 


  X) Do the summary statistics at some point














# -
# The parentage analysis :
# -









From before: 

     METADATA: FullMeta_V3
     GENOTYPES: gtseq7.12_ubc_hap2col_current_vcf.txt

# VI) Clean the data.

Maybe you want to do that after the group selection actually! 

The following will be usefull to rename stuff for FRANz.

```{r}
# Maybe do that ?
# IT's an old piece of code : useless I supose
SuperMoke_good_steelhead <- SuperMoke_goodsex %>% 
  mutate(., Sample_Name = str_replace_all(Sample_Name, "steelhead", "SH_")) %>% 
  mutate(., Sample_Name = str_replace_all(Sample_Name, "SH_0", "SH_")) 

```

THERE IS A PROBLEM EARLIER: samples that have been collected twice or more are not duplicated in the full meta! 




# VII) Define parentage groups
  
  
- Define groups of parents and kids troughout the years. 
- The ones under 80mm FL are juveniles (YOY) : easy.
- The big-tagged individuals are necessarily adults (>100mm). 
 
 I STRUGGLE TO FIND A WAY TO DEFINE POTENTIAL PARENTS. So instead I will do an analysis on ALL the 1995 individuals, and see what comes. 

 
# VIII) Our dataset: all the fish!

The goal of this section is to create a suitable dataset for FRANZ. 
here we use all years to see what it gives ! 
 

```{r}
MetaALLYEARS <- FullMeta_V4   

# No filters here, we analyse everyone together !

head(MetaALLYEARS)
```

Associate these offsprings with the corresponding genotype. 
```{r}
GenoALLYEARS <- gtseq7.12_ubc_hap2col_current_vcf.txt %>% 
  filter(., indiv.ID %in% MetaALLYEARS$indiv.ID)
head(GenoALLYEARS)
```
We have `r nrow(MetaALLYEARS)` metadata fish and `r nrow(GenoALLYEARS)` genotype fish: Is it equal ?

Do a final table with both combined.
```{r}
MetagenoALLYEARS <- MetaALLYEARS %>% 
  left_join(., GenoALLYEARS, by = "indiv.ID" )
MetagenoALLYEARS$Sex <- as.character(MetagenoALLYEARS$Sex)

```

Nice table, almost ready. 
Because the Franz input requires each field of the input to be less than 10 characters,
you need to transform :
  1) The sample.ID
  2) The tag_id
The good thing is here we can use Sample_ID instead, that has the good format :) 

But we still need to get rid of all the useless info!
```{r}
MetagenoALLYEARS_readytotransform <- MetagenoALLYEARS %>% 
  select(., - c(GtSeq_Run, indiv.ID, Sample_Plate, Sample_Well,I7_Index_ID, index, I5_Index_ID, index2 , Sample_Project, NMFS_DNA_ID...23, Plate...11, ...12, ...13, Plate...14, Plate...13, Plates, BOX_ID, BOX_POSITION, SAMPLE_ID, BATCH_ID, PROJECT_NAME, GENUS, SPECIES, LENGTH, WEIGHT, SEX, AGE, REPORTED_LIFE_STAGE, PHENOTYPE, HATCHERY_MARK, TAG_NUMBER, Coll_month, Coll_day, ESTIMATED_DATE, PICKER, PICK_DATE, LEFTOVER_SAMPLE, SAMPLE_COMMENTS, STATE_F, COUNTY_F, WATERSHED, TRIB_1, TRIB_2,  REACH_SITE, HATCHERY, STRAIN, LATITUDE_F, LONGITUDE_F, LOCATION_COMMENTS_F, group))

# Ouah I forgot there was so many useless info ...
# Let's arrange the table so the order of the column is right. 

MetagenoALLYEARS_readytotransform2 <- MetagenoALLYEARS_readytotransform %>% 
  select(., Sample_ID, everything())

# And finally change the names of loci from tag_id to Omy.
names(MetagenoALLYEARS_readytotransform2) <- gsub(x = names(MetagenoALLYEARS_readytotransform2), pattern = "tag_id", replacement = "Omy") 

head(MetagenoALLYEARS_readytotransform2)
nrow(MetagenoALLYEARS_readytotransform2)
ncol(MetagenoALLYEARS_readytotransform2)

 

```
BOUM that's it ! 


In all those years, I wonder what we have: Let's explore. 
```{r}

UBCC_nrow <- MetagenoALLYEARS_readytotransform2 %>% 
  filter(., WATER_NAME == "Upper Big Creek") 
  nrow(UBCC_nrow)
  # 1904 fish from UBC
BC_nrow <- MetagenoALLYEARS_readytotransform2 %>% 
  filter(., WATER_NAME == "Big Creek") 
  nrow(BC_nrow)
  # 91 fish from BC
NAfish_nrow <- MetagenoALLYEARS_readytotransform2 %>% 
  filter(., is.na(WATER_NAME)) 
  nrow(NAfish_nrow)
  head(NAfish_nrow)
  # Zero fish with no info ! that's good :) 
```

    From this point I started another parallel script to test if PO relationships could be assigned by FRANz in the wrong direction (If you want lool at the script "Can parents be counfounded with offsprings.rmd") 

So I still didn't figure out how to deal with the year of birth etc, maybe we will do a fake column after, meanwhile, let's take out the Coll_Year
```{r}

MetagenoALLYEARS_readytotransform3 <- MetagenoALLYEARS_readytotransform2 %>% 
  select(., - c(Coll_year, Pop, WATER_NAME, NMFS_DNA_ID))
head(MetagenoALLYEARS_readytotransform3)
```

We will now write the csv file.
```{r}
write_csv(MetagenoALLYEARS_readytotransform3, path = 'C:/Users/noeba/Desktop/FRANZ_stuff/To_transform/Metageno_readytotransform3.csv' ) 
```









###### AFTER THE CREATION OF THE CSV FILE FOR FRANZ:

 IMPORTANT STEP 
!!! Replace all 'NA' by '?' in the file to transform !! 



Then transform the input thanks to FRANz website tool:  
http://www.bioinf.uni-leipzig.de/Software/FRANz/CSV_Import.html 

** Then pick the transformed 'file' made by the website with ctrl+A and copy it into the txt file of the transformed folder. 
** (Or in any folder you want, just take one)
      
  ###
  ###    But be careful !! 
  ###    If you relaunch FRANz he will replace the files each time :)
  ###
           

## Run Franz

The manual is here : https://www.bioinf.uni-leipzig.de/Software/FRANz/FRANz2.pdf

Here is the command line on windows 10 for running FRANz:

  THE OPTIONS 
 
 1) --mintyped 115            :  This will not change
 2) --typingerror 0.005       :  Same
 3) --hwetestout HWE_test.txt :  To have the HWE test
 4) --Nmax XXX                :  Nmax has to be estimated each time :) 
 
 ---> Estimate Nmax in our 1995 fish dataset (i.e run 7 to 12).
 
```{r}

nrow(FullMeta_V4)
head(FullMeta_V4)

# On the principle, all the fish that are not YOY of 2017 could be parents of the YOY of 2017 or earlier. Thus, if we want the potential parents only: 

YOY_2017 <- FullMeta_V4 %>% 
  filter(., Coll_year == "2017"  & LENGTH <= 80)
nrow(YOY_2017)
head(YOY_2017)

Potential_parents_ALLYEARS <- FullMeta_V4 %>% 
  filter(., !Sample_ID %in% YOY_2017$Sample_ID)
nrow(Potential_parents_ALLYEARS)

# Ok we have the potential parents. How many are males? 

Potential_parents_ALLYEARS %>% 
  filter(., Sex == "M") %>% 
  count()
# 1032 over 1894 fish ! There is quite a bias but I was expecting even more actually :) 


# So this counting is simplistic but we can go for --Nmax of 1032 for now.

```
 
 
 

Celle la c'est celle de Linux, et avec Mokelumne. Faut trouver le bon Nmax pour ici et aussi caler une colonne pour l'âge. 

> FRANz --Nmax ?? --mintyped 115 --typingerror 0.005 --hwetestout HWE_test.txt --femrepro 2:3 --malerepro 2:3

Maybe we want to use the -- maxdepth option, given that we don't know how to figure out the age of the individuals accurately. 

  Here is my line for the 1995 fish dataset (ALLYEARS).
  
   NEXT TIME YOU UPDATE THAT, ADD THE -- detectfullsibs OPTION PLEASE !!  
   NEXT TIME YOU UPDATE THAT, ADD THE -- detectfullsibs OPTION PLEASE !! 
   NEXT TIME YOU UPDATE THAT, ADD THE -- detectfullsibs OPTION PLEASE !! 
   NEXT TIME YOU UPDATE THAT, ADD THE -- detectfullsibs OPTION PLEASE !! 


           FRANz --mintyped 115 --typingerror 0.005 --hwetestout HWE_test.txt --Nmax 1032                    MetagenoALLYEARS_transformed3.csv.txt



Then the results arrive in the folder where the analysed files was.
Move ALL the files of that folder into a dedicated result folder.

Here are the options: 




------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
--------------------------------- Post-FRANz / Results analysis --------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------

## After FRANz

At this point, you have ran FRANz on one or several datasets, whatever. 
You want to look at the results, but that will need some filtering before etc etc. 
Below comes another long part, which is based on what I did in Santa Cruz on Mokelumne fish. 

Let's begin: 

Ok so, here, we use the outputs of Manipulating parentage data Mokelumne and FRANz Haley SNPs scripts FRANz outputs to create your results ! 

What do we want to see here ? 

1) The filters: Each filter will be recorded to facilitate changes and to keep track.

2) Different numbers of trios, single pairs and maybe false positives 
   
3) Family sizes in the datasets

4) More ?





      Special warning: Unlike Mokelumne analysis, we don't need to optimise Nmax for now
      We also don't use COLONY for now so the concerned chunks have been throwed out !
      (If you want to come back to it see 'Parentage_analyzsing_data...after_lab_meeting))


#### Read the parentage file 

This is one of FRANz outputs
Again, change Metageno2017 by the name of the new result folder. 
    (In the object AND in the path!)

```{r}
parentage_MetagenoALLYEARS <- read_csv("C:/Users/noeba/Desktop/FRANZ_stuff/Results/BigCreek_test_ALLYEARS/parentage.csv")

nrow(parentage_MetagenoALLYEARS)
```


#### Filter the results based on prior probability

We set the limit of Posterioir probability at 0.95.
We set the minimu LOD score for parents at a minimum of 5.

!! CHECK THAT YOU CHANGED THE NAME OF OBJECT AND PATH JUST ABOVE !!
   Because after that we don't want to bother to change 2017 by 2015 everywhere ...

```{r}
# Filter it!
  First_filtered_BigCreek <- parentage_MetagenoALLYEARS %>% 
  filter(!is.na(`Parent 1`)) %>%       # Parent ONE to keep single pairs into the dataset
  filter(Posterior >= 0.99) %>%      # Set the filter here
  filter(`Pair LOD Parent 1` >= 5 | `Pair LOD Parent 2` >= 5)  %>% 
  mutate(., TRIOorSP = if_else(is.na(`Parent 2`), "Single_Pair", "Trio"))
nrow(First_filtered_BigCreek)
```

```{r}
First_filtered_BigCreek %>%  count(TRIOorSP)
```


What % of assignment lost with the 0.95 Posterior and 5 Pair LOD filtering ?
```{r}
Without_NA_Unfiltered <- parentage_MetagenoALLYEARS %>% 
  filter(!is.na(`Parent 1`)) %>% 
  mutate(., TRIOorSP = if_else(is.na(`Parent 2`), "Single_Pair", "Trio"))
  
100 - (nrow(First_filtered_BigCreek) * 100) / nrow(Without_NA_Unfiltered) 
```


The chunk above adds also a column that says if we have trios or single-pairs. 

#### UnTidyFRANz function

Neil has made an untidy frame to make working with the data easier. 
Each kid will have 2 rows, 1 row for each parent (sire and dam)

```{r}
tidy_franz <- function(outp) {
  p1 <- outp%>%
    select(Offspring, `Loci Typed`, `Parent 1`, `Loci Typed_1`,LOD, Posterior, `Common Loci Typed`, Mismatches, `Pair LOD Parent 1`, `Posterior Parent 1`, TRIOorSP) %>%
    rename(kid = Offspring, kid_typed = `Loci Typed`, 
         parent = `Parent 1`, parent_typed = `Loci Typed_1`,
         posterior = Posterior, mismatches = Mismatches,
         parent_lod = `Pair LOD Parent 1`,parent_posterior = `Posterior Parent 1`)
 
   p2 <- outp%>%
    select(Offspring, `Loci Typed`, `Parent 2`, `Loci Typed_2`,LOD, Posterior, `Common Loci Typed`, Mismatches, `Pair LOD Parent 2`, `Posterior Parent 2`, TRIOorSP) %>%
    rename(kid = Offspring, kid_typed = `Loci Typed`, 
         parent = `Parent 2`, parent_typed = `Loci Typed_2`,
         posterior = Posterior, mismatches = Mismatches,
         parent_lod = `Pair LOD Parent 2`,parent_posterior = `Posterior Parent 2`)

   bind_rows(p1,p2)
} 
```





AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 
AT THIS POINT YOU CAN SWITCH TO THE SECOND SCRIPT 













 ##### Pieces of code for analysis : Use that at some point?

*PARENTS
```{r}
NumberParentAssign <- Enriched_tidy_coast_BicCreek %>% 
  select(., parent, ParentSex) %>% 
  #filter(., ParentSex == "M") %>% 
  distinct(parent, .keep_all = T) 
nrow(NumberParentAssign) 


# Well I didn't adapted that because there is no point yet. We still didn't figure out how to deal with the age thing.
totparents <- SuperMoke_good_FORMAT %>% 
  select(., Sample_Name, Sex, SpawnYear) %>% 
  filter(., SpawnYear == "2012")
nrow(totparents)

# So 80 / 197 * 100 = 40.609 % of parents assigned ot offsprings
# Bonus: ? males and ? females

```

Offsprings
```{r}
PercKidAssign <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  select(., kid, KidSex) %>% 
  filter(., !Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999$Uniquefrom == "SNPs") %>% 
  #filter(., KidSex == "F") %>% 
  distinct(kid, .keep_all = T)
nrow(PercKidAssign)

totKids <- SuperMoke_good_FORMAT %>% 
  select(., Sample_Name, Sex, SpawnYear) %>% 
  filter(., SpawnYear == "2014")
nrow(totKids)

# 120 kids / 159 found at least a parent! So: 75.471 % of the kids were assigned! 
```


 


















------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------      ||||||||||||||
------------------------ OLD CODE -----------------------------       ||||||||||||
------------------------ OLD CODE -----------------------------        ||||||||||
------------------------ OLD CODE -----------------------------         ||||||||
------------------------ OLD CODE -----------------------------          ||||||
------------------------ OLD CODE -----------------------------           ||||
------------------------ OLD CODE -----------------------------            ||
------------------------ OLD CODE -----------------------------         
------------------------ OLD CODE ----------------------------- 






































################################### PLOT TIME-BUBBLE #####################################

 Some plots -- I redid them with filters. 
Try to combine those plots 
```{r}
# Version 1
V1 <- ggplot(data = tidy_coast_BicCreek) +
geom_histogram( mapping = aes(x = parent_lod), binwidth = 0.5, colour = 'red') +
geom_histogram(data = tidy_coast_BicCreek,  mapping = aes(x = parent_lod), colour = 'green', binwidth = 0.5 ) +
stat_summary(data = tidy_coast_BicCreek, mapping = aes(x = parent_lod, y = mismatches), colour = 'blue') +
stat_summary(data = tidy_coast_BicCreek,  mapping = aes(x = parent_lod, y = mismatches), colour = 'yellow' ) 

# Version 2
V2 <- ggplot(data = tidy_coast_Mykros_Colofiltered) +
geom_histogram( mapping = aes(x = parent_lod, color = as.character(mismatches)), binwidth = 0.5, show.legend = T) +
geom_histogram(data = tidy_coast_SNPs_Colofiltered,  mapping = aes(x = parent_lod, color = as.character(mismatches)), binwidth = 0.5 , show.legend = T) 

ggsave(filename = "V1" ,plot =  V1 , device = 'png', path = '/home/noe/Bureau/New stage/Noe/MicrohapsSteelheadProject/Parentage_Process/Ridiculousplots/' )

ggsave(filename = "V2" ,plot =  V2 , device = 'png', path = '/home/noe/Bureau/New stage/Noe/MicrohapsSteelheadProject/Parentage_Process/Ridiculousplots/' )
```

We can do the same with posterior values! 
```{r}
V3posterior <-   ggplot(data = tidy_coast_Mykros_Colofiltered) +
geom_histogram( mapping = aes(x = parent_posterior, fill = 'Mykro'), binwidth = 0.04, colour = 'red') +
geom_histogram(data = tidy_coast_SNPs_Colofiltered,  mapping = aes(x = parent_posterior, alpha = 'SNP'), colour = 'green', binwidth = 0.04 ) 

ggsave(filename = "V3posterior" ,plot =  V3posterior , device = 'png', path = '/home/noe/Bureau/New stage/Noe/MicrohapsSteelheadProject/Parentage_Process/Ridiculousplots/' )

```

It doesn't say much haha ^^

With the single pairs !
```{r}
# Version 4
V4 <-   ggplot(data = tidy_coast_Mykros_Colofiltered) +
geom_histogram( mapping = aes(x = parent_lod, fill = TRIOorSP, alpha = 4/5), binwidth = 0.5, show.legend = T, position = "identity") +
geom_histogram(data = tidy_coast_SNPs_Colofiltered,  mapping = aes(x = parent_lod, fill = TRIOorSP, alpha = 4/5) , position = "identity", binwidth = 0.5 , show.legend = T) 

ggsave(filename = "V4trioORsnp" ,plot =  V4 , device = 'png', path = '/home/noe/Bureau/New stage/Noe/MicrohapsSteelheadProject/Parentage_Process/Ridiculousplots/' )
```

#############################################################################################################################

 The comparison

For now we looked at some variable, and you have still work to do to join the Colony results and filter all this properly. 
Because the thing is you will first keep only the comparisons common between COLONY and FRANz and then compare SNPs and Mykros.
Once this done, you could run these comparisons. 



Let's compare the numbers 
```{r}
#ComparisonMykros : Potentially including some contradictions between SNPs and Mykros! 
  tidy_coast_Mykros_Nmax104_Colofiltered %>% 
  nrow(.)
  tidy_coast_SNPs_Nmax104_Colofiltered %>% 
  nrow(.)
  
  #ComparisonMykros : Potentially including some contradictions between SNPs and Mykros! 
  tidy_coast_Mykros_Nmax208_Colofiltered %>% 
  nrow(.)
  tidy_coast_SNPs_Nmax208_Colofiltered %>% 
  nrow(.)
  
  #ComparisonMykros : Potentially including some contradictions between SNPs and Mykros! 
  tidy_coast_Mykros_Nmax1040_Colofiltered %>% 
  nrow(.)
  tidy_coast_SNPs_Nmax1040_Colofiltered %>% 
  nrow(.)
  
  #ComparisonMykros : Potentially including some contradictions between SNPs and Mykros! 
  tidy_coast_Mykros_Nmax10400_Colofiltered %>% 
  nrow(.)
  tidy_coast_SNPs_Nmax10400_Colofiltered %>% 
  nrow(.)
  
  #ComparisonMykros : Potentially including some contradictions between SNPs and Mykros! 
  tidy_coast_Mykros_Nmax104000_Colofiltered %>% 
  nrow(.)
  tidy_coast_SNPs_Nmax104000_Colofiltered %>% 
  nrow(.)

    #ComparisonMykros : Potentially including some contradictions between SNPs and Mykros! 
  tidy_coast_Mykros_Nmax10400000_Colofiltered %>% 
  nrow(.)
  tidy_coast_SNPs_Nmax10400000_Colofiltered %>% 
  nrow(.)  
```

```{r}
# Comparison for Nmax: 
FullCOMPARISONzonzon_Nmax104 <- tidy_coast_Mykros_Nmax104_Colofiltered %>% 
  full_join(., tidy_coast_SNPs_Nmax104_Colofiltered, by = c('kid', 'parent')) 
nrow(FullCOMPARISONzonzon_Nmax104) # We gain some more, so there is contradictions.

# Comparison for Nmax: 
FullCOMPARISONzonzon_Nmax208 <- tidy_coast_Mykros_Nmax208_Colofiltered %>% 
  full_join(., tidy_coast_SNPs_Nmax208_Colofiltered, by = c('kid', 'parent')) 
nrow(FullCOMPARISONzonzon_Nmax208) # We gain some more, so there is contradictions.

# Comparison for Nmax: 
FullCOMPARISONzonzon_Nmax1040 <- tidy_coast_Mykros_Nmax1040_Colofiltered %>% 
  full_join(., tidy_coast_SNPs_Nmax1040_Colofiltered, by = c('kid', 'parent')) 
nrow(FullCOMPARISONzonzon_Nmax1040) # We gain some more, so there is contradictions.

# Comparison for Nmax: 
FullCOMPARISONzonzon_Nmax10400 <- tidy_coast_Mykros_Nmax10400_Colofiltered %>% 
  full_join(., tidy_coast_SNPs_Nmax10400_Colofiltered, by = c('kid', 'parent')) 
nrow(FullCOMPARISONzonzon_Nmax10400) # We gain some more, so there is contradictions.

# Comparison for Nmax: 
FullCOMPARISONzonzon_Nmax104000 <- tidy_coast_Mykros_Nmax104000_Colofiltered %>% 
  full_join(., tidy_coast_SNPs_Nmax104000_Colofiltered, by = c('kid', 'parent')) 
nrow(FullCOMPARISONzonzon_Nmax104000) # We gain some more, so there is contradictions.

# Comparison for Nmax: 
FullCOMPARISONzonzon_Nmax10400000 <- tidy_coast_Mykros_Nmax10400000_Colofiltered %>% 
  full_join(., tidy_coast_SNPs_Nmax10400000_Colofiltered, by = c('kid', 'parent')) 
nrow(FullCOMPARISONzonzon_Nmax10400000) # We gain some more, so there is contradictions.
```

 Create a dataset with assignments unique to SNPs for each Nmax value
```{r}
uniquetoSNPS_Nmax104 <- FullCOMPARISONzonzon_Nmax104 %>% 
  filter(., is.na(kid_typed.x)) %>% 
  select(., c(kid,parent,kid_typed.y,parent_typed.y,LOD.y,posterior.y,`Common Loci Typed.y`,mismatches.y,parent_lod.y,parent_posterior.y,TRIOorSP.y))
nrow(uniquetoSNPS_Nmax104)

uniquetoSNPS_Nmax208 <- FullCOMPARISONzonzon_Nmax208 %>% 
  filter(., is.na(kid_typed.x)) %>% 
  select(., c(kid,parent,kid_typed.y,parent_typed.y,LOD.y,posterior.y,`Common Loci Typed.y`,mismatches.y,parent_lod.y,parent_posterior.y,TRIOorSP.y))
nrow(uniquetoSNPS_Nmax208)

uniquetoSNPS_Nmax1040 <- FullCOMPARISONzonzon_Nmax1040 %>% 
  filter(., is.na(kid_typed.x)) %>% 
  select(., c(kid,parent,kid_typed.y,parent_typed.y,LOD.y,posterior.y,`Common Loci Typed.y`,mismatches.y,parent_lod.y,parent_posterior.y,TRIOorSP.y))
nrow(uniquetoSNPS_Nmax1040)

uniquetoSNPS_Nmax10400 <- FullCOMPARISONzonzon_Nmax10400 %>% 
  filter(., is.na(kid_typed.x)) %>% 
  select(., c(kid,parent,kid_typed.y,parent_typed.y,LOD.y,posterior.y,`Common Loci Typed.y`,mismatches.y,parent_lod.y,parent_posterior.y,TRIOorSP.y))
nrow(uniquetoSNPS_Nmax10400)

uniquetoSNPS_Nmax104000 <- FullCOMPARISONzonzon_Nmax104000 %>% 
  filter(., is.na(kid_typed.x)) %>% 
  select(., c(kid,parent,kid_typed.y,parent_typed.y,LOD.y,posterior.y,`Common Loci Typed.y`,mismatches.y,parent_lod.y,parent_posterior.y,TRIOorSP.y))
nrow(uniquetoSNPS_Nmax104000)

uniquetoSNPS_Nmax10400000 <- FullCOMPARISONzonzon_Nmax10400000 %>% 
  filter(., is.na(kid_typed.x)) %>% 
  select(., c(kid,parent,kid_typed.y,parent_typed.y,LOD.y,posterior.y,`Common Loci Typed.y`,mismatches.y,parent_lod.y,parent_posterior.y,TRIOorSP.y))
nrow(uniquetoSNPS_Nmax10400000)
  
# Create a dataset with assignments unique to Mykros for each Nmax value
uniquetoMykros_Nmax104 <- FullCOMPARISONzonzon_Nmax104 %>% 
  filter(., is.na(kid_typed.y)) %>% 
  select(., c(kid,parent,kid_typed.x,parent_typed.x,LOD.x,posterior.x,`Common Loci Typed.x`,mismatches.x,parent_lod.x,parent_posterior.x,TRIOorSP.x))
nrow(uniquetoMykros_Nmax104)

uniquetoMykros_Nmax208 <- FullCOMPARISONzonzon_Nmax208 %>% 
  filter(., is.na(kid_typed.y)) %>% 
  select(., c(kid,parent,kid_typed.x,parent_typed.x,LOD.x,posterior.x,`Common Loci Typed.x`,mismatches.x,parent_lod.x,parent_posterior.x,TRIOorSP.x))
nrow(uniquetoMykros_Nmax208)

uniquetoMykros_Nmax1040 <- FullCOMPARISONzonzon_Nmax1040 %>% 
  filter(., is.na(kid_typed.y)) %>% 
  select(., c(kid,parent,kid_typed.x,parent_typed.x,LOD.x,posterior.x,`Common Loci Typed.x`,mismatches.x,parent_lod.x,parent_posterior.x,TRIOorSP.x))
nrow(uniquetoMykros_Nmax1040)

uniquetoMykros_Nmax10400 <- FullCOMPARISONzonzon_Nmax10400 %>% 
  filter(., is.na(kid_typed.y)) %>% 
  select(., c(kid,parent,kid_typed.x,parent_typed.x,LOD.x,posterior.x,`Common Loci Typed.x`,mismatches.x,parent_lod.x,parent_posterior.x,TRIOorSP.x))
nrow(uniquetoMykros_Nmax10400)

uniquetoMykros_Nmax104000 <- FullCOMPARISONzonzon_Nmax104000 %>% 
  filter(., is.na(kid_typed.y)) %>% 
  select(., c(kid,parent,kid_typed.x,parent_typed.x,LOD.x,posterior.x,`Common Loci Typed.x`,mismatches.x,parent_lod.x,parent_posterior.x,TRIOorSP.x))
nrow(uniquetoMykros_Nmax104000)

uniquetoMykros_Nmax10400000 <- FullCOMPARISONzonzon_Nmax10400000 %>% 
  filter(., is.na(kid_typed.y)) %>% 
  select(., c(kid,parent,kid_typed.x,parent_typed.x,LOD.x,posterior.x,`Common Loci Typed.x`,mismatches.x,parent_lod.x,parent_posterior.x,TRIOorSP.x))
nrow(uniquetoMykros_Nmax10400000)
```




Now that I have the assignments unique for both, I can clean the big comparison to have only the common ones. 
Once this done, I could begin to quantify : Number of trios, SP, but also specify that, after a filtering (I'll do one more strict I guess), all those additionnal assignments unique to SNPs will blow away !! 

```{r}
# We have here a comparison of the common assignments. 
# We do some rename also :)
CommonComparisonZonzon_Nmax104 <- FullCOMPARISONzonzon_Nmax104 %>% 
  filter_all(., all_vars(!is.na(.))) %>% 
  select(., TRIOorSP.x, everything())
names(CommonComparisonZonzon_Nmax104) <- gsub(".y", "_SNPs", names(CommonComparisonZonzon_Nmax104)) 
names(CommonComparisonZonzon_Nmax104) <- gsub(".x", "_mykros", names(CommonComparisonZonzon_Nmax104)) 
CommonComparisonZonzon_Nmax104 <- CommonComparisonZonzon_Nmax104 %>% 
  rename(., posteriorColony_SNPs = posteriorColo_SNPs_SNPs) %>% 
  rename(., posteriorColony_Mykros = posteriorColo_SNPs_mykros)
nrow(CommonComparisonZonzon_Nmax104)

CommonComparisonZonzon_Nmax208 <- FullCOMPARISONzonzon_Nmax208 %>% 
  filter_all(., all_vars(!is.na(.))) %>% 
  select(., TRIOorSP.x, everything())
names(CommonComparisonZonzon_Nmax208) <- gsub(".y", "_SNPs", names(CommonComparisonZonzon_Nmax208)) 
names(CommonComparisonZonzon_Nmax208) <- gsub(".x", "_mykros", names(CommonComparisonZonzon_Nmax208)) 
CommonComparisonZonzon_Nmax208 <- CommonComparisonZonzon_Nmax208 %>% 
  rename(., posteriorColony_SNPs = posteriorColo_SNPs_SNPs) %>% 
  rename(., posteriorColony_Mykros = posteriorColo_SNPs_mykros)
nrow(CommonComparisonZonzon_Nmax208)

CommonComparisonZonzon_Nmax1040 <- FullCOMPARISONzonzon_Nmax1040 %>% 
  filter_all(., all_vars(!is.na(.))) %>% 
  select(., TRIOorSP.x, everything())
names(CommonComparisonZonzon_Nmax1040) <- gsub(".y", "_SNPs", names(CommonComparisonZonzon_Nmax1040)) 
names(CommonComparisonZonzon_Nmax1040) <- gsub(".x", "_mykros", names(CommonComparisonZonzon_Nmax1040)) 
CommonComparisonZonzon_Nmax1040 <- CommonComparisonZonzon_Nmax1040 %>% 
  rename(., posteriorColony_SNPs = posteriorColo_SNPs_SNPs) %>% 
  rename(., posteriorColony_Mykros = posteriorColo_SNPs_mykros)
nrow(CommonComparisonZonzon_Nmax1040)

CommonComparisonZonzon_Nmax10400 <- FullCOMPARISONzonzon_Nmax10400 %>% 
  filter_all(., all_vars(!is.na(.))) %>% 
  select(., TRIOorSP.x, everything())
names(CommonComparisonZonzon_Nmax10400) <- gsub(".y", "_SNPs", names(CommonComparisonZonzon_Nmax10400)) 
names(CommonComparisonZonzon_Nmax10400) <- gsub(".x", "_mykros", names(CommonComparisonZonzon_Nmax10400)) 
CommonComparisonZonzon_Nmax10400 <- CommonComparisonZonzon_Nmax10400 %>% 
  rename(., posteriorColony_SNPs = posteriorColo_SNPs_SNPs) %>% 
  rename(., posteriorColony_Mykros = posteriorColo_SNPs_mykros)
nrow(CommonComparisonZonzon_Nmax10400)

CommonComparisonZonzon_Nmax104000 <- FullCOMPARISONzonzon_Nmax104000 %>% 
  filter_all(., all_vars(!is.na(.))) %>% 
  select(., TRIOorSP.x, everything())
names(CommonComparisonZonzon_Nmax104000) <- gsub(".y", "_SNPs", names(CommonComparisonZonzon_Nmax104000)) 
names(CommonComparisonZonzon_Nmax104000) <- gsub(".x", "_mykros", names(CommonComparisonZonzon_Nmax104000)) 
CommonComparisonZonzon_Nmax104000 <- CommonComparisonZonzon_Nmax104000 %>% 
  rename(., posteriorColony_SNPs = posteriorColo_SNPs_SNPs) %>% 
  rename(., posteriorColony_Mykros = posteriorColo_SNPs_mykros)
nrow(CommonComparisonZonzon_Nmax104000)

CommonComparisonZonzon_Nmax10400000 <- FullCOMPARISONzonzon_Nmax10400000 %>% 
  filter_all(., all_vars(!is.na(.))) %>% 
  select(., TRIOorSP.x, everything())
names(CommonComparisonZonzon_Nmax10400000) <- gsub(".y", "_SNPs", names(CommonComparisonZonzon_Nmax10400000)) 
names(CommonComparisonZonzon_Nmax10400000) <- gsub(".x", "_mykros", names(CommonComparisonZonzon_Nmax10400000)) 
CommonComparisonZonzon_Nmax10400000 <- CommonComparisonZonzon_Nmax10400000 %>% 
  rename(., posteriorColony_SNPs = posteriorColo_SNPs_SNPs) %>% 
  rename(., posteriorColony_Mykros = posteriorColo_SNPs_mykros)
nrow(CommonComparisonZonzon_Nmax10400000)

```
 Exploit this in a plot, it's a decent summary. 


 Quantification
I checked the numbers and they add up to the total: My code works! 

The common things:
Trust most of them. 
Filter the contradictions to decide who's right. 
```{r}
# The common things Pairs
CommonSinglePairs_Nmax104 <- CommonComparisonZonzon_Nmax104 %>% 
  filter(., TRIOorSP_mykros == "Single_Pair" & TRIOorSP_SNPs == "Single_Pair")
nrow(CommonSinglePairs_Nmax104)

CommonSinglePairs_Nmax208 <- CommonComparisonZonzon_Nmax208 %>% 
  filter(., TRIOorSP_mykros == "Single_Pair" & TRIOorSP_SNPs == "Single_Pair")
nrow(CommonSinglePairs_Nmax208)

CommonSinglePairs_Nmax1040 <- CommonComparisonZonzon_Nmax1040 %>% 
  filter(., TRIOorSP_mykros == "Single_Pair" & TRIOorSP_SNPs == "Single_Pair")
nrow(CommonSinglePairs_Nmax1040)

CommonSinglePairs_Nmax10400 <- CommonComparisonZonzon_Nmax10400 %>% 
  filter(., TRIOorSP_mykros == "Single_Pair" & TRIOorSP_SNPs == "Single_Pair")
nrow(CommonSinglePairs_Nmax10400)

CommonSinglePairs_Nmax104000 <- CommonComparisonZonzon_Nmax104000 %>% 
  filter(., TRIOorSP_mykros == "Single_Pair" & TRIOorSP_SNPs == "Single_Pair")
nrow(CommonSinglePairs_Nmax104000)

CommonSinglePairs_Nmax10400000 <- CommonComparisonZonzon_Nmax10400000 %>% 
  filter(., TRIOorSP_mykros == "Single_Pair" & TRIOorSP_SNPs == "Single_Pair")
nrow(CommonSinglePairs_Nmax10400000)


# The common things Trios

CommonTrios_Nmax104 <- CommonComparisonZonzon_Nmax104 %>% 
  filter(., TRIOorSP_mykros == "Trio" & TRIOorSP_SNPs == "Trio") %>% 
  add_count(., kid)%>% 
  select(., - n)  #Because there is an odd number of rows, so some trio is incomplete here, but only here
nrow(CommonTrios_Nmax104)

CommonTrios_Nmax208 <- CommonComparisonZonzon_Nmax208 %>% 
  filter(., TRIOorSP_mykros == "Trio" & TRIOorSP_SNPs == "Trio") %>% 
  add_count(., kid) %>% 
  select(., - n)
nrow(CommonTrios_Nmax208)

CommonTrios_Nmax1040 <- CommonComparisonZonzon_Nmax1040 %>% 
  filter(., TRIOorSP_mykros == "Trio" & TRIOorSP_SNPs == "Trio") %>% 
  add_count(., kid) %>% 
  select(., - n)
nrow(CommonTrios_Nmax1040)

CommonTrios_Nmax10400 <- CommonComparisonZonzon_Nmax10400 %>% 
  filter(., TRIOorSP_mykros == "Trio" & TRIOorSP_SNPs == "Trio") %>% 
  add_count(., kid) %>% 
  select(., - n)
nrow(CommonTrios_Nmax10400)

CommonTrios_Nmax104000 <- CommonComparisonZonzon_Nmax104000 %>% 
  filter(., TRIOorSP_mykros == "Trio" & TRIOorSP_SNPs == "Trio") %>% 
  add_count(., kid) %>% 
  select(., - n)
nrow(CommonTrios_Nmax104000)

CommonTrios_Nmax10400000 <- CommonComparisonZonzon_Nmax10400000 %>% 
  filter(., TRIOorSP_mykros == "Trio" & TRIOorSP_SNPs == "Trio") %>% 
  add_count(., kid) %>% 
  select(., - n)
nrow(CommonTrios_Nmax10400000)


# Contradictions in common assignments. 
CommonContradictions_Nmax104 <- CommonComparisonZonzon_Nmax104 %>% 
  filter(., TRIOorSP_mykros != TRIOorSP_SNPs ) %>% 
  mutate(., WhoIsRight = if_else(LOD_mykros >= LOD_SNPs, "trustMykros", "trustSNPs"))

# Contradictions in common assignments. 
CommonContradictions_Nmax208 <- CommonComparisonZonzon_Nmax208 %>% 
  filter(., TRIOorSP_mykros != TRIOorSP_SNPs ) %>% 
  mutate(., WhoIsRight = if_else(LOD_mykros >= LOD_SNPs, "trustMykros", "trustSNPs"))

# Contradictions in common assignments. 
CommonContradictions_Nmax1040 <- CommonComparisonZonzon_Nmax1040 %>% 
  filter(., TRIOorSP_mykros != TRIOorSP_SNPs ) %>% 
  mutate(., WhoIsRight = if_else(LOD_mykros >= LOD_SNPs, "trustMykros", "trustSNPs"))

# Contradictions in common assignments. 
CommonContradictions_Nmax10400 <- CommonComparisonZonzon_Nmax10400 %>% 
  filter(., TRIOorSP_mykros != TRIOorSP_SNPs ) %>% 
  mutate(., WhoIsRight = if_else(LOD_mykros >= LOD_SNPs, "trustMykros", "trustSNPs"))

# Contradictions in common assignments. 
CommonContradictions_Nmax104000 <- CommonComparisonZonzon_Nmax104000 %>% 
  filter(., TRIOorSP_mykros != TRIOorSP_SNPs ) %>% 
  mutate(., WhoIsRight = if_else(LOD_mykros >= LOD_SNPs, "trustMykros", "trustSNPs"))

# Contradictions in common assignments. 
CommonContradictions_Nmax10400000 <- CommonComparisonZonzon_Nmax10400000 %>% 
  filter(., TRIOorSP_mykros != TRIOorSP_SNPs ) %>% 
  mutate(., WhoIsRight = if_else(LOD_mykros >= LOD_SNPs, "trustMykros", "trustSNPs"))

```

 What's going on with the uniques ? 

Check that those ar uniques, first. 
```{r}
CheckUniqueMykros <- uniquetoMykros_Nmax10400000 %>% 
  inner_join(., CommonSinglePairs_Nmax10400000, by =c("kid","parent")) 

CheckUniqueMykros <- uniquetoMykros_Nmax10400000 %>% 
  inner_join(., CommonTrios_Nmax10400000, by =c("kid","parent")) 
# 0 rows in both cases : good!

CheckUniqueSNPs <- uniquetoSNPS_Nmax10400000 %>% 
  inner_join(., CommonSinglePairs_Nmax10400000, by =c("kid","parent")) 

CheckUniqueSNPs <- uniquetoSNPS_Nmax10400000 %>% 
  inner_join(., CommonTrios_Nmax10400000, by =c("kid","parent")) 
# 0 rows in both cases : good!
```
They are unique !!

Can we find them in each other ? 
```{r}
InnerUnique <- uniquetoSNPS_Nmax10400000 %>% 
  inner_join(., uniquetoMykros_Nmax10400000, by =c("kid","parent")) 
```
Nope ! 


Do they concern the same parents, kid ? 
```{r}
Unique_crossParents_Nmax104 <- uniquetoSNPS_Nmax104 %>% 
  inner_join(., uniquetoMykros_Nmax104, by =c("parent"))
# Concerning 1 common parent : SH_771 and offspring SH_1124

Unique_crossParents_Nmax208 <- uniquetoSNPS_Nmax208 %>% 
  inner_join(., uniquetoMykros_Nmax208, by =c("parent"))
# Concerning 4 common parent 

Unique_crossParents_Nmax1040 <- uniquetoSNPS_Nmax1040 %>% 
  inner_join(., uniquetoMykros_Nmax1040, by =c("parent"))
# Concerning 4  same common parent : SH_858, SH_793, SH_846, SH_781
# For offsprings : SH_1120 (858x846) and SH_1125 (781x793)

# THe results are the same for the following values. 

Unique_crossParents_Nmax10400 <- uniquetoSNPS_Nmax10400 %>% 
  inner_join(., uniquetoMykros_Nmax10400, by =c("parent"))

Unique_crossParents_Nmax104000 <- uniquetoSNPS_Nmax104000 %>% 
  inner_join(., uniquetoMykros_Nmax104000, by =c("parent"))

Unique_crossParents_Nmax10400000 <- uniquetoSNPS_Nmax10400000 %>% 
  inner_join(., uniquetoMykros_Nmax10400000, by =c("parent"))



Unique_crossKids <- uniquetoSNPS %>% 
  inner_join(., uniquetoMykros, by =c("kid"))
```
Yeah, some of them, but not a lot. 

I guess that, anyway, it doesn't matter because I just have to filter them on posterior or likelihood after rbind.



rbind the uniques
```{r}
# I need homogeneous unique datasets
uniquetoMykros_Nmax104 <- uniquetoMykros_Nmax104 %>% 
  mutate(., Uniquefrom = "Mykros")
# Replace x by y in order to merge them :)
names(uniquetoMykros_Nmax104) <- gsub(".x", ".y", names(uniquetoMykros_Nmax104)) 

uniquetoMykros_Nmax208 <- uniquetoMykros_Nmax208 %>% 
  mutate(., Uniquefrom = "Mykros")
# Replace x by y in order to merge them :)
names(uniquetoMykros_Nmax208) <- gsub(".x", ".y", names(uniquetoMykros_Nmax208)) 

uniquetoMykros_Nmax1040 <- uniquetoMykros_Nmax1040 %>% 
  mutate(., Uniquefrom = "Mykros")
# Replace x by y in order to merge them :)
names(uniquetoMykros_Nmax1040) <- gsub(".x", ".y", names(uniquetoMykros_Nmax1040)) 

uniquetoMykros_Nmax10400 <- uniquetoMykros_Nmax10400 %>% 
  mutate(., Uniquefrom = "Mykros")
# Replace x by y in order to merge them :)
names(uniquetoMykros_Nmax10400) <- gsub(".x", ".y", names(uniquetoMykros_Nmax10400)) 

uniquetoMykros_Nmax104000 <- uniquetoMykros_Nmax104000 %>% 
  mutate(., Uniquefrom = "Mykros")
# Replace x by y in order to merge them :)
names(uniquetoMykros_Nmax104000) <- gsub(".x", ".y", names(uniquetoMykros_Nmax104000)) 

uniquetoMykros_Nmax10400000 <- uniquetoMykros_Nmax10400000 %>% 
  mutate(., Uniquefrom = "Mykros")
# Replace x by y in order to merge them :)
names(uniquetoMykros_Nmax10400000) <- gsub(".x", ".y", names(uniquetoMykros_Nmax10400000)) 


uniquetoSNPS_Nmax104 <- uniquetoSNPS_Nmax104 %>% 
  mutate(., Uniquefrom = "SNPS")
# Replace x by y in order to merge them :)
names(uniquetoSNPS_Nmax104) <- gsub(".x", ".y", names(uniquetoSNPS_Nmax104)) 

uniquetoSNPS_Nmax208 <- uniquetoSNPS_Nmax208 %>% 
  mutate(., Uniquefrom = "SNPS")
# Replace x by y in order to merge them :)
names(uniquetoSNPS_Nmax208) <- gsub(".x", ".y", names(uniquetoSNPS_Nmax208)) 

uniquetoSNPS_Nmax1040 <- uniquetoSNPS_Nmax1040 %>% 
  mutate(., Uniquefrom = "SNPS")
# Replace x by y in order to merge them :)
names(uniquetoSNPS_Nmax1040) <- gsub(".x", ".y", names(uniquetoSNPS_Nmax1040)) 

uniquetoSNPS_Nmax10400 <- uniquetoSNPS_Nmax10400 %>% 
  mutate(., Uniquefrom = "SNPS")
# Replace x by y in order to merge them :)
names(uniquetoSNPS_Nmax10400) <- gsub(".x", ".y", names(uniquetoSNPS_Nmax10400)) 

uniquetoSNPS_Nmax104000 <- uniquetoSNPS_Nmax104000 %>% 
  mutate(., Uniquefrom = "SNPS")
# Replace x by y in order to merge them :)
names(uniquetoSNPS_Nmax104000) <- gsub(".x", ".y", names(uniquetoSNPS_Nmax104000)) 

uniquetoSNPS_Nmax10400000 <- uniquetoSNPS_Nmax10400000 %>% 
  mutate(., Uniquefrom = "SNPS")
# Replace x by y in order to merge them :)
names(uniquetoSNPS_Nmax10400000) <- gsub(".x", ".y", names(uniquetoSNPS_Nmax10400000)) 

Troutrelics_Nmax104 <- rbind(uniquetoSNPS_Nmax104,uniquetoMykros_Nmax104)
Troutrelics_Nmax208 <- rbind(uniquetoSNPS_Nmax208,uniquetoMykros_Nmax208)
Troutrelics_Nmax1040 <- rbind(uniquetoSNPS_Nmax1040,uniquetoMykros_Nmax1040)
Troutrelics_Nmax10400 <- rbind(uniquetoSNPS_Nmax10400,uniquetoMykros_Nmax10400)
Troutrelics_Nmax104000 <- rbind(uniquetoSNPS_Nmax104000,uniquetoMykros_Nmax104000)
Troutrelics_Nmax10400000 <- rbind(uniquetoSNPS_Nmax10400000,uniquetoMykros_Nmax10400000)

setdiff(CommonTrios_Nmax104, CommonSinglePairs_Nmax104)
CommonTrust_Nmax104 <- rbind(CommonTrios_Nmax104, CommonSinglePairs_Nmax104)
CommonTrust_Nmax208 <- rbind(CommonTrios_Nmax208, CommonSinglePairs_Nmax208)
CommonTrust_Nmax1040 <- rbind(CommonTrios_Nmax1040, CommonSinglePairs_Nmax1040)
CommonTrust_Nmax10400 <- rbind(CommonTrios_Nmax10400, CommonSinglePairs_Nmax10400)
CommonTrust_Nmax104000 <- rbind(CommonTrios_Nmax104000, CommonSinglePairs_Nmax104000)
CommonTrust_Nmax10400000 <- rbind(CommonTrios_Nmax10400000, CommonSinglePairs_Nmax10400000)

```

Ok this thing of Nmax lead to nowhere... I need to choose the dataset now. 
What do we want as info ? The LOD ? 

Get the average LOD/parent for each value of Nmax for Common assignments. 
```{r}
mean(CommonTrust_Nmax104$parent_lod_mykros)
mean(CommonTrust_Nmax208$parent_lod_mykros)
mean(CommonTrust_Nmax1040$parent_lod_mykros)
mean(CommonTrust_Nmax10400$parent_lod_mykros)
mean(CommonTrust_Nmax104000$parent_lod_mykros)
mean(CommonTrust_Nmax10400000$parent_lod_mykros)

mean(CommonTrust_Nmax104$parent_lod_SNPs)
mean(CommonTrust_Nmax208$parent_lod_SNPs)
mean(CommonTrust_Nmax1040$parent_lod_SNPs)
mean(CommonTrust_Nmax10400$parent_lod_SNPs)
mean(CommonTrust_Nmax104000$parent_lod_SNPs)
mean(CommonTrust_Nmax10400000$parent_lod_SNPs)
```


Get the average LOD/parent for each value of Nmax for UNIQUE assignments. 
```{r}
mean(uniquetoSNPS_Nmax104$parent_lod.y)
mean(uniquetoSNPS_Nmax208$parent_lod.y)
mean(uniquetoSNPS_Nmax1040$parent_lod.y)
mean(uniquetoSNPS_Nmax10400$parent_lod.y)
mean(uniquetoSNPS_Nmax104000$parent_lod.y)
mean(uniquetoSNPS_Nmax10400000$parent_lod.y)

mean(uniquetoMykros_Nmax104$parent_lod.y)
mean(uniquetoMykros_Nmax208$parent_lod.y)
mean(uniquetoMykros_Nmax1040$parent_lod.y)
mean(uniquetoMykros_Nmax10400$parent_lod.y)
mean(uniquetoMykros_Nmax104000$parent_lod.y)
mean(uniquetoMykros_Nmax10400000$parent_lod.y)
```




Just prepare SUperMokeGoodformat for the sex information (It's the genotypes matrix)
```{r}
#Note that kid and parent are the same here, to make my life easier when joining. 
SeaSexandSpawn <- SuperMoke_good_FORMAT %>% 
  select(., Sample_Name, Sex, SpawnYear) 

  SeaSexforKids <- SeaSexandSpawn %>% 
  rename(., kid = Sample_Name) %>% 
  select(., - SpawnYear)

  SeaSexforParents <- SeaSexandSpawn %>% 
  rename(., parent = Sample_Name) %>% 
  select(., - SpawnYear)
  
  SeaSpawnforParents <- SeaSexandSpawn %>% 
  rename(., parent = Sample_Name) %>% 
  select(., - Sex)
  
   SeaSpawnforKids <- SeaSexandSpawn %>% 
  rename(., kid = Sample_Name) %>% 
  select(., - Sex)
```

 We choose: Nmax = 1040 for filter = 0.9999

We want to know if the uniques assignments are the fact of a few parents or a bunch. 
It could explain why all Mykros unique SP are 2012 parents for example
```{r}
# First the single pairs:
UniqueFamilies_MykroSP_Nmax1040 <- Troutrelics_Nmax1040 %>% 
  filter(., Uniquefrom == "Mykros") %>% 
  filter(., TRIOorSP.y == "Single_Pair") %>% 
  add_count(., parent) %>% 
  select(., parent, n) %>% 
  distinct(.) %>% 
  left_join(., SeaSexforParents, by = "parent") %>% 
  left_join(., SeaSpawnforParents, by = "parent")
  # Those 22 single pairs involved 16 different parents !

UniqueFamilies_snpSP_Nmax1040 <- Troutrelics_Nmax1040 %>% 
  filter(., Uniquefrom == "SNPS") %>% 
  filter(., TRIOorSP.y == "Single_Pair") %>% 
  add_count(., parent) %>% 
  select(., parent, n) %>% 
  distinct(.) %>% 
  left_join(., SeaSexforParents, by = "parent") %>% 
  left_join(., SeaSpawnforParents, by = "parent")
 # Those 6 single pairs involved 3 different parents !

# Then the trios

UniqueFamilies_MykroTRIO_Nmax1040 <- Troutrelics_Nmax1040 %>% 
  filter(., Uniquefrom == "Mykros") %>% 
  filter(., TRIOorSP.y == "Trio") %>% 
  add_count(., kid) %>% 
  left_join(., SeaSexforParents, by = "parent") %>% 
  left_join(., SeaSpawnforParents, by = "parent")
  # do nrow/2 = nb of trios = 35 
nrow(UniqueFamilies_MykroTRIO_Nmax1040)

UniqueFamilies_snpTRIO_Nmax1040 <- Troutrelics_Nmax1040 %>% 
  filter(., Uniquefrom == "SNPS") %>% 
  filter(., TRIOorSP.y == "Trio") %>% 
  add_count(., kid) %>% 
  left_join(., SeaSexforParents, by = "parent") %>% 
  left_join(., SeaSpawnforParents, by = "parent")
 # do nrow/2 = nb of trios = 4
nrow(UniqueFamilies_snpTRIO_Nmax1040)
```


 Decide what to do of the uniques Trios of Nmax 1040

Ok so now our SNPs have 0 unqie SP (good!) and 4 complete unique trios. 
The goal is to eliminate them (i.e prove that they were assigned by mykros earlier, but with low confidence, or, ultimately, verify that they are in the SNPpit analysis). 
If we do, we just have to merge our Mykros unique and common and boum!, we count the interesting numbers etc and go forward. 

```{r}
# Are the four unique trios of SNPs present in the pre-filter mykro dataset? 

NotfilteredMykro <- Mykro_parentage_Nmax1040 %>% 
  mutate(., TRIOorSP = if_else(is.na(`Parent 2`), "Single_Pair", "Trio"))
tidyNotfilteredMykro <- tidy_franz(NotfilteredMykro) 

TRIOrigin <- UniqueFamilies_snpTRIO_Nmax1040 %>% 
  left_join(., tidyNotfilteredMykro, by = "kid")

# I looked and the 4 trios have all explanations !
# I will keep only the last one : Off909 and P1058 and 1141
head(UniqueFamilies_snpTRIO_Nmax1040)
nrow(UniqueFamilies_snpTRIO_Nmax1040)
```

 The unique unique SNP trio to keep
```{r}
TRIOtoaddtomykros <- UniqueFamilies_snpTRIO_Nmax1040 %>% 
  filter(., kid == "SH_909")
```

 Do the final dataset for summarizing
1)We want to add : CommonTrust_Nmax1040 + uniquetoMykros_Nmax1040 + TRIOtoaddtomykros
2)Then add them spawn and sex data if they are incomplete. 
3)Then check that there is not 3 parents for a kid.
4)Then check that trios are complete and SP incompletes! 

1)We want to add : CommonTrust_Nmax1040 + uniquetoMykros_Nmax1040 + TRIOtoaddtomykros
It would be nice to specify somewhere that the 909 trio is unique from SNP. 
```{r}
#Merge the uniques in a clean dataset. 
TRIOtoaddtomykros_clean <- TRIOtoaddtomykros %>% 
  select(., c(kid, parent,LOD.y,posterior.y,mismatches.y,parent_lod.y,parent_posterior.y,TRIOorSP.y,Uniquefrom)) 
  names(TRIOtoaddtomykros_clean) <- gsub(".y", "_SNPs", names(TRIOtoaddtomykros_clean)) 
  
FinalUniquesNmax1040 <- uniquetoMykros_Nmax1040 %>% 
    select(., c(kid, parent,LOD.y,posterior.y,mismatches.y,parent_lod.y,parent_posterior.y,TRIOorSP.y,Uniquefrom)) 
  names(FinalUniquesNmax1040) <- gsub(".y", "_mykros", names(FinalUniquesNmax1040)) 

MergedUniquesNmax1040 <- FinalUniquesNmax1040 %>% 
  full_join(., TRIOtoaddtomykros_clean)

# Prepare the common to welcome the uniques:
PartoneofCommon <- CommonTrust_Nmax1040 %>% 
  select(., -c(kid__SNPsped_mykros, parent__SNPsped_mykros, `Common Loci _SNPsped_mykros`, Generations_mykros, parents_mykros_mykros,HighestP_mykros,kid__SNPsped_SNPs,`Common Loci _SNPsped_SNPs`,Generations_SNPs,parents_mykros_SNPs,HighestP_SNPs, parent__SNPsped_SNPs)) %>% 
  mutate(., Uniquefrom = "Common")

  setdiff(PartoneofCommon, MergedUniquesNmax1040)

# Join 'em!!!! 
FinalNmax104_ParentageDataset <- PartoneofCommon %>% 
  full_join(.,MergedUniquesNmax1040 )

head(CommonTrust_Nmax1040)
head(uniquetoMykros_Nmax1040)
head(TRIOtoaddtomykros)

View(CommonTrust_Nmax1040)
View(uniquetoMykros_Nmax1040)
View(TRIOtoaddtomykros)
```

2)Then add them spawn and sex data if they are incomplete. 
```{r}
FinalNmax104_ParentageDataset_CompleteSex <- FinalNmax104_ParentageDataset %>% 
  left_join(., SeaSexforParents, by = "parent") %>% 
  rename(., ParentSex = Sex) %>% 
  left_join(., SeaSexforKids, by = "kid") %>% 
  rename(., KidSex = Sex) %>% 
  left_join(., SeaSpawnforKids, by = "kid") %>% 
  rename(., KidSpawnYear = SpawnYear) %>% 
  left_join(., SeaSpawnforParents, by = "parent") %>% 
  rename(., ParentSpawnYear = SpawnYear)
```

3)Then check that there is not 3 parents for a kid.
```{r}
FinalNmax104_ParentageDataset_NoContradictions <- FinalNmax104_ParentageDataset_CompleteSex %>% 
  add_count(., kid) %>%  
  rename(., CloneKid = n)
```

4)Then check that trios are complete and SP incompletes! 
```{r}
# This dataset should have zero rows :) 
FinalNmax104_ParentageDataset_INCOMPATTRIOSP <- FinalNmax104_ParentageDataset_NoContradictions %>% 
  filter(., TRIOorSP_mykros != TRIOorSP_SNPs)
    # If 0 rows, at least there is no contradictions :)

#We can now filter Trios, check their add_count and same for SP
FinalNmax104_ParentageDataset_INValidTRIO <- FinalNmax104_ParentageDataset_NoContradictions %>% 
  filter(.,TRIOorSP_mykros == "Trio" & CloneKid != "2" )
FinalNmax104_ParentageDataset_INValidSP <- FinalNmax104_ParentageDataset_NoContradictions %>% 
  filter(.,TRIOorSP_mykros == "Single_Pair" & CloneKid != "1" )
nrow(FinalNmax104_ParentageDataset_INValidSP)
```

OK, good, the dataset looks clean :) 

 Visualize and summarize

1) Absolute useful values
```{r}
Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 <-  FinalNmax104_ParentageDataset_NoContradictions

# Number of trios:
Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., TRIOorSP_mykros == "Trio" | TRIOorSP_SNPs == "Trio" ) %>%   # Cause of the solo trio
  nrow(.)
   # Divide by 2

# Number of common trios : 
  Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., TRIOorSP_mykros == "Trio") %>% 
  filter(., Uniquefrom == "Common") %>%  
  nrow(.)
   # Divide by 2
  
  # Number of SP:
Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., TRIOorSP_mykros == "Single_Pair" | TRIOorSP_SNPs == "Single_Pair" ) %>%   # Cause of the solo trio
  nrow(.)

  # Number of common SP:
Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., TRIOorSP_mykros == "Single_Pair" | TRIOorSP_SNPs == "Single_Pair" ) %>%   # Cause of the solo trio
    filter(., Uniquefrom == "Common") %>%  
  nrow(.)

head(Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999)
```


2) Compare the markers in their common assignments:
```{r}
COOMMONS <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., Uniquefrom == "Common")
# LOD / PARENT
mean(COOMMONS$parent_lod_mykros)
mean(COOMMONS$parent_lod_SNPs)

LodMyk <- COOMMONS$parent_lod_mykros
LodSNP <- COOMMONS$parent_lod_SNPs
t.test(LodMyk, LodSNP)

# POSTERIOR 
mean(COOMMONS$posterior_mykros)
mean(COOMMONS$posterior_SNPs)

PostMyk <- COOMMONS$posterior_mykros
PostSNP <- COOMMONS$posterior_SNPs
t.test(PostMyk, PostSNP)

head(Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999)
```

3) Compare Unique and Common values in Mykros, to understand why they were unique! 
```{r}
COMTRIOS <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., Uniquefrom == "Common") %>% 
  filter(., TRIOorSP_mykros == "Trio")

UNIKTRIOS <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., Uniquefrom == "Mykros") %>% 
  filter(., TRIOorSP_mykros == "Trio")

mean(COMTRIOS$parent_lod_mykros)
mean(UNIKTRIOS$parent_lod_mykros)
mean(COMTRIOS$posterior_mykros)
mean(UNIKTRIOS$posterior_mykros)

```


4) Compare single pairs and trios
```{r}
TRIOSTRIOS <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., TRIOorSP_mykros == "Trio")

SPSPSP <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., TRIOorSP_mykros == "Single_Pair")

mean(TRIOSTRIOS$parent_lod_mykros)
mean(SPSPSP$parent_lod_mykros)
mean(TRIOSTRIOS$posterior_mykros)
mean(SPSPSP$posterior_mykros)
```

5) How much % of kids and parents assigned? 

  ### SNPS ###

PARENTS
```{r}
PercParentAssign <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  select(., parent, ParentSex) %>% 
  filter(., !Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999$Uniquefrom == "Mykros") %>% 
  #filter(., ParentSex == "M") %>% 
  distinct(parent, .keep_all = T) 
nrow(PercParentAssign) 

totparents <- SuperMoke_good_FORMAT %>% 
  select(., Sample_Name, Sex, SpawnYear) %>% 
  filter(., SpawnYear == "2012")
nrow(totparents)

# So 50 / 197 * 100 = 25.380 % of parents assigned ot offsprings
# Bonus: ? males and ? females

```

Offsprings
```{r}
PercKidAssign <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  select(., kid, KidSex) %>% 
  filter(., !Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999$Uniquefrom == "Mykros") %>% 
  #filter(., KidSex == "F") %>% 
  distinct(kid, .keep_all = T)
nrow(PercKidAssign)

totKids <- SuperMoke_good_FORMAT %>% 
  select(., Sample_Name, Sex, SpawnYear) %>% 
  filter(., SpawnYear == "2014")
nrow(totKids)

# 66 kids / 159 found at least a parent! So: 41.509 % of offsprngs were assigned
```


 ### MYKROS ###

PARENTS
```{r}
PercParentAssign <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  select(., parent, ParentSex) %>% 
  filter(., !Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999$Uniquefrom == "SNPs") %>% 
  #filter(., ParentSex == "M") %>% 
  distinct(parent, .keep_all = T) 
nrow(PercParentAssign) 

totparents <- SuperMoke_good_FORMAT %>% 
  select(., Sample_Name, Sex, SpawnYear) %>% 
  filter(., SpawnYear == "2012")
nrow(totparents)

# So 80 / 197 * 100 = 40.609 % of parents assigned ot offsprings
# Bonus: ? males and ? females

```

Offsprings
```{r}
PercKidAssign <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  select(., kid, KidSex) %>% 
  filter(., !Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999$Uniquefrom == "SNPs") %>% 
  #filter(., KidSex == "F") %>% 
  distinct(kid, .keep_all = T)
nrow(PercKidAssign)

totKids <- SuperMoke_good_FORMAT %>% 
  select(., Sample_Name, Sex, SpawnYear) %>% 
  filter(., SpawnYear == "2014")
nrow(totKids)

# 120 kids / 159 found at least a parent! So: 75.471 % of the kids were assigned! 
```


 # Family sizes !!
Check the family sizes: what is the strategy ? 
If I filter out the males, group by parent and add_count the kids, It should work !
Then I do the same for females and I'll have the number of families and I could even plot their distrib. 
If we define a family by common kids of two individuals or kids of a single pair. 
```{r}
# Sires firts
Familyguys <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., !ParentSex == "F") %>% 
  add_count(parent) %>% 
  rename(., Number_of_kids = n)
# Dams after
WomensPower <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  filter(., !ParentSex == "M") %>% 
  add_count(parent) %>% 
  rename(., Number_of_kids = n)

# How many families ? 
FAMILIES <- Parentage_Noe_Mokelumne_Final_Nmax1040_Filter09999 %>% 
  group_by(kid) %>% 
    distinct(., kid, .keep_all = T) %>% 
  ungroup() %>% 
  distinct(parent, .keep_all = T)

nrow(FAMILIES)
head(Familyguys)
```
A plot for FAMILIES
```{r}
Malesmales <- Familyguys %>% 
  distinct(., parent, .keep_all = T)
Femalesfemales <- WomensPower %>% 
  distinct(., parent, .keep_all = T)

# Do some subset to plot the abline of distribution of SP vs TRIO
SPmales <- Familyguys %>% 
  filter(., TRIOorSP_mykros == "Single_Pair" | TRIOorSP_SNPs == "Single_Pair")
SPfemales <- WomensPower %>% 
  filter(., TRIOorSP_mykros == "Single_Pair" | TRIOorSP_SNPs == "Single_Pair")
SPdistrib <- rbind(SPmales, SPfemales) %>% 
  distinct(., parent, .keep_all = T)

Triomales <- Familyguys %>% 
  filter(., TRIOorSP_mykros == "Trio" | TRIOorSP_SNPs == "Trio")
Triofemales <- WomensPower %>% 
  filter(., TRIOorSP_mykros == "Trio" | TRIOorSP_SNPs == "Trio")
Triodistrib <- rbind(Triomales, Triofemales)
Triodistrib <- Triodistrib %>% 
  distinct(., parent, .keep_all = T)

nrow(Triomales)
nrow(Triofemales)

# The kolmogorov smirnov test ! 
Zgeg1 <- Malesmales$Number_of_kids
Zgeg2 <- Femalesfemales$Number_of_kids
ks.test( Zgeg1, Zgeg2, alternative = "two.sided")

# The kolmogorov smirnov test ! For trio vs SP
Zgeg11 <- Triodistrib$Number_of_kids
Zgeg22 <- SPdistrib$Number_of_kids
ks.test( Zgeg11, Zgeg22, alternative = "two.sided")


FAMILYPLOT <-    ggplot(Malesmales,aes(x= Number_of_kids))+ 
    geom_histogram(data=subset(Malesmales, ParentSex=='M'),aes(fill=ParentSex),alpha=0.4, stat = "density")+
    geom_histogram(data=subset(Femalesfemales,ParentSex=='F'),aes(fill=ParentSex),alpha=0.4,  stat = "density")+
    geom_density(data=subset(Triodistrib), aes(x= Number_of_kids, color = TRIOorSP_mykros)) + 
    geom_density(data=subset(SPdistrib), aes(x= Number_of_kids, color = TRIOorSP_mykros ))+
    ylim(0, 0.3) +
    scale_fill_manual(name="ParentSex", values=c("gold","black"),labels=c("Males","Females")) +
    scale_color_discrete(name = "Assignment type", labels=c("Trio","Single-Pair") )
    

ggsave(filename = "FamilySize" ,plot =  FAMILYPLOT , device = 'png', path = '/home/noe/Bureau/New stage/Noe/MicrohapsSteelheadProject/Parentage_Process/Ridiculousplots/' )

 http://www.sthda.com/english/wiki/ggplot2-histogram-easy-histogram-graph-with-ggplot2-r-package
 #list of colors: 
   http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf

```

Do a sort of funny plot with that ! :D


Check sex incompatibilites
```{r}
XES <- VictoryParentage %>% 
  group_by(., kid) %>% 
  add_count(., ParentSex)
# No sex incompatibilities !!
```




 # Verify Sex locus

** Reader: Note that this piece of code is made in haste and it's totally dependent on the other scripts about parentage "manipulating" and "analyzing". Also, I checked and SEX info looks more than fiable :)

I did the Sex info very quickly cause I was in haste, so I hope there is no problem with it ... 

1) Re-check the concordance read-infered sex
2) Re-Check the concardance of this with SEX from meta. 
3) For suspicious individuals (i.e in the limit of reads to be F or M), maybe do a quick run of FRANz by manually changing their sex to see if they assign to someone. 

1) Re-check the concordance read-infered sex
```{r}
# My genotype info : 
RUN5_info <- GenoMeta5 %>% 
  select(., Sample_ID, Sample_Name, SEX, SpawnYear, popInd)
# I have to work on the format as previously made: 
SuperMoke_goodsex <- RUN5_info %>% 
  mutate(., Sex = str_replace_all(SEX, "Female", "F"))
SuperMoke_goodsex <- SuperMoke_goodsex %>%
  select(Sex, everything())
SuperMoke_goodsex <- SuperMoke_goodsex %>% 
  mutate(., Sex = str_replace_all(Sex, "Male", "M"))
SuperMoke_goodsex <- SuperMoke_goodsex %>%
  select(Sex, everything()) 
SuperMoke_goodsex <- SuperMoke_goodsex %>% select(- SEX)
SuperMoke_good_steelhead <- SuperMoke_goodsex %>% 
  mutate(., Sample_Name = str_replace_all(Sample_Name, "steelhead", "SH_")) %>% 
  mutate(., Sample_Name = str_replace_all(Sample_Name, "SH_0", "SH_")) 
SuperMoke_good_steelhead <- SuperMoke_good_steelhead %>%
  select(Sample_Name, everything())  
# OK, we have here the Sex info from meta: Just filter individuals presents in SuperMokegoodformat. 

# Set the summary sheet: Normally Anthony is doing it and you just use it :D
steelhead_gtseq5_summary <- read_excel("Bureau/New stage/Noe/MicrohapsSteelheadProject/Run5_results /steelhead_gtseq5_summary.xlsx",  sheet = "greb1_etc")
steelhead_gtseq5_summary_simple <- steelhead_gtseq5_summary %>% 
  filter(., loc == "omyY1_2SEXY" )  %>% 
  gather(., key = "Individuals", value = "sexreads") %>% 
  filter(., !Individuals %in% c("loc", 'total5', "PrI(>=10)"))%>% 
  mutate(., sexreads = as.integer(sexreads)) %>% 
  arrange(., sexreads) %>% 
  mutate(., Sample_Name = str_replace_all(Individuals, "s", "SH_")) %>% 
  select(., Sample_Name, sexreads) %>% 
  filter(., Sample_Name %in% SuperMoke_good_FORMAT$Sample_Name)
  
# We have our 356 fish, their sexreads, good sample names :) 
nrow(steelhead_gtseq5_summary_simple)

SuperMoke_CompletesexTEST <- SuperMoke_good_steelhead %>% 
   left_join(., steelhead_gtseq5_summary_simple, by = "Sample_Name") %>% 
  filter(., Sample_Name %in% steelhead_gtseq5_summary_simple$Sample_Name)%>%
arrange(., sexreads)  %>% 
  distinct(., Sample_Name, .keep_all = T)

nrow(SuperMoke_CompletesexTEST)
View(SuperMoke_CompletesexTEST)

SexContradictions <- SuperMoke_CompletesexTEST %>% 
  filter(., Sex == "F" & sexreads >= 5)

# Ok the most interesting observation is that, from reads 0 to 3, Meta and 2sexy says FEMALE. 
# After, for reads of 10+ it's all males! 
# There is just a doubt on a reads 5 individual (SH_1000) where meta has no sex, but anyway it's an offspring. 
# Also, there is 7 contradictions, but all have reads from 100 to 300 so I trusted Mykros. 
# Anyway, they are offspring also. 


# Number of missing sex info in the 356 fish of parentage
missingsex <- SuperMoke_CompletesexTEST %>% 
  filter(., is.na(Sex))
nrow(missingsex)
# 197 fish with no sex info in the meta : 197/356*100 = 55.33%
```






































