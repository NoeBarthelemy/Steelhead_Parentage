---
title: "Big_Creek_script_9_Parentage+Sibship"
author: 'Noé Barthelemy'
date: "26 mars 2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
> knitr::opts_chunk$set(cache =TRUE)

```{r}
#save.image (file = "Big_Creek_Script9.RData")
#load("Big_Creek_Script9.RData")
```

# Library

```{r}
library(tidyverse)
library(esquisse)
library(ggplot2) 

library(readxl)
library(adegenet)
library(poppr)
library(ecodist)
library(vegan)
library(diveRsity)
library(zvau) # to write genepop file for summary stats
library(car)  #for Levene test
library(JGmisc) # To get the function to detach all packages
# OR to detach all packages 
# invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE))

# Below maybe nice for pedigree plotting
#devtools::install_github("alosdiallo/Pedigree")

```


# I) Introduction

## A) What do we have ? 

So here, let's make a summary of what we have: 

  - Sibship data : 
  
     For all fish  : Per individual info : UBC_run1_SibSize_META_Allfish
                     Per sibship info    : Mini_Summary_per_Sibgroup_Allfish
                      The two datasets are complementary!
     
     For YOYs only : Per individual info : UBC_run1_SibSize_META_Result_YOY_V3
                     Per sibship info    : Mini_Summary_per_Sibgroup_YOYs
                      The two datasets are complementary!
  
  - Parentage data : Enriched_nicerun_V3 
  (This is the data from the new run, with no duplicates and with sibhip info, enriched with metadata and more)
  
## B) What did we do ?   

Script 1 : We impoted the data, linked to metadata etc and did the first FRANz RUn. 
Script 2 : We enriched the parentage results, we checked for sex incompatibilities and computed family size. Note that we did that all over again in script 8 for the second run. 
Script 3 : This was done for importing and treating Omy5 information and check for incompatibilities in parentage data of the first run.
Script 4 : 
        Lots was done in script 4: 
        - A summary of the questions for the paper
        - Sex ratios: In global dataset (1995 fish) and in first parentage dataset (for kids, for parents, per year)
        - Family sizes were computed. Some correlations were investigated, but nothing amazing. 
Script 5 : This script is quite independent since it was done to check if parental relationships could be reversed by accident (an offspring being assigned as the parent of his true parent and vice versa). The conclusion is that this risk is very minor, and absent in trios! 
Script 6 : This script was done to identify duplicates in our dataset. It appeared that they were 186 duplicates that we removed (in Duplicates_to_remove_CERVUS). It is important to note that we kept the information of their duplicate mates so you can use that later. 
Also, we noticed that something was weird with the 2013 cohort, you should investigate that again. 
Script 7 : The sibship analysis: Duplicates were removed, and Anthony used COLONY 2.0 to run a sibship analysis (details of the run are found in BigCreek project/Analysis/Sibship_analysis/Sibship_analysis_COLONYv2/Results_Run1_AntonyClemento/UBC_colony_run1/ProjectInformation.Txt). We prepared the dataset, enriched it with metadata and many new variables like sibship size, length of sibship per year, and summarised it per sibship in a table (Mini_Summary_per_Sibgroup_Allfish). Then, we did a first analysis on all the fish and then one on the YOYs only (We confirmed that all the YOY individuals in a fullsib group were from the same year, we calculated sex ratios accross years and did a mini-summary about the YOY sibships).
Script 8 : We ran Franz again, but this time we used slightly different parameters (check script 8), we removed duplicates and we used a fullsib file as an input to help Franz to get more accurate assignments. Then, we filtered the assignments, we counted the number of trios and snps, we enriched the parentage file with metadata. Then, we confirmed that there was no Omy5 incompatibilities within the families, not a single one! 
Then, we calculated some sex ratios (in the whole dataset, and in the parenatge dataset (in parents and kids), per years as well). 




# II) Big creek and distances

## A) Link distance data with our genetic data. 

Two pieces to link : 

### 1) Our meta: 
We will use FullMeta_V4 cause it's very complete. 

```{r}
head(FullMeta_V4)
```

##### Minimeta_noDup !



I use this little space to create a minimeta with no clones: 
```{r}
Minimeta_V8_noDup <- Minimeta_V8 %>% 
  filter(., !Sample_ID %in% Duplicates_to_remove_CERVUS$Mate_to_remove) %>% 
  mutate(., YOY = ifelse(test = LENGTH < 95, "YES", "no"))
```



### 2) Distance data :

"Upper_Big_Creek_fall_tisue_sample_data_2010_2017_with_distance_for_Devon_12Mar2019"
 This dataset has been uploaded earlier in script one so you should have it already. It contains all the tag, distance, year, fork length etc of all years, i.e 2010 to 2017.

```{r}
Rundio_raw <- Upper_Big_Creek_fall_tisue_sample_data_2010_2017_with_distance_for_Devon_12Mar2019
```

```{r}
# Prepare Rundio_raw
# We prefer to split the capture date because 
Rundio_cooked <- Rundio_raw %>% 
  separate(., col = capture_date, into = c("Coll_year", "Coll_month", "Coll_day") , sep =  "-", remove = F) %>% 
  select(., -c("stream", "year")) %>% 
  rename(., LENGTH = "fl")
Rundio_cooked$fish_num <- as.character(Rundio_cooked$fish_num)
Rundio_cooked$Envelope_num <- as.character(Rundio_cooked$Envelope_num)

```
 
 
### 3) Link 'em !

 
```{r}
Ultimate_key_V1 <- FullMeta_V4 %>%  # Take the genetics meta identifiers 
  select(., Sample_ID, SAMPLE_ID, LENGTH , Coll_year, Coll_month, Coll_day, PROJECT_NAME)

# Select and prepare the ones with a bad format
Ultimate_key_format_1 <- Ultimate_key_V1 %>% 
  filter(., PROJECT_NAME == "Big Creek Mark-Recapture" | PROJECT_NAME == "Big Creek WCRO project") %>% 
  separate(., col = SAMPLE_ID, into = c("population", "Coll_date", "Envelope_num"), remove = F) %>% 
  left_join(., Rundio_cooked, by = c("Coll_year", "Coll_month", "Coll_day", "Envelope_num", "LENGTH")) %>% 
  select(., c("Sample_ID", "SAMPLE_ID" , "fish_num", "Envelope_num", "LENGTH", "Coll_year", "Coll_month", "Coll_day", "tagged", "distance" ) )

# Now the ones with a good format, with no project name (NA)
Ultimate_key_format_2 <- Ultimate_key_V1 %>% 
  filter(., is.na(PROJECT_NAME)) %>% 
  separate(., col = SAMPLE_ID, into = c("fish_num", "Envelope_num", "Tagged"), sep= "_" , remove = F) %>% 
  left_join(., Rundio_cooked, by = c("fish_num", "Coll_year", "Coll_month", "Coll_day", "Envelope_num", "LENGTH" )) %>% 
  select(., c("Sample_ID", "SAMPLE_ID" , "fish_num", "Envelope_num", "LENGTH", "Coll_year", "Coll_month", "Coll_day", "tagged", "distance" ) )

Distance_Ultimate_key_V2 <- rbind(Ultimate_key_format_1, Ultimate_key_format_2)
```

## B) Write the final distance data
 
```{r}
write_csv(Distance_Ultimate_key_V2, "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Summary_tables/Some_tables_from_R/Distance_Genetics_BigCreek_Ultimate_key_V2.csv")
```
 
 Now you can use Distance_Ultimate_key_V2 to have distance information ! :D 
 
 
## C) Update Minimeta with distance

```{r}
Distance_Ultimate_key_V2_distanceOnly <- Distance_Ultimate_key_V2 %>% 
  select(., Sample_ID, distance)

Minimeta_V8 <- Minimeta_V7 %>% 
  left_join(., Distance_Ultimate_key_V2_distanceOnly, by = "Sample_ID" ) %>% 
  select(., -c(fish_num, Tagged_throw, Size_throw))
  
```

 
# III) Join Parentage and sibship data  

Here the goal is to join the parentage data to the sibship data: 
We have kids: 

> Who are their parents? 
> Are they caught-date-size-compatible with their supposed kids? --> Yes ! 
> Are there conflicts between sibships? i.e do more than two parents are found for a given sibship? --> Nope ! 
> If the above mentioned conflicts occur, do they follow a pattern? --> Lower prior and sometimes mismatches
>> Can that be used to eliminate dodgy sibships? 
>>> Can a link be made with all those probabilities? --> Filter prior > 0.90 does the job
> What's happening with the Omy5 genotypes?  --> No incompatibilities

  - Sibship data : 
  
     For all fish  : Per individual info : Filtered_Fullsibs
                                   (which is UBC_run1_SibSize_META_Allfish filtered for Prob.inc > 0.90)
                     Per sibship info    : Mini_Summary_per_Sibgroup_Allfish
                      The two datasets are complementary!
                     
     For YOYs only : Per individual info : UBC_run1_SibSize_META_Result_YOY_V3
                     Per sibship info    : Mini_Summary_per_Sibgroup_YOYs
                      The two datasets are complementary!
  
  - Parentage data : Enriched_nicerun_V3 
  (This is the data from the new run, with no duplicates and with sibhip info, enriched with metadata and more)


 Le truc c'est que la on utilises tout les sibships mais ça crée plein d'erreurs, c'est surement plus prudent de prendre que les sibships de YOY mais on perdrait plein d'informations ... 
Ya peut être moyen de créer une règle afin de voir lesquels sont crédibles ou pas ? 
Et aussi, dans quelles mesures les parentages et sibships assignments sont interbiasées ? 

## A) Prepare the sibship info to join to parentage data

```{r}
Sibship_basic_info_to_join_with_parentage <- Filtered_Fullsibs %>% 
  select(., c(FullSibshipIndex, Sibship_Member))


SibsAndParentage_V1 <- Enriched_nicerun_V3 %>% 
  left_join(., Sibship_basic_info_to_join_with_parentage, by = c("kid" = "Sibship_Member") ) %>% 
  mutate(., Kid_Fullsibship_Index = ifelse(is.na(FullSibshipIndex), "None", FullSibshipIndex  )) %>% 
  select(., - "FullSibshipIndex") %>% 
  left_join(., Sibship_basic_info_to_join_with_parentage, by = c("Dad" = "Sibship_Member") ) %>% 
  mutate(., Dad_Fullsibship_Index = ifelse(is.na(FullSibshipIndex), "None", FullSibshipIndex  )) %>% 
  select(., - "FullSibshipIndex") %>% 
  left_join(., Sibship_basic_info_to_join_with_parentage, by = c("Mom" = "Sibship_Member") ) %>% 
  mutate(., Mom_Fullsibship_Index = ifelse(is.na(FullSibshipIndex), "None", FullSibshipIndex  )) %>% 
  select(., - "FullSibshipIndex") %>% 
  mutate(., Incompatible_sibship = if_else( Kid_Fullsibship_Index == Dad_Fullsibship_Index & Kid_Fullsibship_Index  == Mom_Fullsibship_Index & Kid_Fullsibship_Index != "None", "Both_Incompatible", if_else(Kid_Fullsibship_Index == Mom_Fullsibship_Index & Kid_Fullsibship_Index != "None", "Mom_Incompatible", if_else(Kid_Fullsibship_Index == Dad_Fullsibship_Index & Kid_Fullsibship_Index != "None", "Dad_Incompatible", "OK"  ))))  
  
```

## B) Sibship-parentage incompatibilities

So we see above that there are quite some incompatibilities! 
Maybe Franz would need to have the larger sibship info, rather than just the YoYs ... ? 
But for that you would need to verify and filter the larger sibship file. 
 
```{r}
library(ggplot2)

ggplot(SibsAndParentage_V1) +
 aes(x = Incompatible_sibship, y = Mismatches) +
 geom_boxplot(fill = "#0c4c8a") +
 theme_minimal() +
 facet_wrap(vars(TRIOorSP))
```

Let's join summary sibship info to see if we can discriminate bad assignments from good ones. 
Maybe the solution is simply to feed Franz with the larger sibship file (i.e including non-yoys)

```{r}
# Prepare the most useful sibship summary info to join to kids and parents. 

Basic_Mini_Summary_per_Sibgroup_Allfish <- Mini_Summary_per_Sibgroup_Allfish %>% 
  select(., FullSibshipIndex, `Prob(Inc.)`, `Prob(Exc.)`, Sibsize, Perc.Male)   

# Append _kid to this one for joining purposes
Basic_Mini_Summary_per_Sibgroup_Allfish_KIDS <- Basic_Mini_Summary_per_Sibgroup_Allfish  
colnames(Basic_Mini_Summary_per_Sibgroup_Allfish_KIDS) <- paste(colnames(Basic_Mini_Summary_per_Sibgroup_Allfish_KIDS), "_kid", sep = "")
Basic_Mini_Summary_per_Sibgroup_Allfish_KIDS$FullSibshipIndex_kid <- as.character(Basic_Mini_Summary_per_Sibgroup_Allfish_KIDS$FullSibshipIndex_kid)

# Append _mom to this one for joining purposes
Basic_Mini_Summary_per_Sibgroup_Allfish_MOMS <- Basic_Mini_Summary_per_Sibgroup_Allfish  
colnames(Basic_Mini_Summary_per_Sibgroup_Allfish_MOMS) <- paste(colnames(Basic_Mini_Summary_per_Sibgroup_Allfish_MOMS), "_mom", sep = "")
Basic_Mini_Summary_per_Sibgroup_Allfish_MOMS$FullSibshipIndex_mom <- as.character(Basic_Mini_Summary_per_Sibgroup_Allfish_MOMS$FullSibshipIndex_mom)

# Append _dad to this one for joining purposes
Basic_Mini_Summary_per_Sibgroup_Allfish_DADS <- Basic_Mini_Summary_per_Sibgroup_Allfish  
colnames(Basic_Mini_Summary_per_Sibgroup_Allfish_DADS) <- paste(colnames(Basic_Mini_Summary_per_Sibgroup_Allfish_DADS), "_dad", sep = "")
Basic_Mini_Summary_per_Sibgroup_Allfish_DADS$FullSibshipIndex_dad <- as.character(Basic_Mini_Summary_per_Sibgroup_Allfish_DADS$FullSibshipIndex_dad)
```
 

```{r}
SibsAndParentage_V2 <- SibsAndParentage_V1 %>% 
  left_join(., Basic_Mini_Summary_per_Sibgroup_Allfish_KIDS, by = c("Kid_Fullsibship_Index" = "FullSibshipIndex_kid")) %>% 
  left_join(., Basic_Mini_Summary_per_Sibgroup_Allfish_MOMS, by = c("Mom_Fullsibship_Index" = "FullSibshipIndex_mom")) %>% 
  left_join(., Basic_Mini_Summary_per_Sibgroup_Allfish_DADS, by = c("Dad_Fullsibship_Index" = "FullSibshipIndex_dad"))  
   
```
  
  
```{r} 
library(ggplot2)

ggplot(SibsAndParentage_V2) +
 aes(x = Incompatible_sibship, y = Sibsize_kid) +
 geom_boxplot(fill = "#0c4c8a") +
 theme_minimal()
```

## C) Sibships with more than two parents?   

Maybe that happens! Let's check 
 
```{r}
Number_of_Moms_per_sibship <- SibsAndParentage_V2 %>% 
  ungroup() %>% 
  group_by(Kid_Fullsibship_Index) %>%  
  summarize(number_of_Moms = n_distinct(Mom))

Number_of_Dads_per_sibship <- SibsAndParentage_V2 %>% 
  ungroup() %>% 
  group_by(Kid_Fullsibship_Index) %>%  
  summarize(number_of_Dads = n_distinct(Dad))  
   
Multi_parents_sibships <- Number_of_Moms_per_sibship %>% 
  full_join(., Number_of_Dads_per_sibship, by = "Kid_Fullsibship_Index") %>% 
  filter(., number_of_Moms > 1 | number_of_Dads > 1 ) %>% 
  filter(., !Kid_Fullsibship_Index == "None")
  
```
 
Yes !!! We have no incompatible sibships (i.e no sibship has more than one dad or Mom, which make sense since we gave Franz the list of fullsibships).
 


## D) Are all parents and kids date-length compatible? 

In other words, can we check that all the parents are older and larger than their kids? 
This is tricky because we have to take into account the size and the date together. (i.e a parent caught small 2011 may have had a kid in 2012, and we caught that kid in 2015, being really bigger than the parent!)

```{r}
SibsAndParentage_V2.5 <- SibsAndParentage_V2 %>%
  ungroup( ) %>% 
 # select(., c(TRIOorSP, Coll_year_kid, LENGTH_kid, Mom, Dad, Momsize, MomYear, Dadsize, DadYear)) %>% 
  mutate(., Length_diff_Dad_Kid_comment = ifelse(  is.na(Dad), "No_Dad", 
                                          ifelse( DadYear < Coll_year_kid & Dadsize > LENGTH_kid  , "Older_bigger_dad", 
                                          ifelse( DadYear < Coll_year_kid & Dadsize < LENGTH_kid  , "Older_smaller_dad", 
                                          ifelse( DadYear > Coll_year_kid & Dadsize < LENGTH_kid, "Incompatible", 
                                          ifelse( DadYear > Coll_year_kid & Dadsize > LENGTH_kid  , "Later_bigger_dad", 
                                          ifelse( DadYear == Coll_year_kid & Dadsize > LENGTH_kid , "Same_Year_Bigger_Dad" , 
                                          ifelse( DadYear == Coll_year_kid & Dadsize < LENGTH_kid , "Same_Year_Smaller_Dad" , 
                                          ifelse( DadYear == Coll_year_kid & Dadsize == LENGTH_kid , "Incompatible", 
                                                  "Check" ))))))))) %>% 
  mutate(., Length_diff_Dad_Kid = abs(Dadsize - LENGTH_kid)) %>% 
  mutate(., Year_diff_Dad_Kid = abs(as.numeric(DadYear) - as.numeric(Coll_year_kid))) %>% 
  mutate(., Length_diff_perYear_Dad_Kid = (Dadsize - LENGTH_kid) / (as.numeric(DadYear) - as.numeric(Coll_year_kid)) ) %>% 
  mutate(., Length_diff_Mom_Kid_comment = ifelse(  is.na(Mom), "No_Mom", 
                                          ifelse( MomYear < Coll_year_kid & Momsize > LENGTH_kid  , "Older_bigger_Mom", 
                                          ifelse( MomYear < Coll_year_kid & Momsize < LENGTH_kid  , "Older_smaller_Mom", 
                                          ifelse( MomYear > Coll_year_kid & Momsize < LENGTH_kid, "Incompatible", 
                                          ifelse( MomYear > Coll_year_kid & Momsize > LENGTH_kid  , "Later_bigger_Mom", 
                                          ifelse( MomYear == Coll_year_kid & Momsize > LENGTH_kid , "Same_Year_Bigger_Mom" , 
                                          ifelse( MomYear == Coll_year_kid & Momsize < LENGTH_kid , "Same_Year_Smaller_Mom" , 
                                          ifelse( MomYear == Coll_year_kid & Momsize == LENGTH_kid , "Incompatible", 
                                                  "Check" ))))))))) %>% 
  mutate(., Length_diff_perYear_Mom_Kid = (Momsize - LENGTH_kid) / (as.numeric(MomYear) - as.numeric(Coll_year_kid)) )
  
```

```{r}
SibsAndParentage_V2.5 %>%  count(., Length_diff_Mom_Kid_comment)
```

```{r}
SibsAndParentage_V2.5 %>%  count(., Length_diff_Dad_Kid_comment)
```
The ones causing problems here are : "Incompatible" and "Same_Year_Smaller_Dad/Mom" and then the other cateogries may hide problems too but this will depend on length differences. 


The incompatible ones are SP and have less than 0.9999 in parentage probability. However, all the parentage incompatibilities don't have less than 0.999 proba ! 

Then we computed the length difference per year Dad/Mom: 
  - "Later_bigger" : the higher the better! You want to verify the ones with the lowest Length_diff_perYear 
  - "Older_bigger" : These should be fine but better take a look-see
  - "Older_smaller_dad" : Really depends ... Have to find a rule ! 

# REPORT THIS ABOVE : NEED DEVON's HELP 


## E) Number of sibship per parent
 
 Computed as the number of reproduction events for each parent. 
 
 Special case if: 
 1) A parent has several SP
 2) no sibships were identified for the kids of the SP
Then we count all the SP as only one single pair. 
 
 But before we do one thing : 
 
 What about kids with no sibship ? Maybe they have a sibship of confidence in which they are alone? 
 If it is the case, they SHOULD count each as a separate reproductive event ! 

I take this dataset "UBC_run1_SibSize_META_Probfiltered" from line 656 from script 7 to check this. 
 
Important note: We filter this guys based on probability of EXCLUSION since we don't want incomplete sibships to inflate the number of reproductive events !  

```{r}
Sibships_size_one_filtered <- UBC_run1_SibSize_META_Probfiltered %>% 
  filter(., Sibsize == 1) %>% 
  filter(., `Prob(Inc.)` >= 0.9) %>% 
  filter(., `Prob(Exc.)` >= 0.99)

```
 
***
SO FROM HERE WE INPUT SIBSHIPS OF SIZE ONE INTO THE DATASET TO CALCULATE REPRO EVENTS
***

```{r}
SibsAndParentage_V2.5.5 <- SibsAndParentage_V2.5 

# Input the fullsibship index for kids who are definitely alone in their sibship
SibsAndParentage_V2.5.5$Kid_Fullsibship_Index <- ifelse(SibsAndParentage_V2.5.5$Kid_Fullsibship_Index == "None" & SibsAndParentage_V2.5.5$kid %in% Sibships_size_one_filtered$Sibship_Member, Sibships_size_one_filtered$FullSibshipIndex, SibsAndParentage_V2.5.5$Kid_Fullsibship_Index)

  
# Input the corresponding family size 
SibsAndParentage_V2.5.5$Sibsize_kid <- ifelse(SibsAndParentage_V2.5.5$kid %in% Sibships_size_one_filtered$Sibship_Member, 1, SibsAndParentage_V2.5.5$Sibsize_kid)
  
```

See below the difference of percentage of kids with no sibships when we add the sibships of size one !
```{r}
SibsAndParentage_V2.5 %>% filter(., Kid_Fullsibship_Index == "None") %>% nrow()
nrow(SibsAndParentage_V2.5)
72/374*100
```
```{r}
SibsAndParentage_V2.5.5 %>% filter(., Kid_Fullsibship_Index == "None") %>% nrow()
nrow(SibsAndParentage_V2.5.5)
58/374*100
```
We will want to say that the number of repro events may be underestimated because of the special case mentionned above. But we also need to say how big this effect is, thus: 
How many kids had no sibship WHEN A PARENT HAD SEVERAL SINGLE PAIRS? 

```{r}
SibsAndParentage_V2.5.5 %>% 
  filter(., Kid_Fullsibship_Index == "None") %>% 
  filter(., TRIOorSP == "Single_Pair") %>% 
  ungroup() %>%  #JUst in case
  group_by(., parent_1) %>% 
  mutate(., Number_of_SP_per_parent = n_distinct(kid)) %>% 
  ungroup() %>% 
  # To get the parents who have more than one SP with no sibship assigned for the kid. 
  filter(., Number_of_SP_per_parent > 1 ) %>%  
  nrow()
```
```{r}
24/374*100
```


*** 
READ COMMENT IN CHUNK -- Very IMPORTANT -- Repro event count in case of single pairs 
***

```{r}
SibsAndParentage_V2.6 <- SibsAndParentage_V2.5.5 %>% 
  # I don't know why I putted "None" instead of NA in the fullsibshipindex but I don't need it anymore now. 
  naniar::replace_with_na(replace = list(Kid_Fullsibship_Index = "None")) %>% 
  naniar::replace_with_na(replace = list(Mom_Fullsibship_Index = "None")) %>% 
  naniar::replace_with_na(replace = list(Dad_Fullsibship_Index = "None")) %>% 
  ungroup() %>% 
  
  group_by(., Mom) %>% 
  mutate(Reprod_events_Mom_alpha = n_distinct(Kid_Fullsibship_Index, na.rm = T)) %>% 
  mutate(Reprod_events_Mom_beta = ifelse(is.na(Mom), "9999", as.character(Reprod_events_Mom_alpha) )) %>% 
  naniar::replace_with_na(replace = list(Reprod_events_Mom_beta = "9999")) %>%
  mutate(Reprod_events_Mom_zeros = as.double(Reprod_events_Mom_beta)) %>% 
# Here some parents with single pairs or trios AND single pairs ended up with "0" as number of reproductive event because the kid was not in any sibship.
# Obviously this is ridiculous but we still encounter the special case of not counting each single pair as a different reproductive event.
# However, here not only the SP are NOT counted in the repro events, but also the parents with kids with no sibship assigned have just a "0" for the reprod events
# Thus we need to count: 
#  1 event if multiple single pairs
#  2 event if multiple single pairs and 1 trio
#  3 event if multiple single pairs and 2 trio
#  4 event if multiple single pairs and 3 trio 
  # ETC ...

# SO the easy way is to just make it count the number of unique dads ! and boom !   
  mutate(Reprod_events_Mom = ifelse(Reprod_events_Mom_zeros == 0, no = Reprod_events_Mom_zeros, yes = n_distinct(Dad) )) %>% 
  ungroup() %>% 
  
    group_by(., Dad) %>% 
  mutate(Reprod_events_Dad = n_distinct(Kid_Fullsibship_Index, na.rm = T)) %>% 
  mutate(Reprod_events_Dad = ifelse(is.na(Dad), "9999", as.character(Reprod_events_Dad) )) %>%  
  naniar::replace_with_na(replace = list(Reprod_events_Dad = "9999")) %>%
  mutate(Reprod_events_Dad = as.double(Reprod_events_Dad)) %>% 
  mutate(Reprod_events_Dad = ifelse(Reprod_events_Dad == 0, no = Reprod_events_Dad, yes = n_distinct(Dad) )) %>% 
  ungroup() %>% 
  
    group_by(., Dad) %>% 
  mutate(Number_of_kids_Dad = n_distinct(kid, na.rm = T)) %>% 
  mutate(Number_of_kids_Dad = ifelse(is.na(Dad), "9999", as.character(Number_of_kids_Dad) )) %>%  
  naniar::replace_with_na(replace = list(Number_of_kids_Dad = "9999")) %>%
  mutate(Number_of_kids_Dad = as.double(Number_of_kids_Dad)) %>% 
  ungroup() %>% 
  
    group_by(., Mom) %>% 
  mutate(Number_of_kids_Mom = n_distinct(kid, na.rm = T)) %>% 
  mutate(Number_of_kids_Mom = ifelse(is.na(Mom), "9999", as.character(Number_of_kids_Mom) )) %>%  
  naniar::replace_with_na(replace = list(Number_of_kids_Mom = "9999")) %>%
  mutate(Number_of_kids_Mom = as.double(Number_of_kids_Mom)) %>% 
  ungroup()  
# Activate below if you want to come back on the number of repro events thing.
# %>% select(., kid , Kid_Fullsibship_Index , TRIOorSP, Mom , Dad , Number_of_kids_Mom, Number_of_kids_Dad, Reprod_events_Dad , Reprod_events_Mom_zeros, Reprod_events_Mom)
  
SibsAndParentage_V2.7 <- as_tibble(SibsAndParentage_V2.6)
```


## F) Simplify the dataset

```{r}
SibsAndParentage_V2.8 <- SibsAndParentage_V2.7 %>% 
  select(., c(kid, Mom, Dad, TRIOorSP, Sex_kid, Coll_year_kid, Coll_month_kid, Coll_day_kid, MomYear, DadYear, LENGTH_kid, Momsize, Dadsize, hapstr_kid, MomOmy5, DadOmy5, FamilySize_SPtrio, FamilySize_TriosOnly, Family_OmyType, Reprod_events_Mom, Number_of_kids_Mom, Reprod_events_Dad, Number_of_kids_Dad , Kid_Fullsibship_Index, Mom_Fullsibship_Index, Dad_Fullsibship_Index, Sibsize_kid, Sibsize_mom, Sibsize_dad, Perc.Male_kid, Perc.Male_mom, Perc.Male_dad, Length_diff_Mom_Kid_comment, Length_diff_Dad_Kid_comment))
```

## G) Do known Sibships match number of kids? 
 
 FamIndex_per_year is a new column.
 A family is either: 
 1) All kids of Trios and their mom and dad.
 2) All kids of single-pairs PER YEAR, with their mom or dad. 

 
```{r}
SibsAndParentage_V2.9 <- SibsAndParentage_V2.8 %>% 
  mutate(., matcchF = if_else(is.na(Mom), "no_mom", if_else(Sibsize_kid > Number_of_kids_Mom , "PROBLEM", "OK"))) %>% 
  mutate(., matcchM = if_else(is.na(Dad), "no_dad", if_else(Sibsize_kid > Number_of_kids_Dad , "PROBLEM", "OK"))) %>% 
 group_by(., Mom, Dad, Coll_year_kid) %>%
 { mutate(ungroup(.), FamIndex_per_year_SP = 1000+group_indices(.)) } %>% 
ungroup() %>%   
  group_by(., Mom, Dad) %>%
 { mutate(ungroup(.), FamIndex_per_year_Trio = group_indices(.)) } %>% 
 select(., c(FamIndex_per_year_Trio, everything()))  %>% 
  ungroup() %>% 
  mutate(., FamIndex_per_year = ifelse(TRIOorSP == "Trio",FamIndex_per_year_Trio, FamIndex_per_year_SP )) %>% 
  select(., - c(FamIndex_per_year_Trio, FamIndex_per_year_SP)) %>% 
  select(., c(FamIndex_per_year, everything()))   


```

They do ! 


## H) Compute family year 

```{r}
SibsAndParentage_V2.9.1 <- SibsAndParentage_V2.9 %>% 
  ungroup() %>% 
  group_by(., Mom, Dad) %>% 
  mutate(., Family_minYear = min(Coll_year_kid)) %>% 
  ungroup()
```

## I) Input distances

```{r}
SibsAndParentage_V2.9.2 <- SibsAndParentage_V2.9.1 %>% 
  left_join(., Distance_Ultimate_key_V2_distanceOnly, by = c( "kid" = "Sample_ID" ) ) %>% 
  rename(., kid_distance = "distance") %>% 
  left_join(., Distance_Ultimate_key_V2_distanceOnly, by = c( "Mom" = "Sample_ID" ) ) %>% 
  rename(., Mom_distance = "distance") %>% 
  left_join(., Distance_Ultimate_key_V2_distanceOnly, by = c( "Dad" = "Sample_ID" ) ) %>% 
  rename(., Dad_distance = "distance") 
```

## J) Input proportions of AAAA alleles in family 

Here we will compute :
1) Number of A alleles in Kid, Mom, Dad
2) Sum those
3) Average it per family

This will provide us with a sort of continuous variable that we will be able to compare to 
1) Family size
2) Distance


The calculation of proportions of A alleles per family below is a bit obscure but I checked it so you can trust it !! 


```{r}

Proportions_of_AAAA_per_family <- SibsAndParentage_V2.9.2 %>% 
  select(., FamIndex_per_year, hapstr_kid, MomOmy5, DadOmy5, kid) %>% 
  mutate(., A_count_kid = if_else( hapstr_kid == "AAAA", 2, if_else(hapstr_kid == "HHHH", 1, if_else(hapstr_kid == "RRRR", 0, 999999999999999 )) )) %>% 
    mutate(., A_count_Mom = if_else( MomOmy5 == "AAAA", 2, if_else(MomOmy5 == "HHHH", 1, if_else(MomOmy5 == "RRRR", 0, 999999999999999 )) )) %>% 
    mutate(., A_count_Dad = if_else( DadOmy5 == "AAAA", 2, if_else(DadOmy5 == "HHHH", 1, if_else(DadOmy5 == "RRRR", 0, 999999999999999 )) )) %>% 
  group_by(., FamIndex_per_year) %>% 
  mutate(., Tot_A_count = sum(A_count_kid, mean(A_count_Mom), mean(A_count_Dad), na.rm = T)) %>% 
  add_count() %>%                                    # Check number of offspring
  # Add moms and dads to family size: i.e number of offspring + 2 if both parents, +1 if only one
  mutate(., Famsize_quick = ifelse(is.na(DadOmy5) & is.na(MomOmy5) , n, ifelse( !is.na(DadOmy5) & !is.na(MomOmy5), n+2, n+1 ) ))      %>%                  
  mutate(., Proportion_A_alleles_Family = Tot_A_count/(2*Famsize_quick)) %>% 
  ungroup() %>% 
  select(., Proportion_A_alleles_Family, kid ) 



SibsAndParentage_V2.9.3 <- SibsAndParentage_V2.9.2 %>% 
  left_join(., Proportions_of_AAAA_per_family , by = "kid")


```


## K) Compute Omy5 per sibship

The idea is to reconstruct the parental Omy5 genotypes to know what is the Omy5 type for the family even if we don't have both parents. 

### Continue -- TOO COMPLEX


```{r}
# First the Omy5 by parent can help a lot !
Parents_OmyType <- SibsAndParentage_V3 %>% 
  ungroup() %>% 
  distinct(Kid_Fullsibship_Index, .keep_all = T) %>% 
  select(., Kid_Fullsibship_Index, MomOmy5, DadOmy5) %>% 
  rename(., FullSibshipIndex = "Kid_Fullsibship_Index")
Parents_OmyType$FullSibshipIndex <- as.double(Parents_OmyType$FullSibshipIndex)


Sibship_Omy5s_type <- Filtered_Fullsibs %>% 
  filter(., !hapstr == "?") %>% 
  ungroup() %>% 
  select(., FullSibshipIndex, hapstr) %>% 
  left_join(., Parents_OmyType, by = "FullSibshipIndex") %>% 
  group_by(., FullSibshipIndex) %>% 
  mutate(., Omytype = n_distinct(hapstr))
  
```





 
 Use the latest version later in script (called V3 so had to adapt)
 
```{r}
SibsAndParentage_V3 <- SibsAndParentage_V2.9.3 %>% 
  ungroup() %>% 
  select(., -c(matcchF, matcchM))

nrow(SibsAndParentage_V3)
```
 

# IV) Spatial Auto-correlation analysis ! 

What is it ? 

https://rspatial.org/raster/analysis/3-spauto.html 
http://adegenet.r-forge.r-project.org/files/day3.1.2.pdf 

What can we use to do it ? 

  GenAlEx
  R : adegenet 

Why do we use it ? 

To check if genetic distance is correlated to spatial distance. 
Spatial autocorrelation can be negative or positive (i.e individuals are more dissimilar than random, or similar, respectively). 


## A) Background & Procedure

The lag vector Lx computes mean values of neighbours. 
If x is your variable of interest (eg. the genetics), if you have a positive correlation between the lag vectors Lx and x, the Moran index will be higher than Io ( I(x) > Io ), Io is when you have no autocorrelation, i.e.  random spatial distribution. 
If Io > I(x), then you have a negative correlation. 

> Testing Moran’s I

Monte Carlo procedure: 
  - Compute I from the data
  - permute randomly the locations to get a value of I under H0: “x is distributed at random across space.”
  - Repeat this operation a large number of times to obtain a reference distribution of I under H0. 
  - Compare initial value to the reference distribution to get a p-value.

There is much more, and it's ver ywell explained :
Theory here : http://adegenet.r-forge.r-project.org/files/day3.1.2.pdf 
R code here : http://adegenet.r-forge.r-project.org/files/practical-day3.1.2.pdf 


 WARNING: We should somehow justify that our sampling design is adapted to this analysis. 



## B) Look at YOYs first 

It is likely that the multi-year sibships may spread more in the river! 
However, if we look at YOYs, we may see them staying all together :) 

So we want to know the autocorrelation of the variable "FullSibshipIndex" in the space "distance "



### 1) Join YOY sibships with distance data

Distance data : Distance_Ultimate_key_V2 
YOY sibship data : UBC_run1_SibSize_META_Result2_YOYs

```{r}
 head(UBC_run1_SibSize_META_Result2_YOYs)
```

```{r}
Minidistance_V1 <- Distance_Ultimate_key_V2 %>% 
  select(., c(Sample_ID, distance))


Distance_YOYs_sibships <- UBC_run1_SibSize_META_Result2_YOYs %>% 
      left_join(., Minidistance_V1, by = c("Sibship_Member" = "Sample_ID" ))
  
```

    ### Do like in Bohling 2019 

Adding a spatial component to our evaluation, we performed a Mantel test between individual genetic distance and geographic distance using the R package ecodist (Goslee and Urban 2007). Genetic distance was estimated using the R package poppr (Kamvar et al. 2014). Geo- graphic distance was represented as stream distance between capture locations for individual Redband Trout. With the Mantel test we also estimated spatial autocorrelation using a simple Mantel correlogram.


### 2) Prepare YoY genotypes


https://r-forge.r-project.org/scm/viewvc.php/*checkout*/www/files/tutorial.pdf?revision=150&root=adegenet&pathrev=462  

First extract sibship info for YOYs: 
```{r}
YoY_FullSibshipIndex <- UBC_run1_SibSize_META_Result_YOY_V3 %>% 
  select(., c(FullSibshipIndex, Sibship_Member)) 
```

Reduce the 1995 fish dataset to the YOY sibships only and change the indiv.ID to Sample_ID format. 
Yoy sibships dataset : UBC_run1_SibSize_META_Result_YOY_V3 (Already filtered for Prob(Inc.) <= 0.9 )
```{r}
genotypes_YOY_sibships <- gtseq7.12_ubc_hap2col_current_vcf.txt %>% 
  left_join(., Key_BC_V1, by = "indiv.ID") %>% 
  select(., - c(indiv.ID, group)) %>% 
  filter(.,Sample_ID %in% UBC_run1_SibSize_META_Result_YOY_V3$Sibship_Member) %>% 
  left_join(., YoY_FullSibshipIndex, by = c("Sample_ID" = "Sibship_Member")) 
```



### 3) Add leading zeros to get a  three digits format ! 

```{r}
genotypes_YOY_sibships_two_digits <- data.frame(lapply(genotypes_YOY_sibships, function(x){
  gsub("^([0-9]){1}$", "0\\1", x) 
  }))
genotypes_YOY_sibships_three_digits <- data.frame(lapply(genotypes_YOY_sibships_two_digits, function(x){
  gsub("^([0-9]{2})$", "0\\1", x) 
  }))

colnames(genotypes_YOY_sibships_three_digits) <- gsub("^tag_id_([0-9]{1,6}.[0-9]{1})$", "\\1", colnames(genotypes_YOY_sibships_three_digits))
colnames(genotypes_YOY_sibships_three_digits) <- gsub("^([0-9]{1,6}).([0-9]{1})$", "\\1_\\2", colnames(genotypes_YOY_sibships_three_digits))

```

 A couple of checks about missing data and identical rows ... 

```{r}
genotypes_YOY_sibships_three_digits_HowManyNA <- genotypes_YOY_sibships_three_digits %>% 
  mutate( NAs= rowSums(is.na(genotypes_YOY_sibships_three_digits)))


nrow(genotypes_YOY_sibships_three_digits_HowManyNA)
Check_identical_GenoYoy <- genotypes_YOY_sibships_three_digits_HowManyNA %>% 
  select(., -c(NAs, Sample_ID, FullSibshipIndex)) %>% 
  distinct()
nrow(Check_identical_GenoYoy) == nrow(genotypes_YOY_sibships_three_digits_HowManyNA)
```
If true you have no identical rows ! 


### 4) Replace NAs with "?"

 Ya une sombre histoire avec les NA ici. En gros mieux vaut remplacer par "na"

```{r}
i <- sapply(genotypes_YOY_sibships_three_digits, is.factor) # Identify all factor variables in your data
genotypes_YOY_sibships_three_digits[i] <- lapply(genotypes_YOY_sibships_three_digits[i], as.character) # Convert factors to character variables
genotypes_YOY_sibships_three_digits[is.na(genotypes_YOY_sibships_three_digits)] <- "na" # Replace NAs with "NA", as shown in Example 1
genotypes_YOY_sibships_three_digits[i] <- lapply(genotypes_YOY_sibships_three_digits[i], as.factor) # Convert character columns back to factors
```



### 5) From Two to One column per locus 

Merge columns together for conversion to genind
We need the one row/loci format ! 
```{r}
genotypes_YOY_sibships_3digs_oneColformat <- genotypes_YOY_sibships_three_digits %>% 
  gather(., Loci, Allele, -FullSibshipIndex, -Sample_ID, na.rm = F) %>% 
  mutate(., Unified_Loci = gsub( x = Loci, "^([0-9]{1,6}).[0-9]{1}$", "\\1" )) %>%
  ungroup()  %>% 
  group_by(., Sample_ID, Unified_Loci) %>% 
  mutate(., two_alleles = paste0(Allele, collapse = "/")) %>% 
  select(., -c(Loci, Allele)) %>% 
  group_by(., Sample_ID) %>% 
  distinct(., Unified_Loci, .keep_all = T ) %>% 
  spread(., key = Unified_Loci, value = two_alleles) %>% 
  ungroup()

```

 



### 6) Mantel's tests and correlograms

#### a) !Sibship based! correlogram  

 This whole thing makes no sense as we group per sibship !!

Although maybe it does but I need to be careful on the interpretation. 

```{r}
library(adegenet)
library(ecodist)
```

Now convert in genind format ! 
```{r}
# Before remove unused columns 
genotypes_YOY_sibships_3digs_oneColformat_forConversion <-  genotypes_YOY_sibships_3digs_oneColformat %>%  
  arrange(., FullSibshipIndex, Sample_ID) %>% 
  select(., -c(FullSibshipIndex)) %>% 
  column_to_rownames(., "Sample_ID")

ncol(genotypes_YOY_sibships_3digs_oneColformat_forConversion)

genind_genotypes_YOY_sibships_three_digits_distance <- df2genind(X = genotypes_YOY_sibships_3digs_oneColformat_forConversion , sep = "/" , pop = genotypes_YOY_sibships_three_digits$FullSibshipIndex, NA.char = "NA")

genind_genotypes_YOY_sibships_three_digits_distance
``` 

```{r}
zgeg <- edwards.dist(genind_genotypes_YOY_sibships_three_digits_distance)
head(zgeg)

# Number of NAs
nanana <- sum(which(is.na(zgeg)))
nonanona <- sum(which(!is.na(zgeg)))

nanana/(nanana+nonanona)*100
```


Convert genind to genpop 
```{r}
genpop_genotypes_YOY_sibships_three_digits_distance <- genind2genpop(genind_genotypes_YOY_sibships_three_digits_distance)

genpop_genotypes_YOY_sibships_three_digits_distance
```

Compute genetic distance

 Warning: Below you can use several different genetic distances. 
Let's use Edwards' distance because its euclidian. 
```{r}
genetic_distance <- dist.genpop(genpop_genotypes_YOY_sibships_three_digits_distance, method = 2)
summary(genetic_distance)
```

```{r}
# Compute a sibship distance file with the mean distance per sibling group
MeanSibship_distance <- Distance_YOYs_sibships %>% 
  select(., c(FullSibshipIndex, Sibship_Member, distance)) %>% 
  group_by(., FullSibshipIndex) %>% 
  mutate(., Meand_Dist_perSibship = mean(distance)) %>% 
  arrange(., FullSibshipIndex, Sibship_Member) %>% 
  select(., -c(Sibship_Member, distance)) %>% 
  ungroup %>% 
  distinct(., FullSibshipIndex, .keep_all = T) %>% 
  mutate( pseudo_y = 0) 

dist_mean_geographic_distance <- distance(MeanSibship_distance, "euclidean")
head(dist_mean_geographic_distance)
```

```{r}
Mean_sibships_correlog <- mantel.correlog(D.eco = genetic_distance, D.geo = dist_mean_geographic_distance, n.class = 0, cutoff = F, nperm = 999)

plot(Mean_sibships_correlog)
```

```{r}
mantel_meanDIst_sibship <- mantel.randtest(genetic_distance, dist_mean_geographic_distance, nrepet = 10000)
mantel_meanDIst_sibship
```

There is isolation by distance !?
 
```{r}
# nclass is 675 (max distance) divided by 25 (distance interval) = 27 You can use that or leave it to Sturge's rule
MantimantoCorr_YoYSibs <- mgram(species.d = genetic_distance , space.d =  dist_mean_geographic_distance, nperm = 10000, cboot = 0.95)
MantimantoCorr_YoYSibs
plot(MantimantoCorr_YoYSibs)
```


#### b) Individual-based correlogram

Without grouping per sibship, we just compute individual distances. 

Now convert in genind format !  WE LEAVE POP = NULL !!! 
And we use the table in one-column per locus format 

```{r}
# Remove "pop" (i.e sibship information)    
genotypes_YOY_sibships_three_digits_noPop <- genotypes_YOY_sibships_3digs_oneColformat %>% 
  arrange(., Sample_ID) %>% 
  select(., - c(FullSibshipIndex)) %>% 
  column_to_rownames(., "Sample_ID" )

genind_GenoYoYs_sibships_distance_noPop <- df2genind(X = genotypes_YOY_sibships_three_digits_noPop , sep = "/" , NA.char = "NA")

genind_GenoYoYs_sibships_distance_noPop
``` 

```{r}
zgego <- poppr::edwards.dist(genind_GenoYoYs_sibships_distance_noPop)
head(zgego)

# Number of NAs
nanana2 <- sum(which(is.na(zgego)))
nonanona2 <- sum(which(!is.na(zgego)))

nanana2 / (nanana2 + nonanona2) *100
```


Add distance information in @other

```{r}
# First we need the same individuals, it may make the importation easier. 
YoY_minidistance <- Minidistance_V1 %>% 
  filter(., Sample_ID %in% UBC_run1_SibSize_META_Result_YOY_V3$Sibship_Member)

genind_GenoYoYs_sibships_distance_noPop$other$Distance <- YoY_minidistance

genind_GenoYoYs_sibships_distance_noPop$other$Distance

```

 # No need to conver to genpop here aswe use poppr's function


Create distance matrixes 
 We use poppr here as it has functions to calculate distance based on individuals and not populations! 
You can change from Edward's to another but Edward is Euclidian so it's cool. 
And you have to to it on the genind object directly
```{r}
# We have a problem here because I need to define populations ! 
Edwards_Indiv_genetic_distance_noPop <- edwards.dist(genind_GenoYoYs_sibships_distance_noPop)
summary(Edwards_Indiv_genetic_distance_noPop)
```
 
We compute a "y" coordinate made of zeros, so that a matrix can be done.
```{r}
YoY_minidistance_y0 <- YoY_minidistance %>% 
  mutate( pseudo_y = 0) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID")

dist_Indiv_geographic_distance <- dist(YoY_minidistance_y0, "euclidean")

summary(dist_Indiv_geographic_distance)
```

Test Isolation by Distance
```{r}
Mantimanto <- mantel.randtest(Edwards_Indiv_genetic_distance_noPop , dist_Indiv_geographic_distance, nrepet = 10000)
Mantimanto
```
Mantel test is significant ! 

Be careful because this doesn't NECESSARILY mean that you have IDB ! :) 

```{r}
plot(Mantimanto)
```


```{r}
MantimantoCorr_YoYsibsNotgrouped <- mgram(species.d = Edwards_Indiv_genetic_distance_noPop , space.d =  dist_Indiv_geographic_distance, nperm = 10000, cboot = 0.95, nboot = 10000)
MantimantoCorr_YoYsibsNotgrouped
plot(MantimantoCorr_YoYsibsNotgrouped)
```
Remember that in principle, a significant Mantel test or a correlogram pattern only indicates that genetic variability is structured in geographic space. 


## C) Simple correlation distance - sibshipIndex in YOYs

You have to test this the propper way, not with a correlation , dumb-ass 

# TO DO 


## D) Mantel correlogram in all sibships ! 

This time we don't take only YoYs. 
We will use Filtered_Fullsibs (Sibships, not necessarily YoYs, filtered for prob.Inc > 0.99).

Distance data : Distance_Ultimate_key_V2 
ALL sibship data : Filtered_Fullsibs

```{r}
head(Filtered_Fullsibs)
```

### 0) Remove some sibships of extreme size 
 Wait a second ! 
What if we remove big and small sibships (i.e big sibships have higher chances of being spurious and small ones won't show up in the correlations ?!)
```{r}
Mini_Summary_per_Sibgroup_Allfish %>% 
  count(., Sibsize)
```
 So let's try with what is between 5 and 25 sibsize !! 

```{r}
Filtered_Fullsibs_NoSmallNoBigSibship <- Filtered_Fullsibs %>% 
  filter(., !Sibsize > 100) %>% 
  filter(., !Sibsize < 1)  
```

```{r}
nrow(Filtered_Fullsibs) == nrow(Filtered_Fullsibs_NoSmallNoBigSibship)
```



### 1) Prepare All sibships genotypes


https://r-forge.r-project.org/scm/viewvc.php/*checkout*/www/files/tutorial.pdf?revision=150&root=adegenet&pathrev=462  

 WARNING : Here we DON'T really use all the sibships: We try filtering out the big and small ones, see above!

Reduce the 1995 fish dataset to All sibships only and change the indiv.ID to Sample_ID format.  
```{r}
genotypes_All_sibships <- gtseq7.12_ubc_hap2col_current_vcf.txt %>% 
  left_join(., Key_BC_V1, by = "indiv.ID") %>% 
  select(., - c(indiv.ID, group)) %>% 
  filter(.,Sample_ID %in% Filtered_Fullsibs_NoSmallNoBigSibship$Sibship_Member) 
```



### 3) Add leading zeros to get a  three digits format ! 

```{r}
genotypes_All_sibships_two_digits <- data.frame(lapply(genotypes_All_sibships, function(x){
  gsub("^([0-9]){1}$", "0\\1", x) 
  }))
genotypes_All_sibships_three_digits <- data.frame(lapply(genotypes_All_sibships_two_digits, function(x){
  gsub("^([0-9]{2})$", "0\\1", x) 
  }))

colnames(genotypes_All_sibships_three_digits) <- gsub("^tag_id_([0-9]{1,6}.[0-9]{1})$", "\\1", colnames(genotypes_All_sibships_three_digits))
colnames(genotypes_All_sibships_three_digits) <- gsub("^([0-9]{1,6}).([0-9]{1})$", "\\1_\\2", colnames(genotypes_All_sibships_three_digits))

```

 A couple of checks about missing data and identical rows ... 

```{r}
genotypes_All_sibships_three_digits_HowManyNA <- genotypes_All_sibships_three_digits %>% 
  mutate( NAs= rowSums(is.na(genotypes_All_sibships_three_digits)))


nrow(genotypes_All_sibships_three_digits_HowManyNA)
Check_identical_GenoAll <- genotypes_All_sibships_three_digits_HowManyNA %>% 
  select(., -c(NAs, Sample_ID)) %>% 
  distinct()
nrow(Check_identical_GenoAll) == nrow(genotypes_All_sibships_three_digits_HowManyNA)
```
If true you have no identical rows ! 


### 4) Replace NAs with "na"

 Ya une sombre histoire avec les NA ici. En gros mieux vaut remplacer par "na"

```{r}
i <- sapply(genotypes_All_sibships_three_digits, is.factor) # Identify all factor variables in your data
genotypes_All_sibships_three_digits[i] <- lapply(genotypes_All_sibships_three_digits[i], as.character) # Convert factors to character variables
genotypes_All_sibships_three_digits[is.na(genotypes_All_sibships_three_digits)] <- "na" # Replace NAs with "NA", as shown in Example 1
genotypes_All_sibships_three_digits[i] <- lapply(genotypes_All_sibships_three_digits[i], as.factor) # Convert character columns back to factors
```



### 5) From Two to One column per locus 

Merge columns together for conversion to genind
We need the one row/loci format ! 
```{r}
genotypes_All_sibships_3digs_oneColformat <- genotypes_All_sibships_three_digits %>% 
  gather(., Loci, Allele, -Sample_ID, na.rm = F) %>% 
  mutate(., Unified_Loci = gsub( x = Loci, "^([0-9]{1,6}).[0-9]{1}$", "\\1" )) %>%
  ungroup()  %>% 
  group_by(., Sample_ID, Unified_Loci) %>% 
  mutate(., two_alleles = paste0(Allele, collapse = "/")) %>% 
  select(., -c(Loci, Allele)) %>% 
  group_by(., Sample_ID) %>% 
  distinct(., Unified_Loci, .keep_all = T ) %>% 
  spread(., key = Unified_Loci, value = two_alleles) %>% 
  ungroup()

```


### 6) Individual-based correlogram

Without grouping per sibship, we just compute individual distances. 

Now convert in genind format !  WE LEAVE POP = NULL !!! 
And we use the table in one-column per locus format 

```{r}
# Remove "pop" (i.e sibship information)    
genotypes_All_sibships_three_digits_noPop <- genotypes_All_sibships_3digs_oneColformat %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID" ) 
 

genind_GenoAlls_sibships_distance_noPop <- df2genind(X = genotypes_All_sibships_three_digits_noPop , sep = "/" , NA.char = "NA")

genind_GenoAlls_sibships_distance_noPop
``` 

Prepare the distance info for all the sibships
```{r}
All_minidistance <- Minidistance_V1 %>% 
  filter(., Sample_ID %in% Filtered_Fullsibs_NoSmallNoBigSibship$Sibship_Member) %>% 
  arrange(., Sample_ID) 
```

 # No need to conver to genpop here aswe use poppr's function


Create distance matrixes 
 We use poppr here as it has functions to calculate distance based on individuals and not populations! 
You can change from Edward's to another but Edward is Euclidian so it's cool. 
And you have to to it on the genind object directly
```{r}
# We have a problem here because I need to define populations ! 
Edwards_All_SIbships_Indiv_genetic_distance_noPop <- edwards.dist(genind_GenoAlls_sibships_distance_noPop)

# Number of NAs
nanana1 <- sum(which(is.na(Edwards_All_SIbships_Indiv_genetic_distance_noPop)))
nonanona1 <- sum(which(!is.na(Edwards_All_SIbships_Indiv_genetic_distance_noPop)))

nanana1/(nanana1+nonanona1)*100
# summary(Edwards_All_SIbships_Indiv_genetic_distance_noPop)
head(Edwards_All_SIbships_Indiv_genetic_distance_noPop)
```
 
We compute a "y" coordinate made of zeros, so that a matrix can be done.
```{r}
All_minidistance_y0 <- All_minidistance %>% 
  mutate( pseudo_y = 0) %>% 
  column_to_rownames(., "Sample_ID")

dist_All_sibships_Indiv_geographic_distance <- dist(All_minidistance_y0, "euclidean")

#summary(dist_All_sibships_Indiv_geographic_distance)
```

 ICI NON PLUS CA MARCHE PAS : 
 Généralement on as un problème avec les grandes matrices, les NA et les tests de Mantel ... 

Test Isolation by Distance
```{r}
Mantimanto_Allsibs <- mantel.randtest(Edwards_All_SIbships_Indiv_genetic_distance_noPop , dist_All_sibships_Indiv_geographic_distance, nrepet = 10000)
Mantimanto_Allsibs
```
Overall Mantel test is NOT WORKING HERE ! 

Be careful because this doesn't NECESSARILY mean that you have IDB ! :) 

```{r}
plot(Mantimanto_Allsibs)
```


```{r}
MantimantoCorr_Allsibs <- mgram(species.d = Edwards_All_SIbships_Indiv_genetic_distance_noPop , space.d =  dist_All_sibships_Indiv_geographic_distance, nperm = 999, cboot = 0.95, nboot = 999)
MantimantoCorr_Allsibs
plot(MantimantoCorr_Allsibs)
```
Remember that in principle, a significant Mantel test or a correlogram pattern only indicates that genetic variability is structured in geographic space. 



## E) Mantel correlogram in all the 1809 fish ! 

### 1) Take 1809 fish genotype and distance data

Distance data : Distance_Ultimate_key_V2_distanceOnly 
Genotype data : For_Colony_Sibship_Noduplicates (For all the 1995 fish MINUS THE DUPLICATES !)

```{r}
Distances_1809_fish  <- Distance_Ultimate_key_V2_distanceOnly %>% 
  filter(., Sample_ID %in% For_Colony_Sibship_Noduplicates$Sample_ID) %>% 
  arrange(., Sample_ID)
nrow(Distances_1809_fish)
```


### 2) Prepare 1809 genotypes


https://r-forge.r-project.org/scm/viewvc.php/*checkout*/www/files/tutorial.pdf?revision=150&root=adegenet&pathrev=462  

```{r}
head(For_Colony_Sibship_Noduplicates)
```
 



### 3) Add leading zeros to get a  three digits format ! 

```{r}
genotypes_1809_fish_two_digits <- data.frame(lapply(For_Colony_Sibship_Noduplicates, function(x){
  gsub("^([0-9]){1}$", "0\\1", x) 
  }))
genotypes_1809_fish_three_digits <- data.frame(lapply(genotypes_1809_fish_two_digits, function(x){
  gsub("^([0-9]{2})$", "0\\1", x) 
  }))

colnames(genotypes_1809_fish_three_digits) <- gsub("^tag_id_([0-9]{1,6}.[0-9]{1})$", "\\1", colnames(genotypes_1809_fish_three_digits))
colnames(genotypes_1809_fish_three_digits) <- gsub("^([0-9]{1,6}).([0-9]{1})$", "\\1_\\2", colnames(genotypes_1809_fish_three_digits))
```

 A couple of checks about missing data and identical rows ...

```{r}
genotypes_1809_fish_three_digits_HowManyNA <- genotypes_1809_fish_three_digits %>% 
  mutate( NAs= rowSums(is.na(genotypes_1809_fish_three_digits)))


nrow(genotypes_1809_fish_three_digits_HowManyNA)
Check_identical_1809_fish <- genotypes_1809_fish_three_digits_HowManyNA %>% 
  select(., -c(NAs, Sample_ID)) %>% 
  distinct()
nrow(Check_identical_1809_fish) == nrow(genotypes_1809_fish_three_digits_HowManyNA)
```
If True you have no identical rows

### 4) Replace NAs with "NA"
```{r}
i <- sapply(genotypes_1809_fish_three_digits, is.factor) # Identify all factor variables in your data
genotypes_1809_fish_three_digits[i] <- lapply(genotypes_1809_fish_three_digits[i], as.character) # Convert factors to character variables
genotypes_1809_fish_three_digits[is.na(genotypes_1809_fish_three_digits)] <- "na" # Replace NAs with "NA", as shown in Example 1
genotypes_1809_fish_three_digits[i] <- lapply(genotypes_1809_fish_three_digits[i], as.factor) # Convert character columns back to factors
```


### 5) From Two to One column per locus 

Merge columns together for conversion to genind
We need the one row/loci format ! 
```{r}
genotypes_1809_fish_3digs_oneColformat <- genotypes_1809_fish_three_digits %>% 
  gather(., Loci, Allele, -Sample_ID, na.rm = F) %>% 
  mutate(., Unified_Loci = gsub( x = Loci, "^([0-9]{1,6}).[0-9]{1}$", "\\1" )) %>%
  ungroup()  %>% 
  group_by(., Sample_ID, Unified_Loci) %>% 
  mutate(., two_alleles = paste0(Allele, collapse = "/")) %>% 
  select(., -c(Loci, Allele)) %>% 
  group_by(., Sample_ID) %>% 
  distinct(., Unified_Loci, .keep_all = T ) %>% 
  spread(., key = Unified_Loci, value = two_alleles) %>% 
  ungroup()

```

 
### 6) Individual-based correlogram

Here just make the rownames be Sample_ID
And we use the table in one-column per locus format 
```{r}
genotypes_1809_fish_three_digits_noPop <- genotypes_1809_fish_3digs_oneColformat %>%
#  mutate(., FakePops = Sample_ID) %>%   # We con't really need those fakepops anymore
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID" )
genotypes_1809_fish_three_digits_noPop
```

```{r}
ncol(genotypes_1809_fish_three_digits_noPop)
```


```{r}
genind_Geno1809_fish_distance_noPop <- df2genind(X = genotypes_1809_fish_three_digits_noPop , sep = "/" , NA.char = "NA")

genind_Geno1809_fish_distance_noPop
``` 

 # No need to conver to genpop here aswe use poppr's function

Create distance matrixes 
 We use poppr here as it has functions to calculate distance based on individuals and not populations! 
You can change from Edward's to another but Edward is Euclidian so it's cool. 
And you have to to it on the genind object directly
```{r}
# We have a problem here because I need to define populations ! 
Edwards_1809_fish_genetic_distance_noPop <- edwards.dist(genind_Geno1809_fish_distance_noPop)

# Number of NAs
nanana <- sum(which(is.na(Edwards_1809_fish_genetic_distance_noPop)))
nonanona <- sum(which(!is.na(Edwards_1809_fish_genetic_distance_noPop)))

nanana/(nanana+nonanona)*100

head(Edwards_1809_fish_genetic_distance_noPop)
 
```

```{r}
summary(as.vector(Edwards_1809_fish_genetic_distance_noPop))
```


We compute a "y" coordinate made of zeros, so that a matrix can be done.
```{r}
Distances_1809_fish_y0 <- Distances_1809_fish %>% 
  mutate( pseudo_y = 0) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID")

dist_1809_fish_geographic_distance <- dist(Distances_1809_fish_y0, "euclidean")
#summary(dist_1809_fish_geographic_distance)
```

```{r}
summary(as.vector(dist_1809_fish_geographic_distance))
```
On essaie de faire le correlogramme pour tous les 1809 poissons. 

Test Isolation by Distance
```{r}
Mantimanto <- mantel.randtest(Edwards_1809_fish_genetic_distance_noPop , dist_1809_fish_geographic_distance, nrepet = 99)
Mantimanto
```
Overall Mantel test is  WORKING HERE ! 

Be careful because this doesn't NECESSARILY mean that you have IDB ! :) 

```{r}
plot(Mantimanto)
```


```{r}
MantimantoCorr_1809 <- mgram(species.d = Edwards_1809_fish_genetic_distance_noPop , space.d =  dist_1809_fish_geographic_distance, nperm = 999, cboot = 0.95, nboot = 999)
MantimantoCorr_1809
plot(MantimantoCorr_1809)
```
Remember that in principle, a significant Mantel test or a correlogram pattern only indicates that genetic variability is structured in geographic space. 

## F) Mantel correlogram grouped by Omy5 in all sibships ! 

We will use Filtered_Fullsibs (Sibships, not necessarily YoYs, filtered for prob.Inc > 0.99).

Distance data : Distance_Ultimate_key_V2 
ALL sibship data : Filtered_Fullsibs


> The idea is to separate the fullsibs by Omy5. Then, we will compare how the genetic distance is linked to distance in different Omy5 haplotypes!  
Then, by sex, we will check if the variance in dispersal of heterozygotes is different! 
So, to get it right, we split by INDIVIDUALS, not by the average Omy5 of the family or something else. 
So most sibships will be split in two or three!


```{r}
head(Filtered_Fullsibs)
```

### 0) Create lists by Omy5
 
  

```{r}
Filtered_Fullsibs_AAAA <- Filtered_Fullsibs %>% 
  filter(., hapstr == "AAAA")

Filtered_Fullsibs_HHHH <- Filtered_Fullsibs %>% 
  filter(., hapstr == "HHHH")

Filtered_Fullsibs_RRRR <- Filtered_Fullsibs %>% 
  filter(., hapstr == "RRRR")


nrow(Filtered_Fullsibs_AAAA)
nrow(Filtered_Fullsibs_HHHH)
nrow(Filtered_Fullsibs_RRRR)

```



### 1) Prepare All sibships genotypes


https://r-forge.r-project.org/scm/viewvc.php/*checkout*/www/files/tutorial.pdf?revision=150&root=adegenet&pathrev=462  

 WARNING : Here we DON'T really use all the sibships: We try filtering out the big and small ones, see above!

Reduce the 1995 fish dataset to All sibships only and change the indiv.ID to Sample_ID format.  
```{r}
genotypes_All_sibships <- gtseq7.12_ubc_hap2col_current_vcf.txt %>% 
  left_join(., Key_BC_V1, by = "indiv.ID") %>% 
  select(., - c(indiv.ID, group)) %>% 
  filter(.,Sample_ID %in% Filtered_Fullsibs$Sibship_Member) 
```



### 3) Add leading zeros to get a  three digits format ! 

```{r}
genotypes_All_sibships_two_digits <- data.frame(lapply(genotypes_All_sibships, function(x){
  gsub("^([0-9]){1}$", "0\\1", x) 
  }))
genotypes_All_sibships_three_digits <- data.frame(lapply(genotypes_All_sibships_two_digits, function(x){
  gsub("^([0-9]{2})$", "0\\1", x) 
  }))

colnames(genotypes_All_sibships_three_digits) <- gsub("^tag_id_([0-9]{1,6}.[0-9]{1})$", "\\1", colnames(genotypes_All_sibships_three_digits))
colnames(genotypes_All_sibships_three_digits) <- gsub("^([0-9]{1,6}).([0-9]{1})$", "\\1_\\2", colnames(genotypes_All_sibships_three_digits))

```

 A couple of checks about missing data and identical rows ... 

```{r}
genotypes_All_sibships_three_digits_HowManyNA <- genotypes_All_sibships_three_digits %>% 
  mutate( NAs= rowSums(is.na(genotypes_All_sibships_three_digits)))


nrow(genotypes_All_sibships_three_digits_HowManyNA)
Check_identical_GenoAll <- genotypes_All_sibships_three_digits_HowManyNA %>% 
  select(., -c(NAs, Sample_ID)) %>% 
  distinct()
nrow(Check_identical_GenoAll) == nrow(genotypes_All_sibships_three_digits_HowManyNA)
```
If true you have no identical rows ! 


### 4) Replace NAs with "na"

 Ya une sombre histoire avec les NA ici. En gros mieux vaut remplacer par "na"

```{r}
i <- sapply(genotypes_All_sibships_three_digits, is.factor) # Identify all factor variables in your data
genotypes_All_sibships_three_digits[i] <- lapply(genotypes_All_sibships_three_digits[i], as.character) # Convert factors to character variables
genotypes_All_sibships_three_digits[is.na(genotypes_All_sibships_three_digits)] <- "na" # Replace NAs with "NA", as shown in Example 1
genotypes_All_sibships_three_digits[i] <- lapply(genotypes_All_sibships_three_digits[i], as.factor) # Convert character columns back to factors
```



### 5) From Two to One column per locus 

Merge columns together for conversion to genind
We need the one row/loci format ! 
```{r}
genotypes_All_sibships_3digs_oneColformat <- genotypes_All_sibships_three_digits %>% 
  gather(., Loci, Allele, -Sample_ID, na.rm = F) %>% 
  mutate(., Unified_Loci = gsub( x = Loci, "^([0-9]{1,6}).[0-9]{1}$", "\\1" )) %>%
  ungroup()  %>% 
  group_by(., Sample_ID, Unified_Loci) %>% 
  mutate(., two_alleles = paste0(Allele, collapse = "/")) %>% 
  select(., -c(Loci, Allele)) %>% 
  group_by(., Sample_ID) %>% 
  distinct(., Unified_Loci, .keep_all = T ) %>% 
  spread(., key = Unified_Loci, value = two_alleles) %>% 
  ungroup()

```


### 6) Individual-based correlogram

Without grouping per sibship, we just compute individual distances. 

Now convert in genind format !  WE LEAVE POP = NULL !!! 
And we use the table in one-column per locus format 


```{r}
genotypes_All_sibships_3digs_oneColformat %>%  count()
```



          !BUT HERE WE SPLIT BY OMY5 !


*AAAA*
```{r}
# Remove "pop" (i.e sibship information)    
genotypes_All_sibships_three_digits_noPop_AAAA <- genotypes_All_sibships_3digs_oneColformat %>% 
  filter(., Sample_ID %in% Filtered_Fullsibs_AAAA$Sibship_Member) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID" ) 
 

genind_GenoAlls_sibships_distance_noPop_AAAA <- df2genind(X = genotypes_All_sibships_three_digits_noPop_AAAA , sep = "/" , NA.char = "NA")

genind_GenoAlls_sibships_distance_noPop_AAAA
``` 
*HHHH*
```{r}
# Remove "pop" (i.e sibship information)    
genotypes_All_sibships_three_digits_noPop_HHHH <- genotypes_All_sibships_3digs_oneColformat %>% 
  filter(., Sample_ID %in% Filtered_Fullsibs_HHHH$Sibship_Member) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID" ) 
 

genind_GenoAlls_sibships_distance_noPop_HHHH <- df2genind(X = genotypes_All_sibships_three_digits_noPop_HHHH , sep = "/" , NA.char = "NA")

genind_GenoAlls_sibships_distance_noPop_HHHH
```

*RRRR*
```{r}
# Remove "pop" (i.e sibship information)    
genotypes_All_sibships_three_digits_noPop_RRRR <- genotypes_All_sibships_3digs_oneColformat %>% 
  filter(., Sample_ID %in% Filtered_Fullsibs_RRRR$Sibship_Member) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID" ) 
 

genind_GenoAlls_sibships_distance_noPop_RRRR <- df2genind(X = genotypes_All_sibships_three_digits_noPop_RRRR , sep = "/" , NA.char = "NA")

genind_GenoAlls_sibships_distance_noPop_RRRR
```

Prepare the distance info for all the sibships


```{r}
All_minidistance <- Minidistance_V1 %>% 
  filter(., Sample_ID %in% Filtered_Fullsibs$Sibship_Member) %>% 
  arrange(., Sample_ID)
```

 # No need to conver to genpop here aswe use poppr's function


Create distance matrixes 
 We use poppr here as it has functions to calculate distance based on individuals and not populations! 
You can change from Edward's to another but Edward is Euclidian so it's cool. 
And you have to to it on the genind object directly
*AAAA*
```{r}
# We have a problem here because I need to define populations ! 
Edwards_All_SIbships_Indiv_genetic_distance_noPop_AAAA <- edwards.dist(genind_GenoAlls_sibships_distance_noPop_AAAA)
# summary(Edwards_All_SIbships_Indiv_genetic_distance_noPop)
head(Edwards_All_SIbships_Indiv_genetic_distance_noPop_AAAA)

# Number of NAs
nananaAAAA <- sum(which(is.na(Edwards_All_SIbships_Indiv_genetic_distance_noPop_AAAA)))
nonanonaAAAA <- sum(which(!is.na(Edwards_All_SIbships_Indiv_genetic_distance_noPop_AAAA)))

nananaAAAA / (nananaAAAA + nonanonaAAAA) *100
```
 *HHHH*
```{r}
# We have a problem here because I need to define populations ! 
Edwards_All_SIbships_Indiv_genetic_distance_noPop_HHHH <- edwards.dist(genind_GenoAlls_sibships_distance_noPop_HHHH)
# summary(Edwards_All_SIbships_Indiv_genetic_distance_noPop)
head(Edwards_All_SIbships_Indiv_genetic_distance_noPop_HHHH)


# Number of NAs
nananaHHHH <- sum(which(is.na(Edwards_All_SIbships_Indiv_genetic_distance_noPop_HHHH)))
nonanonaHHHH <- sum(which(!is.na(Edwards_All_SIbships_Indiv_genetic_distance_noPop_HHHH)))

nananaHHHH / (nananaHHHH + nonanonaHHHH) *100
```

*RRRR*
```{r}
# We have a problem here because I need to define populations ! 
Edwards_All_SIbships_Indiv_genetic_distance_noPop_RRRR <- edwards.dist(genind_GenoAlls_sibships_distance_noPop_RRRR)
# summary(Edwards_All_SIbships_Indiv_genetic_distance_noPop)
head(Edwards_All_SIbships_Indiv_genetic_distance_noPop_RRRR)

nananaRRRR <- sum(which(is.na(Edwards_All_SIbships_Indiv_genetic_distance_noPop_RRRR)))
nonanonaRRRR <- sum(which(!is.na(Edwards_All_SIbships_Indiv_genetic_distance_noPop_RRRR)))

nananaRRRR / (nananaRRRR + nonanonaRRRR) *100
```
 


We compute a "y" coordinate made of zeros, so that a matrix can be done.
*AAAA*
```{r}
All_minidistance_y0_AAAA <- All_minidistance %>% 
  filter(., Sample_ID %in% Filtered_Fullsibs_AAAA$Sibship_Member) %>%
  arrange(., Sample_ID) %>% 
  mutate( pseudo_y = 0) %>% 
  column_to_rownames(., "Sample_ID")


dist_All_sibships_Indiv_geographic_distance_AAAA <- dist(All_minidistance_y0_AAAA, "euclidean")

head(dist_All_sibships_Indiv_geographic_distance_AAAA)
```
*HHHH*
```{r}
All_minidistance_y0_HHHH <- All_minidistance %>% 
  filter(., Sample_ID %in% Filtered_Fullsibs_HHHH$Sibship_Member) %>%
  arrange(., Sample_ID) %>% 
  mutate( pseudo_y = 0) %>% 
  column_to_rownames(., "Sample_ID")


dist_All_sibships_Indiv_geographic_distance_HHHH <- dist(All_minidistance_y0_HHHH, "euclidean")

head(dist_All_sibships_Indiv_geographic_distance_HHHH)
```

*RRRR*
```{r}
All_minidistance_y0_RRRR <- All_minidistance %>% 
  filter(., Sample_ID %in% Filtered_Fullsibs_RRRR$Sibship_Member) %>%
  arrange(., Sample_ID) %>% 
  mutate( pseudo_y = 0) %>% 
  column_to_rownames(., "Sample_ID")


dist_All_sibships_Indiv_geographic_distance_RRRR <- dist(All_minidistance_y0_RRRR, "euclidean")

head(dist_All_sibships_Indiv_geographic_distance_RRRR)
```

And , finally, the mantel correlograms ! 
 
*AAAA*
```{r}
MantimantoCorr_Allsibs_AAAA <- mgram(species.d = Edwards_All_SIbships_Indiv_genetic_distance_noPop_AAAA , space.d =  dist_All_sibships_Indiv_geographic_distance_AAAA, nperm = 999, cboot = 0.95, nboot = 999, nclass = 18)
MantimantoCorr_Allsibs_AAAA
plot(MantimantoCorr_Allsibs_AAAA)
```

*HHHH*
```{r}
MantimantoCorr_Allsibs_HHHH <- mgram(species.d = Edwards_All_SIbships_Indiv_genetic_distance_noPop_HHHH , space.d =  dist_All_sibships_Indiv_geographic_distance_HHHH, nperm = 999, cboot = 0.95, nboot = 999, nclass = 18)
MantimantoCorr_Allsibs_HHHH
plot(MantimantoCorr_Allsibs_HHHH)
```

*RRRR*
```{r}
MantimantoCorr_Allsibs_RRRR <- mgram(species.d = Edwards_All_SIbships_Indiv_genetic_distance_noPop_RRRR , space.d =  dist_All_sibships_Indiv_geographic_distance_RRRR, nperm = 999, cboot = 0.95, nboot = 999, nclass = 18)
MantimantoCorr_Allsibs_RRRR
plot(MantimantoCorr_Allsibs_RRRR)
```

Remember that in principle, a significant Mantel test or a correlogram pattern only indicates that genetic variability is structured in geographic space. 



☻> I can't manage to combine those correlograms !
☻> I can't manage to combine those correlograms !
☻> I can't manage to combine those correlograms !
☻> I can't manage to combine those correlograms !

```{r}
H_sibsmatnicorr <- as.vector(MantimantoCorr_Allsibs_HHHH[["mgram"]])
A_sibsmatnicorr <- as.vector(MantimantoCorr_Allsibs_AAAA[["mgram"]])
R_sibsmatnicorr <- as.vector(MantimantoCorr_Allsibs_RRRR[["mgram"]])

sibsmanticorr_combined <- data.frame(H_sibsmatnicorr, A_sibsmatnicorr, R_sibsmatnicorr)

plot(sibsmanticorr_combined)
```









## G) Variances in dispersal ?  

So, in the same idea of F), let's see if we see a significant difference in the means of variances of sibships of different Omy5 haplotypes! 

### 1) Compute a little summary ! 
```{r}
Var_BigCreek_NoDuplicates_Sibship_info_08April2020 <-  Filtered_Fullsibs %>% 
  ungroup() %>% 
  left_join(., Distance_Ultimate_key_V2_distanceOnly, by = c( "Sibship_Member" = "Sample_ID" )) %>% 
  group_by(., hapstr, FullSibshipIndex) %>% 
  summarise(., mean_dist=mean(distance), var_dist=var(distance), sd_dist=sd(distance))
```

Ok well done. 
However, some groups have only one representent, or have NAs. Let's remove them! 

```{r}
Var_in_Sibship_dist_noNA <- Var_BigCreek_NoDuplicates_Sibship_info_08April2020 %>% 
  filter(., !is.na(var_dist)) %>% 
  filter(., !hapstr == "?") %>% 
  ungroup()
```

### 2) How many little groups ? 

We had : 
This number of individuals : 
```{r}
nrow(Filtered_Fullsibs)
```
Split in this number of subgroups (by sibship AND by Omy5 haplo)
```{r}
nrow(Var_BigCreek_NoDuplicates_Sibship_info_08April2020)
```
And that many of them were composed of only one individual: 
```{r}
nrow(Var_BigCreek_NoDuplicates_Sibship_info_08April2020) - nrow(Var_in_Sibship_dist_noNA)
```
And what remains is (in number of little groups): 
```{r}
Var_in_Sibship_dist_noNA %>% 
  count(., hapstr)
```

### 3) Now test dispersal variance ! 

We will test different things as I am not sure of which test is best.

#### a) Mean of variances by Omy5 haplotypes

http://www.sthda.com/english/wiki/one-way-anova-test-in-r 

We will use an ANOVA. 
But first verify homogeneity of variances (of var_dist!) with a levene test. 

```{r}
leveneTest( var_dist  ~ hapstr, data = Var_in_Sibship_dist_noNA)
```
Test is not significant so variances of variances of distances are not different between Omy5 groups. 
The data (variances of distances) are independent. 
Last assumption : The data (the variances of distances) of the factors (factors being Omy5 groups) are normally distributed. 
Let's check that: 
```{r}
Var_in_Sibship_dist_noNA_AAAA <- Var_in_Sibship_dist_noNA %>% 
  filter(., hapstr == "AAAA")
 shapiro.test(Var_in_Sibship_dist_noNA_AAAA$var_dist)
```
```{r}
Var_in_Sibship_dist_noNA_RRRR <- Var_in_Sibship_dist_noNA %>% 
  filter(., hapstr == "RRRR")
 shapiro.test(Var_in_Sibship_dist_noNA_RRRR$var_dist)
```
```{r}
Var_in_Sibship_dist_noNA_HHHH <- Var_in_Sibship_dist_noNA %>% 
  filter(., hapstr == "HHHH")
 shapiro.test(Var_in_Sibship_dist_noNA_HHHH$var_dist)
```
Ok so it's good for all of them !! 
Let's do the ANOVA : 
We need to order the data first apparently. 
```{r}
Var_in_Sibship_dist_noNA$hapstr <- ordered(Var_in_Sibship_dist_noNA$hapstr, levels= c("AAAA","HHHH","RRRR"))
```

Now the anova itself
```{r}
# Compute the analysis of variance
res.aov.omy5 <- aov(var_dist  ~ hapstr , data = Var_in_Sibship_dist_noNA)
# Summary of the analysis
summary(res.aov.omy5)
```
```{r}
TukeyHSD(res.aov.omy5)
```


#### b) What about Sex grouping in HHHH ? 

```{r}
Var_in_HHHH_by_sex <-  Filtered_Fullsibs %>% 
  ungroup() %>% 
  filter(., hapstr== "HHHH") %>% 
  left_join(., Distance_Ultimate_key_V2_distanceOnly, by = c( "Sibship_Member" = "Sample_ID" )) %>% 
  group_by(., Sex, FullSibshipIndex) %>% 
  summarise(., mean_dist=mean(distance), var_dist=var(distance), sd_dist=sd(distance))
```

BUT, now remove groups with only one individual (i.e with no variance)
```{r}
Var_in_HHHH_by_sex_noNa <- Var_in_HHHH_by_sex %>% 
  filter(., !is.na(var_dist)) %>% 
  ungroup()

Var_in_HHHH_by_sex_noNa %>% count(Sex)
```
Ok so sex is not too unbalanced, I guess that's good !

Let's do the ANOVA : 
We need to order the data first apparently. 
```{r}
Var_in_HHHH_by_sex_noNa$Sex <- ordered(Var_in_HHHH_by_sex_noNa$Sex, levels= c("F","M"))
```

Now the anova itself
```{r}
# Compute the analysis of variance
res.aov.HHHHperSex <- aov(var_dist  ~ Sex , data = Var_in_HHHH_by_sex_noNa)
# Summary of the analysis
summary(res.aov.HHHHperSex)
```

```{r}
TukeyHSD(res.aov.HHHHperSex)
```
 
```{r}
res <- wilcox.test(var_dist ~ Sex, data = Var_in_HHHH_by_sex_noNa,
                   exact = FALSE)
res
```

## H) Mantel correlogram in BIG FISH from the 1809 fish ! 

### 1) Take big fish genotype and distance data

Distance data : Distance_Ultimate_key_V2_distanceOnly 
Genotype data : For_Colony_Sibship_Noduplicates (For all the 1995 fish MINUS THE DUPLICATES !)

A list of big fish
```{r}
Minimeta_V8_noDup_Big_Fish <- Minimeta_V8_noDup %>% 
  filter(., LENGTH >= 150)

nrow(Minimeta_V8_noDup_Big_Fish)
```

Filter the big fish only (Comes from Minimeta_V8_noDup so there are no duplicated samples)
```{r}
Distances_Big_fish  <- Distance_Ultimate_key_V2_distanceOnly %>% 
  filter(., Sample_ID %in% Minimeta_V8_noDup_Big_Fish$Sample_ID) %>% 
  arrange(., Sample_ID)
nrow(Distances_Big_fish)
```


### 2) Prepare 1809 genotypes


https://r-forge.r-project.org/scm/viewvc.php/*checkout*/www/files/tutorial.pdf?revision=150&root=adegenet&pathrev=462  

```{r}
head(For_Colony_Sibship_Noduplicates)
```
 



### 3) Add leading zeros to get a  three digits format ! 

```{r}
genotypes_Big_fish_two_digits <- data.frame(lapply(For_Colony_Sibship_Noduplicates, function(x){
  gsub("^([0-9]){1}$", "0\\1", x) 
  }))
genotypes_Big_fish_three_digits <- data.frame(lapply(genotypes_Big_fish_two_digits, function(x){
  gsub("^([0-9]{2})$", "0\\1", x) 
  }))

colnames(genotypes_Big_fish_three_digits) <- gsub("^tag_id_([0-9]{1,6}.[0-9]{1})$", "\\1", colnames(genotypes_Big_fish_three_digits))
colnames(genotypes_Big_fish_three_digits) <- gsub("^([0-9]{1,6}).([0-9]{1})$", "\\1_\\2", colnames(genotypes_Big_fish_three_digits))
```

 A couple of checks about missing data and identical rows ...

```{r}
genotypes_Big_fish_three_digits_HowManyNA <- genotypes_Big_fish_three_digits %>% 
  mutate( NAs= rowSums(is.na(genotypes_Big_fish_three_digits)))


nrow(genotypes_Big_fish_three_digits_HowManyNA)
Check_identical_Big_fish <- genotypes_Big_fish_three_digits_HowManyNA %>% 
  select(., -c(NAs, Sample_ID)) %>% 
  distinct()
nrow(Check_identical_Big_fish) == nrow(genotypes_Big_fish_three_digits_HowManyNA)
```
If True you have no identical rows

### 4) Replace NAs with "NA"
```{r}
i <- sapply(genotypes_Big_fish_three_digits, is.factor) # Identify all factor variables in your data
genotypes_Big_fish_three_digits[i] <- lapply(genotypes_Big_fish_three_digits[i], as.character) # Convert factors to character variables
genotypes_Big_fish_three_digits[is.na(genotypes_Big_fish_three_digits)] <- "na" # Replace NAs with "NA", as shown in Example 1
genotypes_Big_fish_three_digits[i] <- lapply(genotypes_Big_fish_three_digits[i], as.factor) # Convert character columns back to factors
```


### 5) From Two to One column per locus 

Merge columns together for conversion to genind
We need the one row/loci format ! 
```{r}
genotypes_Big_fish_3digs_oneColformat <- genotypes_Big_fish_three_digits %>% 
  gather(., Loci, Allele, -Sample_ID, na.rm = F) %>% 
  mutate(., Unified_Loci = gsub( x = Loci, "^([0-9]{1,6}).[0-9]{1}$", "\\1" )) %>%
  ungroup()  %>% 
  group_by(., Sample_ID, Unified_Loci) %>% 
  mutate(., two_alleles = paste0(Allele, collapse = "/")) %>% 
  select(., -c(Loci, Allele)) %>% 
  group_by(., Sample_ID) %>% 
  distinct(., Unified_Loci, .keep_all = T ) %>% 
  spread(., key = Unified_Loci, value = two_alleles) %>% 
  ungroup()

```

 
### 6) Individual-based correlogram

Here just make the rownames be Sample_ID
And we use the table in one-column per locus format 
```{r}
genotypes_Big_fish_three_digits_noPop <- genotypes_Big_fish_3digs_oneColformat %>%
#  mutate(., FakePops = Sample_ID) %>%   # We con't really need those fakepops anymore
  filter(., Sample_ID %in% Minimeta_V8_noDup_Big_Fish$Sample_ID) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID" )
genotypes_Big_fish_three_digits_noPop
```

```{r}
ncol(genotypes_Big_fish_three_digits_noPop)
nrow(genotypes_Big_fish_three_digits_noPop)
```


```{r}
genind_GenoBig_fish_distance_noPop <- df2genind(X = genotypes_Big_fish_three_digits_noPop , sep = "/" , NA.char = "na")

genind_GenoBig_fish_distance_noPop
``` 

 # No need to conver to genpop here aswe use poppr's function

Create distance matrixes 
 We use poppr here as it has functions to calculate distance based on individuals and not populations! 
You can change from Edward's to another but Edward is Euclidian so it's cool. 
And you have to to it on the genind object directly
```{r}
# We have a problem here because I need to define populations ! 
Edwards_Big_fish_genetic_distance_noPop <- edwards.dist(genind_GenoBig_fish_distance_noPop)
summary(Edwards_Big_fish_genetic_distance_noPop)

# Number of NAs
sum(which(is.na(Edwards_Big_fish_genetic_distance_noPop)))
head(Edwards_Big_fish_genetic_distance_noPop)

# Below I write the file to check why there are so many NAs: 
# I think it is because any non-typed marker creates a cascad effect and only NA in given individual. 
checkNAs_in_Edwards_Big_fish_genetic_distance_noPop <- as.data.frame(as.matrix(Edwards_Big_fish_genetic_distance_noPop))
write.csv(x = checkNAs_in_Edwards_Big_fish_genetic_distance_noPop, file = "Distance_analysis/checkNAs_in_Edwards_Big_fish_genetic_distance_noPop.txt")
```

```{r}
summary(as.vector(Edwards_Big_fish_genetic_distance_noPop))
```


We compute a "y" coordinate made of zeros, so that a matrix can be done.
```{r}
Distances_Big_fish_y0 <- Distances_Big_fish %>% 
  mutate( pseudo_y = 0) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID")

dist_Big_fish_geographic_distance <- dist(Distances_Big_fish_y0, "euclidean")

#summary(dist_Big_fish_geographic_distance)
```

```{r}
summary(as.vector(dist_Big_fish_geographic_distance))
```

### ICI CA MARCHE PAS 
On essaie de faire le correlogramme pour tous les 1809 poissons. 

Test Isolation by Distance
```{r}
Mantimanto <- mantel.randtest(Edwards_Big_fish_genetic_distance_noPop , dist_Big_fish_geographic_distance, nrepet = 99)
Mantimanto
```
Overall Mantel test is NOT WORKING HERE !

Be careful because this doesn't NECESSARILY mean that you have IDB ! :) 

```{r}
plot(Mantimanto)
```


```{r}
MantimantoCorr_1809_big <- mgram(species.d = Edwards_Big_fish_genetic_distance_noPop , space.d =  dist_Big_fish_geographic_distance, nperm = 999, cboot = 0.95, nboot = 999)
MantimantoCorr_1809_big
plot(MantimantoCorr_1809_big)
```
Remember that in principle, a significant Mantel test or a correlogram pattern only indicates that genetic variability is structured in geographic space. 


## I) Mantel correlogram in YOY sibships ! 

This time we take only YoYs. 
We will use Filtered_Fullsibs (Sibships, not necessarily YoYs, filtered for prob.Inc > 0.99).

Distance data : Distance_Ultimate_key_V2 
ALL sibship data : Filtered_Fullsibs

```{r}
head(Filtered_Fullsibs)
```

### 0) Remove some sibships of extreme size 
 Wait a second ! 
What if we remove big and small sibships (i.e big sibships have higher chances of being spurious and small ones won't show up in the correlations ?!)
```{r}
Mini_Summary_per_Sibgroup_Allfish %>% 
  count(., Sibsize)
```
 So let's try with what is between 5 and 25 sibsize !! 


The dataset "Filtered_YOY_Fullsibs" has kind of an obscure origin. 
Let's make it again with the idea that it is "Filtered_Fullsibs" with a YoY 95mm threshold.

```{r}
Filtered_YOY_Fullsibs <- Filtered_Fullsibs %>% 
  filter(., LENGTH <= 95) %>% 
    group_by(., FullSibshipIndex, Coll_year) %>% 
  add_count() %>% 
  rename(., YOY_sibsize_byYear = 'n') %>%  
  filter(., YOY_sibsize_byYear > 1) %>% 
  ungroup() %>% 
  group_by(., FullSibshipIndex) %>% 
  add_count() %>% 
  rename(., YOY_sibsize_AllYears = 'n')

Filtered_YOY_Fullsibs_NoSmallNoBigSibship <- Filtered_YOY_Fullsibs %>% 
  filter(., !Sibsize > 100) %>% 
  filter(., !Sibsize < 1)   
```

```{r}
nrow(Filtered_Fullsibs) == nrow(Filtered_Fullsibs_NoSmallNoBigSibship)
```



### 1) Prepare All sibships genotypes


https://r-forge.r-project.org/scm/viewvc.php/*checkout*/www/files/tutorial.pdf?revision=150&root=adegenet&pathrev=462  

 WARNING : Here we DON'T really use all the sibships: We try filtering out the big and small ones, see above!

Reduce the 1995 fish dataset to All sibships only and change the indiv.ID to Sample_ID format.  
```{r}
genotypes_All_sibships <- gtseq7.12_ubc_hap2col_current_vcf.txt %>% 
  left_join(., Key_BC_V1, by = "indiv.ID") %>% 
  select(., - c(indiv.ID, group)) %>% 
  filter(.,Sample_ID %in% Filtered_Fullsibs_NoSmallNoBigSibship$Sibship_Member) 
```



### 3) Add leading zeros to get a  three digits format ! 

```{r}
genotypes_All_sibships_two_digits <- data.frame(lapply(genotypes_All_sibships, function(x){
  gsub("^([0-9]){1}$", "0\\1", x) 
  }))
genotypes_All_sibships_three_digits <- data.frame(lapply(genotypes_All_sibships_two_digits, function(x){
  gsub("^([0-9]{2})$", "0\\1", x) 
  }))

colnames(genotypes_All_sibships_three_digits) <- gsub("^tag_id_([0-9]{1,6}.[0-9]{1})$", "\\1", colnames(genotypes_All_sibships_three_digits))
colnames(genotypes_All_sibships_three_digits) <- gsub("^([0-9]{1,6}).([0-9]{1})$", "\\1_\\2", colnames(genotypes_All_sibships_three_digits))

```

 A couple of checks about missing data and identical rows ... 

```{r}
genotypes_All_sibships_three_digits_HowManyNA <- genotypes_All_sibships_three_digits %>% 
  mutate( NAs= rowSums(is.na(genotypes_All_sibships_three_digits)))


nrow(genotypes_All_sibships_three_digits_HowManyNA)
Check_identical_GenoAll <- genotypes_All_sibships_three_digits_HowManyNA %>% 
  select(., -c(NAs, Sample_ID)) %>% 
  distinct()
nrow(Check_identical_GenoAll) == nrow(genotypes_All_sibships_three_digits_HowManyNA)
```
If true you have no identical rows ! 


### 4) Replace NAs with "na"

 Ya une sombre histoire avec les NA ici. En gros mieux vaut remplacer par "na"

```{r}
i <- sapply(genotypes_All_sibships_three_digits, is.factor) # Identify all factor variables in your data
genotypes_All_sibships_three_digits[i] <- lapply(genotypes_All_sibships_three_digits[i], as.character) # Convert factors to character variables
genotypes_All_sibships_three_digits[is.na(genotypes_All_sibships_three_digits)] <- "na" # Replace NAs with "NA", as shown in Example 1
genotypes_All_sibships_three_digits[i] <- lapply(genotypes_All_sibships_three_digits[i], as.factor) # Convert character columns back to factors
```



### 5) From Two to One column per locus 

Merge columns together for conversion to genind
We need the one row/loci format ! 
```{r}
genotypes_All_sibships_3digs_oneColformat <- genotypes_All_sibships_three_digits %>% 
  gather(., Loci, Allele, -Sample_ID, na.rm = F) %>% 
  mutate(., Unified_Loci = gsub( x = Loci, "^([0-9]{1,6}).[0-9]{1}$", "\\1" )) %>%
  ungroup()  %>% 
  group_by(., Sample_ID, Unified_Loci) %>% 
  mutate(., two_alleles = paste0(Allele, collapse = "/")) %>% 
  select(., -c(Loci, Allele)) %>% 
  group_by(., Sample_ID) %>% 
  distinct(., Unified_Loci, .keep_all = T ) %>% 
  spread(., key = Unified_Loci, value = two_alleles) %>% 
  ungroup()

```


### 6) Individual-based correlogram

Without grouping per sibship, we just compute individual distances. 

Now convert in genind format !  WE LEAVE POP = NULL !!! 
And we use the table in one-column per locus format 

```{r}
# Remove "pop" (i.e sibship information)    
genotypes_All_sibships_three_digits_noPop <- genotypes_All_sibships_3digs_oneColformat %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID" ) 
 

genind_GenoAlls_sibships_distance_noPop <- df2genind(X = genotypes_All_sibships_three_digits_noPop , sep = "/" , NA.char = "na")

genind_GenoAlls_sibships_distance_noPop
``` 

Prepare the distance info for all the sibships
```{r}
All_minidistance <- Minidistance_V1 %>% 
  filter(., Sample_ID %in% Filtered_Fullsibs_NoSmallNoBigSibship$Sibship_Member) %>% 
  arrange(., Sample_ID) 
```

 # No need to conver to genpop here aswe use poppr's function


Create distance matrixes 
 We use poppr here as it has functions to calculate distance based on individuals and not populations! 
You can change from Edward's to another but Edward is Euclidian so it's cool. 
And you have to to it on the genind object directly
```{r}
# We have a problem here because I need to define populations ! 
Edwards_All_SIbships_Indiv_genetic_distance_noPop <- edwards.dist(genind_GenoAlls_sibships_distance_noPop)
# summary(Edwards_All_SIbships_Indiv_genetic_distance_noPop)
head(Edwards_All_SIbships_Indiv_genetic_distance_noPop)
```
 
We compute a "y" coordinate made of zeros, so that a matrix can be done.
```{r}
All_minidistance_y0 <- All_minidistance %>% 
  mutate( pseudo_y = 0) %>% 
  column_to_rownames(., "Sample_ID")

dist_All_sibships_Indiv_geographic_distance <- dist(All_minidistance_y0, "euclidean")

#summary(dist_All_sibships_Indiv_geographic_distance)
```

 ICI NON PLUS CA MARCHE PAS : 
 Généralement on as un problème avec les grandes matrices, les NA et les tests de Mantel ... 

Test Isolation by Distance
```{r}
Mantimanto_Allsibs <- mantel.randtest(Edwards_All_SIbships_Indiv_genetic_distance_noPop , dist_All_sibships_Indiv_geographic_distance, nrepet = 10000)
Mantimanto_Allsibs
```
Overall Mantel test is NOT WORKING HERE ! 

Be careful because this doesn't NECESSARILY mean that you have IDB ! :) 

```{r}
plot(Mantimanto_Allsibs)
```


```{r}
MantimantoCorr_Allsibs <- mgram(species.d = Edwards_All_SIbships_Indiv_genetic_distance_noPop , space.d =  dist_All_sibships_Indiv_geographic_distance, nperm = 999, cboot = 0.95, nboot = 999)
MantimantoCorr_Allsibs
plot(MantimantoCorr_Allsibs)
```
Remember that in principle, a significant Mantel test or a correlogram pattern only indicates that genetic variability is structured in geographic space. 


## J) Permute sibships and test variance difference. 

The idea is to permute groups of sibships many times, in order to create random sibships and compute their distance variance. Then compare the variance of distance in true sibships compared to random sibships. 

The  main  function  in permute for  providing  random  permutations  is shuffle().   We  can write our own randomisation test for the jackal data by first creating a function to compute the difference of means for two groups which can be used in a simple for()loop to generate the null distribution for the difference of means.  First, we allocate some storage to hold the null difference of means; here we use4999 random permutations so allocate a vector of length 5000.  Then we iterate, randomly generating  an  ordering  of  the Sex vector  and  computing  the  difference  of  means  for  that permutation.
The null distribution of Dican be visualised using a histogram, as shown in Figure 1.  Theobserved difference of means (4.8) is indicated by the red tick mark.


```{r}
library(permute)

# Create the right dataset
Filtered_Fullsibs_distances <- Filtered_Fullsibs %>% 
  ungroup() %>% 
  left_join(., Minidistance_V1, by = c("Sibship_Member" = "Sample_ID")) %>% 
  select(., FullSibshipIndex, distance, Sibship_Member)
 
set.seed(42)
Djackal <- numeric(length = 1000)
N <- nrow(Filtered_Fullsibs_distances)

 for(i in seq_len(length(Djackal) - 1)) {
         perm <- shuffle(N)
         temp_dataset <- Filtered_Fullsibs_distances 
         temp_dataset$FullSibshipIndex <- temp_dataset$FullSibshipIndex[perm]
         Djackal[i] <- temp_dataset %>% 
                         group_by(FullSibshipIndex) %>% 
                         mutate(., varianceDist = var(distance)) %>% 
                         ungroup() %>% 
                         mutate(BigVarDistmean = mean(varianceDist))  %>% 
                         distinct(BigVarDistmean)
     }
Djackal[1000] <- Djackal[1] # Just stupid line to remind that we dont replace the 100' value by our observed data. 

#The observed difference of variances was added to the null distribution, because under the null hypothesis the observed allocation of distance in different sibships is just one of the possible random allocations.
Reality_varDist <- Filtered_Fullsibs_distances %>% 
                         group_by(FullSibshipIndex) %>% 
                         mutate(., varianceDist = var(distance)) %>% 
                         ungroup() %>% 
                         mutate(BigVarDistmean = mean(varianceDist))  %>% 
                         distinct(BigVarDistmean, .keep_all = F)
   
```

```{r}
Djackal_vector <- as.numeric(Djackal)
Reality_varDist_numeric <-  as.numeric(Reality_varDist)

hist(Djackal_vector)
```
The number of values in the randomisation distribution equal to or larger than the observed difference is

```{r}
Dbig <- sum(Djackal <= Reality_varDist_numeric)
Dbig
```
giving a permutational p-value of

```{r}
Dbig / length(Djackal)
```

which is comparable with that determined from the frequentist t-test, and indicates strong evidence against the null hypothesis of no difference.

## K) SAMPLE sibships and test variance difference. 

SAME AS ABOVE IN J) BUT INSTEAD OF PERMUTATIONS WE DO A DRAWING WITH REPLACEMENT

```{r}
library(permute)

# Create the right dataset
Filtered_Fullsibs_distances <- Filtered_Fullsibs %>% 
  ungroup() %>% 
  left_join(., Minidistance_V1, by = c("Sibship_Member" = "Sample_ID")) %>% 
  select(., FullSibshipIndex, distance, Sibship_Member)
 
set.seed(42)
Djackal_2 <- numeric(length = 3000)
N <- nrow(Filtered_Fullsibs_distances)

 for(i in seq_len(length(Djackal_2) - 1)) {
         # Below sample in FUllsibshipIndex with replacement
         sample_fullsib <- sample(x= Filtered_Fullsibs_distances$FullSibshipIndex, size = N, replace = TRUE)
         temp_dataset <- Filtered_Fullsibs_distances 
         temp_dataset$FullSibshipIndex <- sample_fullsib # Replace FullsibshipIndex with the re-sampled one
         Djackal_2[i] <- temp_dataset %>% 
                         group_by(FullSibshipIndex) %>% 
                         mutate(., varianceDist = var(distance, na.rm = T)) %>% 
                         #mutate(.,  varianceDist = ifelse(is.na(varianceDist), 0 , varianceDist)) %>% 
                         # Line above was to avoid getting NA's because of sibships sampled once only 
                         # but we prefer to simly remove the NA's like below 
                         filter(., !is.na(varianceDist) ) %>% 
                         ungroup() %>% 
                         mutate(BigVarDistmean = mean(varianceDist))  %>% 
                         distinct(BigVarDistmean)
     }
Djackal_2[3000] <- Djackal_2[1] # Just stupid line to remind that we dont replace the 100' value by our observed data. 

#The observed difference of variances was added to the null distribution, because under the null hypothesis the observed allocation of distance in different sibships is just one of the possible random allocations.
Reality_varDist_2 <- Filtered_Fullsibs_distances %>% 
                         group_by(FullSibshipIndex) %>% 
                         mutate(., varianceDist = var(distance)) %>% 
                         ungroup() %>% 
                         mutate(BigVarDistmean = mean(varianceDist))  %>% 
                         distinct(BigVarDistmean, .keep_all = F)
   
```


```{r}
Djackal_vector_2 <- as.numeric(Djackal_2)
Reality_varDist_numeric2 <-  as.numeric(Reality_varDist_2)

hist(Djackal_vector_2)
```
The number of values in the randomisation distribution equal to or larger than the observed difference is

```{r}
Dbig2 <- sum(Djackal_2 <= Reality_varDist_numeric2)
Dbig2
```
giving a permutational p-value of

```{r}
Dbig2 / length(Djackal_2)
```

which is comparable with that determined from the frequentist t-test, and indicates strong evidence against the null hypothesis of no difference.


SO WE ARE GOOD TO SAY THAT SIBLINGS STAY SPATIALLY CLUSTERED IN THE CREEK !! 
SO WE ARE GOOD TO SAY THAT SIBLINGS STAY SPATIALLY CLUSTERED IN THE CREEK !! 
SO WE ARE GOOD TO SAY THAT SIBLINGS STAY SPATIALLY CLUSTERED IN THE CREEK !! 
SO WE ARE GOOD TO SAY THAT SIBLINGS STAY SPATIALLY CLUSTERED IN THE CREEK !! 

 
 How much smaller is the mean of mean of variance of distance in real data than in simulated data ?
```{r}

mean(unlist(Djackal_2))/Reality_varDist_numeric2

```
 
 
## L) But how close do they stay from each other ? 

```{r}
Filtered_Fullsibs_distances_perGroup <- Filtered_Fullsibs_distances %>%
                               group_by(FullSibshipIndex) %>% 
                               mutate(., Diff=c(last(distance)-first(distance),diff(distance))) %>% 
                               mutate(., meandiff = mean(Diff))


Filtered_Fullsibs_distances_perGroup <- Filtered_Fullsibs_distances %>%
                               group_by(FullSibshipIndex) %>% 
                               arrange(., distance, .by_group = TRUE) %>% 
                               mutate(., Diff = distance - lag(distance)) %>% 
                               mutate(., meandiff = mean(Diff, na.rm = T))


Filtered_Fullsibs_distances_perGroup <- Filtered_Fullsibs_distances
 #Create list by group
L <- split(Filtered_Fullsibs_distances_perGroup,Filtered_Fullsibs_distances_perGroup$FullSibshipIndex)
#Create function
compute_d <- function(x)
{
  xv <- as.numeric(x$distance)
  y <- dist(xv)
  avg <- mean(y)
  y1 <- as.data.frame(as.matrix(y))
  y2 <- cbind(x,y1)
  y2$mean <- avg
  return(y2)
}
#Apply function
# I got help for this line, it gives me exactly what I want: The mean of pairwise distances wihtin sibship groups. 
mean_pairwise_distances <- do.call('rbind', lapply(lapply(L,compute_d), function(x) x%>% select(mean) %>% distinct(mean)))
Best_mean_pairwise_distances <- mean_pairwise_distances %>%  
  mutate(., FullSibshipIndex = rownames(.)) %>% 
  rename(., mean_pairwise_distance = "mean") %>% 
  select(., FullSibshipIndex, mean_pairwise_distance)
Best_mean_pairwise_distances$FullSibshipIndex <- as.numeric(Best_mean_pairwise_distances$FullSibshipIndex
)

```
  
```{r}
# Add our new value to the distances dataset
Filtered_Fullsibs_distances_V2 <- Filtered_Fullsibs_distances %>% 
  left_join(., Best_mean_pairwise_distances, by = "FullSibshipIndex")

# And all this to the Filtered fullsibs
Filtered_Fullsibs_V2 <- Filtered_Fullsibs %>% 
  left_join(., Filtered_Fullsibs_distances_V2, by = c("FullSibshipIndex", "Sibship_Member" ) )

```

### Approach one : BAD
  Noe !! 
  Here we have our dataset with distances etc etc. 
  We want to see if % of A alleles have an effect on dispersal, so we will use "Proportions_of_AAAA_per_SIBSHIP", a dataset created LATER in the script (bad practice, I know)
  
```{r}
Proportions_of_AAAA_per_SIBSHIP_only <- Proportions_of_AAAA_per_SIBSHIP %>% 
  select(., FullSibshipIndex ,Proportion_A_alleles_Sibship) %>% 
  distinct(., FullSibshipIndex, .keep_all =  T)

Filtered_Fullsibs_V3 <- Filtered_Fullsibs_V2 %>% 
  left_join(., Proportions_of_AAAA_per_SIBSHIP_only, by = "FullSibshipIndex")

```
  
  You need to create a dataset with only one occurence of each sibship to not inflate the numbers.
```{r}
For_AAAA_dispersal_cor_test_ONLY <- Filtered_Fullsibs_V3 %>% 
  distinct(., FullSibshipIndex, .keep_all = T)

cor.test(For_AAAA_dispersal_cor_test_ONLY$mean_pairwise_distance, For_AAAA_dispersal_cor_test_ONLY$Proportion_A_alleles_Sibship, alternative = "greater", method = "pearson")
```
  Fuck ! Dispersal is NOT correlated with proportion of A alleles in the sibship !
 
### Approach two : BETTER
  
 So AS THE PROPORTION OF A ALLELES THING DID NOT WORK , let's try another aprroach: 
 
 Let's compute, per individual, the distance between the individual (Distance_of_ind_from_mean_distance) and the center of the sibship (i.e mean distance, #Mean_distance_per_Sib), and compare it with the mean distance between all individuals.
 
 > CAPTION : 
 
 DiffCenterPairwise = 
 Difference between the distance of the individual with the "center" of the sibship (i.e mean distance in stream) and the mean pairwise distances of individuals in the sibship. 
 
 
 
```{r}
Filtered_Fullsibs_V4 <- Filtered_Fullsibs_V3 %>% 
  ungroup() %>% 
  filter(., !Sibsize == 2) %>% 
  group_by(., FullSibshipIndex) %>% 
  mutate(., Mean_distance_per_Sib = mean(distance)) %>% 
  mutate(., Distance_of_ind_from_mean_distance = abs(distance - Mean_distance_per_Sib)) %>% 
  mutate(., DiffCenterPairwise = abs(Distance_of_ind_from_mean_distance - mean_pairwise_distance)) %>% 
  mutate(., Pos_from_MeanDistsibship = distance - Mean_distance_per_Sib)
```
 
 Now let's check what we want : 
 
#### a) Do AAAA disperse more in all sibships ?  
 
```{r}
AAAA_individuals_from_sibship <- Filtered_Fullsibs_V4 %>% 
  filter(., hapstr == "AAAA")

RRRR_individuals_from_sibship <- Filtered_Fullsibs_V4 %>% 
  filter(., hapstr == "RRRR")

t.test(AAAA_individuals_from_sibship$DiffCenterPairwise, RRRR_individuals_from_sibship$DiffCenterPairwise, alternative = "greater")

```
 
 The mean of the differences between 1) the distance of the individual with the "center" of the sibship (i.e mean distance in stream) and 2) the mean pairwise distances of individuals in the sibship; is greater for AAAA individuals than RRRR individuals ! 

#### b) Do AAAA disperse more in YOY sibships ?

So let's be clear: 
Here we take our datasets with all the fullsibs (filtered etc) and then we don't bother at looking at the fish that have a YoY duplicate (i.e YoY clone) and we just filter by YoY and then look at dispersal.

However, to not bias the thing we need to recalculate the distances per sibship! 

To do that we take back the chunk from all above: 
```{r}
# First recalculate the mean pairwise distance and then it is easy !

## A) Take the YoYs fish from all this sibship mess 

  # And of course don't forget to eliminate sibship for which there was 1 YoY only because in those cases we are going to have troubles estimating pairwaise distances, right? 

YoY_from_Filtered_Fullsibs <- Filtered_Fullsibs %>%  # We come back to version 1, i.e before any distance related calculation. 
  filter(., YOY == "YES") %>% 
  group_by(., FullSibshipIndex) %>% 
  add_count(., name = "Number_of_YoYs_in_Sibship") %>% 
  filter(., !Number_of_YoYs_in_Sibship == 1)

## B) Now reduce the dataset used to calculate pairwise distances before to just YoYs

YOY_Filtered_Fullsibs_distances_perGroup <- Filtered_Fullsibs_distances %>% 
  filter(., Sibship_Member %in% YoY_from_Filtered_Fullsibs$Sibship_Member)

## C) You are ready to calculate mean pairwise distances for YoYs of the sibships

 #Create list by group
L_Yoys <- split(YOY_Filtered_Fullsibs_distances_perGroup,YOY_Filtered_Fullsibs_distances_perGroup$FullSibshipIndex)
#Create function
compute_d <- function(x)
{
  xv <- as.numeric(x$distance)
  y <- dist(xv)
  avg <- mean(y)
  y1 <- as.data.frame(as.matrix(y))
  y2 <- cbind(x,y1)
  y2$mean <- avg
  return(y2)
}
#Apply function
# I got help for this line, it gives me exactly what I want: The mean of pairwise distances wihtin sibship groups. 
mean_pairwise_distances_YoYs <- do.call('rbind', lapply(lapply(L_Yoys,compute_d), function(x) x%>% select(mean) %>% distinct(mean)))
Best_mean_pairwise_distances_YoYs <- mean_pairwise_distances_YoYs %>%  
  mutate(., FullSibshipIndex = rownames(.)) %>% 
  rename(., mean_pairwise_distance = "mean") %>% 
  select(., FullSibshipIndex, mean_pairwise_distance)
Best_mean_pairwise_distances_YoYs$FullSibshipIndex <- as.numeric(Best_mean_pairwise_distances_YoYs$FullSibshipIndex
)
```

```{r}
# Add our new value to the distances dataset (YoYs only here)
YoY_Filtered_Fullsibs_distances_V2 <- YOY_Filtered_Fullsibs_distances_perGroup %>% 
  left_join(., Best_mean_pairwise_distances_YoYs, by = "FullSibshipIndex")

# And all this to the Filtered fullsibs
YoY_Filtered_Fullsibs_V2 <- YoY_from_Filtered_Fullsibs %>% 
  left_join(., YoY_Filtered_Fullsibs_distances_V2, by = c("FullSibshipIndex", "Sibship_Member" ) )

```
Ok good you have the newly calculated pairwise distances for YoYs of the sibships.

But now you need to recalculate the "DiffCenterPairwise", as defined earlier. 
 
 
 
### CHECK HERE FOR DISPERSAL
### CHECK HERE FOR DISPERSAL
### CHECK HERE FOR DISPERSAL
 
```{r}
# So here we go straight to V4 from V2 since V3 was only the incorporation of proportion of A alleles in sibships which is not useful here!

YoY_Filtered_Fullsibs_V4 <- YoY_Filtered_Fullsibs_V2 %>% 
  ungroup() %>% 
  filter(., !Number_of_YoYs_in_Sibship == 2) %>% 
  group_by(., FullSibshipIndex) %>% 
  mutate(., Mean_distance_per_Sib = mean(distance)) %>% 
  mutate(., Distance_of_ind_from_mean_distance = abs(distance - Mean_distance_per_Sib)) %>% 
  mutate(., DiffCenterPairwise = abs(Distance_of_ind_from_mean_distance - mean_pairwise_distance)) %>% 
  mutate(., Pos_from_MeanDistsibship = distance - Mean_distance_per_Sib) 

```


```{r}
YoY_AAAA_individuals_from_sibship <- YoY_Filtered_Fullsibs_V4 %>% 
  filter(., hapstr == "AAAA")  

YoY_RRRR_individuals_from_sibship <- YoY_Filtered_Fullsibs_V4 %>% 
  filter(., hapstr == "RRRR")

t.test(YoY_AAAA_individuals_from_sibship$DiffCenterPairwise, YoY_RRRR_individuals_from_sibship$DiffCenterPairwise, alternative = "greater")

```
```{r}
Summary_Sibsizes_Filtered_Fullsibs_V4 <- Filtered_Fullsibs_V4 %>% ungroup() %>% distinct(., FullSibshipIndex, .keep_all = T) %>% group_by(., Sibsize) %>% add_count() %>% select(., Sibsize, n) %>% 
  distinct(., Sibsize, .keep_all = T) %>% 
  ungroup() %>% 
  mutate(., "Smaller_than_7_fish" = ifelse(test = Sibsize < 7, yes =  "Yes",no =  "No")) %>% 
  group_by(., Smaller_than_7_fish) %>% 
  summarise(., How_many_smaller_than_7_fish = sum(n))
```

So 50% of the populations are smaller than 7 individuals. 
 
#### c) What about sex-dependent dominance ?  
 
```{r}
Males_HHHH_individuals_from_sibship <- Filtered_Fullsibs_V4 %>% 
  filter(., hapstr == "HHHH") %>% 
  filter(., Sex == "M")

Females_HHHH_individuals_from_sibship <- Filtered_Fullsibs_V4  %>% 
  filter(., hapstr == "HHHH") %>% 
  filter(., Sex == "F")  


t.test(Females_HHHH_individuals_from_sibship$DiffCenterPairwise, Males_HHHH_individuals_from_sibship$DiffCenterPairwise, alternative = "greater")

```
So it's not significant , we don't see the sex-dependent dominance pattern here.

In YoYs maybe we'll se it !??
```{r}
YoY_Males_HHHH_individuals_from_sibship <- YoY_Filtered_Fullsibs_V4 %>% 
  filter(., hapstr == "HHHH") %>% 
  filter(., Sex == "M")

YoY_Females_HHHH_individuals_from_sibship <- YoY_Filtered_Fullsibs_V4  %>% 
  filter(., hapstr == "HHHH") %>% 
  filter(., Sex == "F")  


t.test(YoY_Females_HHHH_individuals_from_sibship$DiffCenterPairwise, YoY_Males_HHHH_individuals_from_sibship$DiffCenterPairwise, alternative = "greater")

```
Nope

#### d) How far appart are the siblings ?

First in all sibships
```{r}
MeanPairwise_distances_Allsibships <- Filtered_Fullsibs_V4 %>% 
  distinct(., FullSibshipIndex , .keep_all = T) 

mean(MeanPairwise_distances_Allsibships$mean_pairwise_distance)
```

Second in sibships that are NOT YoY sibship
```{r}
MeanPairwise_distances_All_but_YOY_sibships <- Filtered_Fullsibs_V4 %>% 
  filter(., !FullSibshipIndex %in% YoY_Filtered_Fullsibs_V4$FullSibshipIndex) %>% 
  distinct(., FullSibshipIndex , .keep_all = T) 

mean(MeanPairwise_distances_All_but_YOY_sibships$mean_pairwise_distance)
```

Then in only YoY sibships (Remember we removed sibships of size 2 for these dispersal stuff)
```{r}
MeanPairwise_distances_Only_YoY_sibships <- YoY_Filtered_Fullsibs_V4 %>% 
  distinct(., FullSibshipIndex , .keep_all = T) 

mean(MeanPairwise_distances_Only_YoY_sibships$mean_pairwise_distance)
```
#### e) Do the "A" YoYs actually go downstream? 

It would be good to check! Both answers would be really interesting.

Update your fullsibs datasets to include a variable that would allow such measurement.

We could check the % of "A" individuals that are actually more downstream than their siblings.

We should also check if the average distance from sibship is significantly lower in "A" individuals --> We did and it is not.
But what if we take only females? 

##### One) Update dataset
```{r}
Filtered_Fullsibs_V5 <- Filtered_Fullsibs_V4 %>% 
  # So first we want a variable saying if they are upstream or downstream
  ungroup() %>% 
  mutate(., Pos_from_sibship_qual = if_else(condition = Pos_from_MeanDistsibship < 0,   "Downstream", "Upstream")) %>% 
  group_by(., FullSibshipIndex, Pos_from_sibship_qual) %>% 
  add_count(., name = "Number_of_fish_up") %>% 
  # Then we want the MEDIAN distance per sibship, since some very fast moving fish may influence the mean too much. 
  ungroup() %>% 
  group_by(., FullSibshipIndex) %>% 
  mutate(., Median_Distance_per_sib = median(distance)) %>% 
  # Finally we need the position from MEDIAN sibship this time. This may work better than the mean to detect differences between sexes or Omy5.
  mutate(., Pos_from_MedianDistsibship = distance - Median_Distance_per_sib)

# Now same thing with the YoY dataset !

YoY_Filtered_Fullsibs_V5 <- YoY_Filtered_Fullsibs_V4 %>% 
  # So first we want a variable saying if they are upstream or downstream
  ungroup() %>% 
  mutate(., Pos_from_sibship_qual = if_else(condition = Pos_from_MeanDistsibship < 0,   "Downstream", "Upstream")) %>% 
  group_by(., FullSibshipIndex, Pos_from_sibship_qual) %>% 
  add_count(., name = "Number_of_fish_up") %>% 
  # Then we want the MEDIAN distance per sibship, since some very fast moving fish may influence the mean too much. 
  ungroup() %>% 
  group_by(., FullSibshipIndex) %>% 
  mutate(., Median_Distance_per_sib = median(distance)) %>% 
  # Finally we need the position from MEDIAN sibship this time. This may work better than the mean to detect differences between sexes or Omy5.
  mutate(., Pos_from_MedianDistsibship = distance - Median_Distance_per_sib)
```

Prepare some datasets of YoYs separated by Omy5 hapstr
```{r}
YoY_AAAA_individuals_from_sibship <- YoY_Filtered_Fullsibs_V5 %>% 
  filter(., hapstr == "AAAA")  

YoY_RRRR_individuals_from_sibship <- YoY_Filtered_Fullsibs_V5 %>% 
  filter(., hapstr == "RRRR")
```

Prepare some datasets of all fish separated by Omy5 hapstr
```{r}
AAAA_individuals_from_sibship <- Filtered_Fullsibs_V5 %>% 
  filter(., hapstr == "AAAA")  

RRRR_individuals_from_sibship <- Filtered_Fullsibs_V5 %>% 
  filter(., hapstr == "RRRR")
```

Prepare some datasets of "A" females vs any other individuals. 
```{r}
AAAA_females_from_sibship <- Filtered_Fullsibs_V5 %>% 
  filter(., hapstr == "AAAA") %>% 
  filter(., Sex == "F")

Allfish_but_AAAA_females_from_sibship <- Filtered_Fullsibs_V5 %>% 
  filter(., !Sibship_Member %in% AAAA_females_from_sibship$Sibship_Member)

#Check every fish is either in one or the other.
nrow(AAAA_females_from_sibship) + nrow(Allfish_but_AAAA_females_from_sibship) == nrow(Filtered_Fullsibs_V5)
```
Prepare some datasets of "A" YoY females vs any other YoY individuals. 
```{r}
YoY_AAAA_females_from_sibship <- YoY_Filtered_Fullsibs_V5 %>% 
  filter(., hapstr == "AAAA") %>% 
  filter(., Sex == "F")

YoY_Allfish_but_AAAA_females_from_sibship <- YoY_Filtered_Fullsibs_V5 %>% 
  filter(., !Sibship_Member %in% AAAA_females_from_sibship$Sibship_Member)

#Check every fish is either in one or the other.
nrow(YoY_AAAA_females_from_sibship) + nrow(YoY_Allfish_but_AAAA_females_from_sibship) == nrow(YoY_Filtered_Fullsibs_V5)
```
Prepare some datasets of all fish separated by SEX in YoYs
```{r}
YoY_Females_from_sibship <- YoY_Filtered_Fullsibs_V5 %>% 
  filter(., Sex == "F")  

YoY_Males_from_sibship <- YoY_Filtered_Fullsibs_V5 %>% 
  filter(., Sex == "M")

nrow(YoY_Females_from_sibship)
nrow(YoY_Males_from_sibship)
```

##### Two) Do some tests in YoYs

Now below we test if the distance from sibship is lower (i.e negative for fish moving downstream!) in YoYs.
```{r}
t.test(YoY_AAAA_individuals_from_sibship$Pos_from_MeanDistsibship, YoY_RRRR_individuals_from_sibship$Pos_from_MeanDistsibship, alternative = "less")

```
But now let's do it with the median.
```{r}
t.test(YoY_AAAA_individuals_from_sibship$Pos_from_MedianDistsibship, YoY_RRRR_individuals_from_sibship$Pos_from_MedianDistsibship, alternative = "less")
```

##### Three) Do the same tests in all sibships

Now below we test if the distance from sibship is lower (i.e negative for fish moving downstream!) in  all sibships
```{r}
t.test(AAAA_individuals_from_sibship$Pos_from_MeanDistsibship, RRRR_individuals_from_sibship$Pos_from_MeanDistsibship, alternative = "less")

```
But now let's do it with the median.
```{r}
t.test(AAAA_individuals_from_sibship$Pos_from_MedianDistsibship, RRRR_individuals_from_sibship$Pos_from_MedianDistsibship, alternative = "less")
```
##### Four) Now compare "A" females to other fish

Now below we test if the distance from sibship is lower (i.e negative for fish moving downstream!) in "A" females vs other fish
```{r}
t.test(AAAA_females_from_sibship$Pos_from_MeanDistsibship, Allfish_but_AAAA_females_from_sibship$Pos_from_MeanDistsibship, alternative = "less")

```
But now let's do it with the median.
```{r}
t.test(AAAA_females_from_sibship$Pos_from_MedianDistsibship, Allfish_but_AAAA_females_from_sibship$Pos_from_MedianDistsibship, alternative = "less")
```
##### Five) Compare "A" YoY females to other YoY fish

Now below we test if the distance from sibship is lower (i.e negative for fish moving downstream!) in "A" YoY females vs other YoY fish.
```{r}
t.test(YoY_AAAA_females_from_sibship$Pos_from_MeanDistsibship, YoY_Allfish_but_AAAA_females_from_sibship$Pos_from_MeanDistsibship, alternative = "less")

```
But now let's do it with the median.
```{r}
t.test(YoY_AAAA_females_from_sibship$Pos_from_MedianDistsibship, YoY_Allfish_but_AAAA_females_from_sibship$Pos_from_MedianDistsibship, alternative = "less")
```

##### Six) Compare females to males in YoY fish

Now below we test if the distance from sibship is lower (i.e negative for fish moving downstream!) in Males vs females
```{r}
t.test(YoY_Females_from_sibship$Pos_from_MeanDistsibship, YoY_Males_from_sibship$Pos_from_MeanDistsibship, alternative = "less")

```
But now let's do it with the median.
```{r}
t.test(YoY_Females_from_sibship$Pos_from_MedianDistsibship, YoY_Males_from_sibship$Pos_from_MedianDistsibship, alternative = "less")
```


##### Seven) Try a lm() model

Now let's try some modelling maybe ! 

```{r}
Dispersal_model <- lm(data = Filtered_Fullsibs_V5, Pos_from_MeanDistsibship ~ Sex * hapstr)
summary(Dispersal_model)
```
 

 
## M) Correlograms in all 1809 fish, grouped by Omy5

Of course there is some redundancy between the multiple sections here in the spatial analysis section, but this is to maximise reproducibility. So more long but easier to check.

### 1) Take 1809 fish genotype and distance data

Distance data : Distance_Ultimate_key_V2_distanceOnly 
Genotype data : For_Colony_Sibship_Noduplicates (For all the 1995 fish MINUS THE DUPLICATES !)

```{r}
Distances_1809_fish  <- Distance_Ultimate_key_V2_distanceOnly %>% 
  filter(., Sample_ID %in% For_Colony_Sibship_Noduplicates$Sample_ID) %>% 
  arrange(., Sample_ID)
nrow(Distances_1809_fish)
```


### 2) Prepare 1809 genotypes


https://r-forge.r-project.org/scm/viewvc.php/*checkout*/www/files/tutorial.pdf?revision=150&root=adegenet&pathrev=462  

```{r}
head(For_Colony_Sibship_Noduplicates)
```
 



### 3) Add leading zeros to get a  three digits format ! 

```{r}
genotypes_1809_fish_two_digits <- data.frame(lapply(For_Colony_Sibship_Noduplicates, function(x){
  gsub("^([0-9]){1}$", "0\\1", x) 
  }))
genotypes_1809_fish_three_digits <- data.frame(lapply(genotypes_1809_fish_two_digits, function(x){
  gsub("^([0-9]{2})$", "0\\1", x) 
  }))

colnames(genotypes_1809_fish_three_digits) <- gsub("^tag_id_([0-9]{1,6}.[0-9]{1})$", "\\1", colnames(genotypes_1809_fish_three_digits))
colnames(genotypes_1809_fish_three_digits) <- gsub("^([0-9]{1,6}).([0-9]{1})$", "\\1_\\2", colnames(genotypes_1809_fish_three_digits))
```

 A couple of checks about missing data and identical rows ...

```{r}
genotypes_1809_fish_three_digits_HowManyNA <- genotypes_1809_fish_three_digits %>% 
  mutate( NAs= rowSums(is.na(genotypes_1809_fish_three_digits)))


nrow(genotypes_1809_fish_three_digits_HowManyNA)
Check_identical_1809_fish <- genotypes_1809_fish_three_digits_HowManyNA %>% 
  select(., -c(NAs, Sample_ID)) %>% 
  distinct()
nrow(Check_identical_1809_fish) == nrow(genotypes_1809_fish_three_digits_HowManyNA)
```
If True you have no identical rows

### 4) Replace NAs with "NA"
```{r}
i <- sapply(genotypes_1809_fish_three_digits, is.factor) # Identify all factor variables in your data
genotypes_1809_fish_three_digits[i] <- lapply(genotypes_1809_fish_three_digits[i], as.character) # Convert factors to character variables
genotypes_1809_fish_three_digits[is.na(genotypes_1809_fish_three_digits)] <- "na" # Replace NAs with "NA", as shown in Example 1
genotypes_1809_fish_three_digits[i] <- lapply(genotypes_1809_fish_three_digits[i], as.factor) # Convert character columns back to factors
```


### 5) From Two to One column per locus 

Merge columns together for conversion to genind
We need the one row/loci format ! 
```{r}
genotypes_1809_fish_3digs_oneColformat <- genotypes_1809_fish_three_digits %>% 
  gather(., Loci, Allele, -Sample_ID, na.rm = F) %>% 
  mutate(., Unified_Loci = gsub( x = Loci, "^([0-9]{1,6}).[0-9]{1}$", "\\1" )) %>%
  ungroup()  %>% 
  group_by(., Sample_ID, Unified_Loci) %>% 
  mutate(., two_alleles = paste0(Allele, collapse = "/")) %>% 
  select(., -c(Loci, Allele)) %>% 
  group_by(., Sample_ID) %>% 
  distinct(., Unified_Loci, .keep_all = T ) %>% 
  spread(., key = Unified_Loci, value = two_alleles) %>% 
  ungroup()

```

 
### 6) Individual-based correlogram

Here just make the rownames be Sample_ID
And we use the table in one-column per locus format 


          !BUT HERE WE SPLIT THE 1809 FISH BY OMY5 !


Create lists per Omy5.
```{r}

All1809fish_AAAA_list <- Minimeta_V8_noDup %>% 
  filter(., hapstr == "AAAA")

All1809fish_HHHH_list <- Minimeta_V8_noDup %>% 
  filter(., hapstr == "HHHH")

All1809fish_RRRR_list <- Minimeta_V8_noDup %>% 
  filter(., hapstr == "RRRR")

nrow(All1809fish_AAAA_list)
nrow(All1809fish_HHHH_list)
nrow(All1809fish_RRRR_list)
```



*AAAA*
```{r}
# Remove "pop" (i.e sibship information)    
genotypes_All_1809_fish_three_digits_noPop_AAAA <- genotypes_1809_fish_3digs_oneColformat %>% 
  filter(., Sample_ID %in% All1809fish_AAAA_list$Sample_ID) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID" ) 
 

genind_GenoAlls_1809_fish_distance_noPop_AAAA <- df2genind(X = genotypes_All_1809_fish_three_digits_noPop_AAAA , sep = "/" , NA.char = "NA")

genind_GenoAlls_1809_fish_distance_noPop_AAAA
``` 
*HHHH*
```{r}
# Remove "pop" (i.e sibship information)    
genotypes_All_1809_fish_three_digits_noPop_HHHH <- genotypes_1809_fish_3digs_oneColformat %>% 
  filter(., Sample_ID %in% All1809fish_HHHH_list$Sample_ID) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID" ) 
 

genind_GenoAlls_1809_fish_distance_noPop_HHHH <- df2genind(X = genotypes_All_1809_fish_three_digits_noPop_HHHH , sep = "/" , NA.char = "NA")

genind_GenoAlls_1809_fish_distance_noPop_HHHH
```

*RRRR*
```{r}
# Remove "pop" (i.e sibship information)    
genotypes_All_1809_fish_three_digits_noPop_RRRR <- genotypes_1809_fish_3digs_oneColformat %>% 
  filter(., Sample_ID %in% All1809fish_RRRR_list$Sample_ID) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID" ) 
 

genind_GenoAlls_1809_fish_distance_noPop_RRRR <- df2genind(X = genotypes_All_1809_fish_three_digits_noPop_RRRR , sep = "/" , NA.char = "NA")

genind_GenoAlls_1809_fish_distance_noPop_RRRR
```

Prepare the distance info for all the 1809_fish


```{r}
All_minidistance <- Minidistance_V1 %>% 
  filter(., Sample_ID %in% Minimeta_V8_noDup$Sample_ID) %>% 
  arrange(., Sample_ID)
```

 # No need to conver to genpop here aswe use poppr's function


Create distance matrixes 
 We use poppr here as it has functions to calculate distance based on individuals and not populations! 
You can change from Edward's to another but Edward is Euclidian so it's cool. 
And you have to to it on the genind object directly
*AAAA*
```{r}
# We have a problem here because I need to define populations ! 
Edwards_1809_fish_Indiv_genetic_distance_noPop_AAAA <- edwards.dist(genind_GenoAlls_1809_fish_distance_noPop_AAAA)
# summary(Edwards_1809_fish_Indiv_genetic_distance_noPop)
head(Edwards_1809_fish_Indiv_genetic_distance_noPop_AAAA)
length(Edwards_1809_fish_Indiv_genetic_distance_noPop_AAAA)

# Number of NAs
nanana1809_fishAAAA <- sum(which(is.na(Edwards_1809_fish_Indiv_genetic_distance_noPop_AAAA)))
nonanona1809_fishAAAA <- sum(which(!is.na(Edwards_1809_fish_Indiv_genetic_distance_noPop_AAAA)))

nanana1809_fishAAAA / (nanana1809_fishAAAA + nonanona1809_fishAAAA) *100
```
 *HHHH*
```{r}
# We have a problem here because I need to define populations ! 
Edwards_1809_fish_Indiv_genetic_distance_noPop_HHHH <- edwards.dist(genind_GenoAlls_1809_fish_distance_noPop_HHHH)
# summary(Edwards_1809_fish_Indiv_genetic_distance_noPop)
head(Edwards_1809_fish_Indiv_genetic_distance_noPop_HHHH)
length(Edwards_1809_fish_Indiv_genetic_distance_noPop_HHHH)

# Number of NAs
nanana1809_fishHHHH <- sum(which(is.na(Edwards_1809_fish_Indiv_genetic_distance_noPop_HHHH)))
nonanona1809_fishHHHH <- sum(which(!is.na(Edwards_1809_fish_Indiv_genetic_distance_noPop_HHHH)))

nananaHHHH / (nanana1809_fishHHHH + nonanona1809_fishHHHH) *100
```

*RRRR*
```{r}
# We have a problem here because I need to define populations ! 
Edwards_1809_fish_Indiv_genetic_distance_noPop_RRRR <- edwards.dist(genind_GenoAlls_1809_fish_distance_noPop_RRRR)
# summary(Edwards_1809_fish_Indiv_genetic_distance_noPop)
head(Edwards_1809_fish_Indiv_genetic_distance_noPop_RRRR)
length(Edwards_1809_fish_Indiv_genetic_distance_noPop_RRRR)

nanana1809_fishRRRR <- sum(which(is.na(Edwards_1809_fish_Indiv_genetic_distance_noPop_RRRR)))
nonanona1809_fishRRRR <- sum(which(!is.na(Edwards_1809_fish_Indiv_genetic_distance_noPop_RRRR)))

nanana1809_fishRRRR / (nanana1809_fishRRRR + nonanona1809_fishRRRR) *100
```
 


We compute a "y" coordinate made of zeros, so that a matrix can be done.
*AAAA*
```{r}
All_minidistance_y0_AAAA <- All_minidistance %>% 
  filter(., Sample_ID %in% All1809fish_AAAA_list$Sample_ID) %>%
  arrange(., Sample_ID) %>% 
  mutate( pseudo_y = 0) %>% 
  column_to_rownames(., "Sample_ID")


dist_All_1809_fish_Indiv_geographic_distance_AAAA <- dist(All_minidistance_y0_AAAA, "euclidean")

head(dist_All_1809_fish_Indiv_geographic_distance_AAAA)
```
*HHHH*
```{r}
All_minidistance_y0_HHHH <- All_minidistance %>% 
  filter(., Sample_ID %in% All1809fish_HHHH_list$Sample_ID) %>%
  arrange(., Sample_ID) %>% 
  mutate( pseudo_y = 0) %>% 
  column_to_rownames(., "Sample_ID")


dist_All_1809_fish_Indiv_geographic_distance_HHHH <- dist(All_minidistance_y0_HHHH, "euclidean")

head(dist_All_1809_fish_Indiv_geographic_distance_HHHH)
```

*RRRR*
```{r}
All_minidistance_y0_RRRR <- All_minidistance %>% 
  filter(., Sample_ID %in% All1809fish_RRRR_list$Sample_ID) %>%
  arrange(., Sample_ID) %>% 
  mutate( pseudo_y = 0) %>% 
  column_to_rownames(., "Sample_ID")


dist_All_1809_fish_Indiv_geographic_distance_RRRR <- dist(All_minidistance_y0_RRRR, "euclidean")

head(dist_All_1809_fish_Indiv_geographic_distance_RRRR)
```

And , finally, the mantel correlograms ! 
 
*AAAA* 
```{r}
MantimantoCorr_1809_fish_AAAA <- mgram(species.d = Edwards_1809_fish_Indiv_genetic_distance_noPop_AAAA , space.d =  dist_All_1809_fish_Indiv_geographic_distance_AAAA, nperm = 999, cboot = 0.95, nboot = 999, nclass = 18)
MantimantoCorr_1809_fish_AAAA
plot(MantimantoCorr_1809_fish_AAAA)
```

*HHHH*
```{r}
MantimantoCorr_1809_fish_HHHH <- mgram(species.d = Edwards_1809_fish_Indiv_genetic_distance_noPop_HHHH , space.d =  dist_All_1809_fish_Indiv_geographic_distance_HHHH, nperm = 999, cboot = 0.95, nboot = 999, nclass = 18)
MantimantoCorr_1809_fish_HHHH
plot(MantimantoCorr_1809_fish_HHHH)
```

*RRRR*
```{r}
MantimantoCorr_1809_fish_RRRR <- mgram(species.d = Edwards_1809_fish_Indiv_genetic_distance_noPop_RRRR , space.d =  dist_All_1809_fish_Indiv_geographic_distance_RRRR, nperm = 999, cboot = 0.95, nboot = 999, nclass = 18)
MantimantoCorr_1809_fish_RRRR
plot(MantimantoCorr_1809_fish_RRRR)
```

Remember that in principle, a significant Mantel test or a correlogram pattern only indicates that genetic variability is structured in geographic space. 



 
## N) Correlograms combined to use for plotting

We want a nice plot with different correlograms combined ! 

So let's combine those :
MantimantoCorr_Allsibs  --> Based on individuals , but only the ones from sibships of size > 2 
MantimantoCorr_YoYsibsNotgrouped --> Based on individuals,but only the ones from YOY sibships of size > 2
MantimantoCorr_1809 --> Based on all the 1809 individuals
MantimantoCorr_Allsibs_AAAA --> It is in the name
MantimantoCorr_Allsibs_RRRR
MantimantoCorr_Allsibs_HHHH
MantimantoCorr_1809_fish_AAAA --> Same as above but with the 1809 fish, not only the ones in sibships
MantimantoCorr_1809_fish_HHHH
MantimantoCorr_1809_fish_RRRR

```{r}

CombinMgram_1809 <- as.data.frame(MantimantoCorr_1809[["mgram"]]) %>% 
  mutate(., Origin = "All_individuals") %>% 
  mutate(., hapstr = "diverse") %>% 
  mutate(., dataset_name = "MantimantoCorr_1809")

CombinMgram_YoYsibsNotgrouped <- as.data.frame(MantimantoCorr_YoYsibsNotgrouped[["mgram"]]) %>% 
  mutate(., Origin = "YoY_sibs_not_grouped") %>% 
  mutate(., hapstr = "diverse")%>% 
  mutate(., dataset_name = "MantimantoCorr_YoYsibsNotgrouped")

CombinMgram_Allsibs <- as.data.frame(MantimantoCorr_Allsibs[["mgram"]]) %>% 
  mutate(., Origin = "Allsibs") %>% 
  mutate(., hapstr = "diverse")%>% 
  mutate(., dataset_name = "MantimantoCorr_Allsibs")

CombinMgram_Allsibs_AAAA <- as.data.frame(MantimantoCorr_Allsibs_AAAA[["mgram"]]) %>% 
  mutate(., Origin = "Allsibs") %>% 
  mutate(., hapstr = "AAAA")%>% 
  mutate(., dataset_name = "MantimantoCorr_Allsibs_AAAA")

CombinMgram_Allsibs_RRRR <- as.data.frame(MantimantoCorr_Allsibs_RRRR[["mgram"]]) %>% 
  mutate(., Origin = "Allsibs") %>% 
  mutate(., hapstr = "RRRR")%>% 
  mutate(., dataset_name = "MantimantoCorr_Allsibs_RRRR")

CombinMgram_Allsibs_HHHH <- as.data.frame(MantimantoCorr_Allsibs_HHHH[["mgram"]]) %>% 
  mutate(., Origin = "Allsibs") %>% 
  mutate(., hapstr = "HHHH")%>% 
  mutate(., dataset_name = "MantimantoCorr_Allsibs_HHHH")

CombinMgram_1809_fish_AAAA <- as.data.frame(MantimantoCorr_1809_fish_AAAA[["mgram"]]) %>% 
  mutate(., Origin = "All_individuals") %>% 
  mutate(., hapstr = "AAAA")%>% 
  mutate(., dataset_name = "MantimantoCorr_1809_fish_AAAA")

CombinMgram_1809_fish_HHHH <- as.data.frame(MantimantoCorr_1809_fish_HHHH[["mgram"]]) %>% 
  mutate(., Origin = "All_individuals") %>% 
  mutate(., hapstr = "HHHH")%>% 
  mutate(., dataset_name = "MantimantoCorr_1809_fish_HHHH")

CombinMgram_1809_fish_RRRR <- as.data.frame(MantimantoCorr_1809_fish_RRRR[["mgram"]]) %>% 
  mutate(., Origin = "All_individuals") %>% 
  mutate(., hapstr = "RRRR")%>% 
  mutate(., dataset_name = "MantimantoCorr_1809_fish_RRRR")

MEGA_combinogram <- rbind(CombinMgram_1809, CombinMgram_YoYsibsNotgrouped, CombinMgram_Allsibs, CombinMgram_Allsibs_AAAA, CombinMgram_Allsibs_HHHH, CombinMgram_Allsibs_RRRR, CombinMgram_1809_fish_AAAA, CombinMgram_1809_fish_HHHH, CombinMgram_1809_fish_RRRR) %>% 
  mutate(., significant = if_else(condition = pval < 0.05, "yes", "no"))

```
Now let's plot it !! 


*Mantel correlograms of individuals identified in full-sibling groups, grouped by Omy5 inversion type*

```{r}

MEGA_combinogram %>%
 filter(., !hapstr == "diverse") %>% 
 filter(., Origin == "Allsibs") %>% 
 ggplot() +
 aes(x = lag, y = mantelr, colour = hapstr) +
 scale_color_manual(values = c("#00AFBB", "#E7B800", "#FC4E07")) +
 geom_point( size = 4, aes( shape = significant )) +
 scale_shape_manual(values=c(1, 19))+
 labs(x = "Distance between individuals in the stream", y = "Mantel correlation coefficient", title = "Mantel correlograms of individuals identified in full-sibling groups, \n                      grouped by Omy5 inversion type", colour = "      Omy5 \ninversion type", shape = "  Significance of \nmantel correlation") +
 geom_line() +
 theme_minimal()
```
 
*Mantel correlograms of individuals IN ALL 1809 fish, grouped by Omy5 inversion type*

```{r}
Megacombinogram_All1809_inds_plot <- MEGA_combinogram %>%
 filter(., dataset_name == "MantimantoCorr_1809_fish_AAAA" | dataset_name == "MantimantoCorr_1809_fish_HHHH" | dataset_name == "MantimantoCorr_1809_fish_RRRR") %>% 
 ggplot() +
 aes(x = lag, y = mantelr, colour = hapstr) +
 scale_color_manual(values = c("#00AFBB", "#E7B800", "#FC4E07"), labels = c("Anadromous (A)", 
                                   "Heterozygous (H)", 
                                   "Resident (R)")) +
 geom_point( size = 4, aes( shape = significant )) +
 scale_shape_manual(values=c(1, 19), labels = c("Not significant", "Signficant"))+
 labs(x = "Distance between individuals in the stream (m)", y = "Mantel correlation coefficient",  colour = "      Omy5 \ninversion type", shape = "  Significance of \nmantel correlation \n       (CI 95%)") +
 geom_line() +
 theme_minimal()

plot(Megacombinogram_All1809_inds_plot)

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/Figure4.png", plot = Megacombinogram_All1809_inds_plot, dpi = 300, width = 10)

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/Figure4.svg", plot = Megacombinogram_All1809_inds_plot, dpi = 300, width = 10)
``` 


# V) Answer Paper Questions now ! 
 
## A) Fullsibs families across YOY cohorts. 
 
> Hypothesis : Predict that full sib families will not be found across YOY cohorts. We may find sibling relationships among the resident fish, and their distributions in the stream could be interesting.

This was done already in section III) D) of script 7. 

We have two datasets for YoY sibships: 
UBC_run1_SibSize_META_Result2_YOYs (per individual)
Mini_Summary_per_Sibgroup_YOYs (Summary per sibship)

```{r}
Mini_Summary_per_Sibgroup_YOYs %>% 
  count(., YOYsibs_AllsameYear)
```
They are all ofrom the same year, except in two groups, but it's only because they have duplicated samples that have been sampled as YOYs before :D 

## B) Large multiple mating resident males

>Hypothesis : Some large resident males will sire juveniles across multiple cohorts.

For now we will use the dataset : SibsAndParentage_V3 created in section III) of this script. 
It has parentage data and sibship data, plus some nice stuff. 

```{r}
Multiple_mating_Dads <-  SibsAndParentage_V3 %>% 
  filter(., Reprod_events_Dad > 1)  %>% 
  filter(., Number_of_kids_Dad > 2)

TocheckMultiple_mating_Dads <- Multiple_mating_Dads %>% 
  distinct(., Dad, .keep_all =  T)
```

How many dads mated multiple times ? 
```{r}
Multiple_mating_Dads %>% ungroup() %>% count(n_distinct(Dad))
```
How many % of total kids is that ? 
```{r}
95/374*100
```

What were their haplotypes?
```{r}
Multiple_mating_Dads %>% ungroup() %>% distinct(Dad, .keep_all = T) %>% select(Dad, DadOmy5)
```

For how many assignments is Mom missing ? 
```{r}
Multiple_mating_Dads %>% ungroup() %>% count(is.na(Mom))
```
62.10526 %


What is the % of HETEROZYGOUS in the kids of multiple mating dads? 
```{r}
Multiple_mating_Dads %>% ungroup() %>% count(., hapstr_kid == "HHHH")
```
21.27% !! (20/94*100)

WHEN THE MOM IS ABSENT: What is the % of HETEROZYGOUS in kids of multiple mating dads? 
```{r}
Multiple_mating_Dads %>% ungroup() %>% filter(., is.na(Mom)) %>% count(., hapstr_kid == "HHHH")
```


```{r}
Sizes_of_Multiple_mating_Dads <- Multiple_mating_Dads %>% 
    filter(., Reprod_events_Dad >1) %>% 
    distinct(., Dad, .keep_all = T) %>% 
    select(., Dadsize)

Sizes_of_One_mating_Dads <- SibsAndParentage_V3 %>% 
  filter(., Reprod_events_Dad == 1) %>%
  distinct(., Dad , .keep_all = T) %>% 
  select(., Dadsize)

shapiro.test(Multiple_mating_Dads$Dadsize)

t.test(Sizes_of_Multiple_mating_Dads, Sizes_of_One_mating_Dads, alternative = "greater", var.equal = FALSE)
```
Maybe there is a correlation between number of reproductive events and length? 
```{r}
CorrReproEventsLENGTH_dads <- SibsAndParentage_V3 %>% 
  distinct(., Dad , .keep_all = T) %>% 
  filter(., !is.na(Dad))

cor.test(CorrReproEventsLENGTH_dads$Dadsize, CorrReproEventsLENGTH_dads$Reprod_events_Dad, alternative = "greater", method = "pearson")

cor.test(CorrReproEventsLENGTH_dads$Dadsize, CorrReproEventsLENGTH_dads$Number_of_kids_Dad, alternative = "greater", method = "pearson")
```
## C) Large multiple mating resident females

> Test it for Females :

```{r}
Multiple_mating_Moms <-  SibsAndParentage_V3 %>% 
  filter(., Reprod_events_Mom > 1) 

TocheckMultiple_mating_Moms <- Multiple_mating_Moms %>% 
  distinct(., Mom, .keep_all =  T)
```

How many Moms mated multiple times ? 
```{r}
Multiple_mating_Moms %>% count(n_distinct(Mom))
```
What were their haplotypes? 
```{r}
Multiple_mating_Moms %>% ungroup() %>% distinct(Mom, .keep_all = T) %>% select(Mom, MomOmy5)
```

For how many assignments is Dad missing ? 
```{r}
Multiple_mating_Moms %>% ungroup() %>% count(is.na(Dad))
```

What is the % of HETEROZYGOUS in the kids of multiple mating Moms? 
```{r}
Multiple_mating_Moms %>% ungroup() %>% count(., hapstr_kid == "HHHH")
```

WHEN DAD IS ABSENT: What is the % of HETEROZYGOUS in the kids of multiple mating Moms? 
```{r}
Multiple_mating_Moms %>% ungroup() %>%  filter(., is.na(Dad)) %>% count(., hapstr_kid == "HHHH")
```

```{r}

Sizes_of_Multiple_mating_Moms <- Multiple_mating_Moms %>% 
    filter(., Reprod_events_Mom >1) %>% 
    distinct(., Mom, .keep_all = T) %>% 
    select(., Momsize)

Sizes_of_One_mating_Moms <- SibsAndParentage_V3 %>% 
  distinct(., Mom , .keep_all = T) %>% 
  select(., Momsize)
  
shapiro.test(Multiple_mating_Moms$Momsize)

t.test(Sizes_of_Multiple_mating_Moms, Sizes_of_One_mating_Moms, alternative = "greater", var.equal = FALSE)
```
Maybe there is a correlation between number of reproductive events and length? 
```{r}
CorrReproEventsLENGTH_moms <- SibsAndParentage_V3 %>% 
  distinct(., Mom , .keep_all = T) %>% 
  filter(., !is.na(Mom))

cor.test(CorrReproEventsLENGTH$Momsize, CorrReproEventsLENGTH$Reprod_events_Mom, alternative = "greater", method = "pearson")

cor.test(CorrReproEventsLENGTH$Momsize, CorrReproEventsLENGTH$Number_of_kids_Mom, alternative = "greater", method = "pearson")
```

## D) What about Single-mating parents ?

### 1) Omy5 : Not conclusive
What are the % of hapstr in SINGLE mating parents? 
```{r}
SINGLE_mating_Dads <-  SibsAndParentage_V3 %>% 
  filter(., Reprod_events_Dad == 1)  %>% 
  distinct(., Dad, .keep_all = T)

SINGLE_mating_Moms <-  SibsAndParentage_V3 %>% 
  filter(., Reprod_events_Mom == 1)  %>% 
  distinct(., Mom, .keep_all = T)

# Now it is cool you have lists of single mating parents but let's take just their haplotype and summarise


nrow(SINGLE_mating_Dads)
nrow(SINGLE_mating_Moms)
# Below 
 nrow(SINGLE_mating_Moms) + nrow(SINGLE_mating_Dads) 
 
```
But what about the Omy5 numbers in single mating parents then ?
```{r}
SINGLE_mating_Dads %>%  count(., DadOmy5)
```
```{r}
SINGLE_mating_Moms %>%  count(., MomOmy5)
```
MMMhhh ... not really sure about how to think about all this ...




## E) Is our parentage dataset multigenerational?

By that I mean: Is there parents that you find in offsprings? 

Let's create datasets for different generations !

Ok I have no clue of how to represent the multigeneration thing so fuck it for now.


    I FAILED TO USE KINSHIP       


```{r}
library(kinship2)

SibsAndParentage_V3_No_SP <- SibsAndParentage_V3 %>% 
 # filter(., !TRIOorSP == "Single_Pair") %>% 
  select(., c(kid, Mom, Dad, Sex_kid, FamIndex_per_year))

Famid <- SibsAndParentage_V3_No_SP %>% 
  select(., kid, FamIndex_per_year) %>% 
  rename(., id= "kid")

ForKinship <- with(SibsAndParentage_V3_No_SP, fixParents(id=kid, dadid=Dad, momid=Mom, sex=Sex_kid ))


ForKinship_V2 <- ForKinship %>% 
  mutate(., famid = 1)
  
  
   group_by(., momid, dadid) %>%
 { mutate(ungroup(.), famid = group_indices(.)) } %>% 
 select(., c(famid, everything())) 
  
  
  
  left_join(., Famid, by = "id")

pedigrou <- with(ForKinship_V2, pedigree(id=id, dadid=dadid, momid=momid, sex=sex, famid=famid))


with(SibsAndParentage_V3_No_SP, pedigree(id=kid, dadid=Dad, momid=Mom, sex=Sex_kid, famid=FamIndex_per_year))

Multigenerations_V1 <- pedigree(id = (SibsAndParentage_V3_No_SP$kid), dadid = (SibsAndParentage_V3_No_SP$Dad), momid = (SibsAndParentage_V3_No_SP$Mom), sex = (SibsAndParentage_V3_No_SP$Sex_kid), famid = (SibsAndParentage_V3_No_SP$FamIndex_per_year) )

```

```{r}
data(sample.ped)
sample.ped2 = subset(sample.ped, ped == 2)
id1 = c(210, 212)
id2 = c(211, 213)
r = c(1, 2)
rm = cbind(id1, id2, r)

pedAll <- pedigree(
        id=sample.ped$id, 
        dadid=sample.ped$father, 
        momid=sample.ped$mother,
        sex=sample.ped$sex, 
        famid=sample.ped$ped)
print(pedAll)

plot(pedAll['1'])
```


### 1) YoY as anadromous mothers ? 


Here let's check if we caught YoYs which became anadromous mothers afterwards. 

The dataset to look at is : SibsAndParentage_V3 

```{r}
AnadrYOYmoms <- SibsAndParentage_V3 %>% 
  filter(., MomOmy5 == "AAAA" )

```

So no, we didn't sampled YoYs which returned as anadromous moms after. 


## F) Effects of drought

 So after Devon's reply to my first report, we may have new ways of exploring that, we will see! 

    1) Relatively more residents caught during droughts
    2) Family size change during drought
    3) Number of fish caught during drought  --> Maybe a linear model later. 
    4) 

  BELOW WE ASSUME THAT THE DROUGHT IS 2012 - 2016 ! 
    
    
###♥ 1) Relatively more residents caught during droughts

Below we create a nice dataset that is composed of all the Omy5 genotypes data + plenty of metadata, but no parentage data. We will reuse the dataset later but for now we use it to answer the question: Did we find more residents during the drought? 

#### In all fish
> Prepare and test 

```{r}
Drought_fish <- Minimeta_V8_noDup %>% 
  filter(., !Coll_year > 2016) %>% 
  filter(., !Coll_year < 2012) %>% 
  filter(., !is.na(hapstr))

Non_drought_fish <- Minimeta_V8_noDup %>% 
  filter(., Coll_year > 2016 | Coll_year < 2012) %>% 
  filter(., !is.na(hapstr))

# Proportion of Anadromous type in drought 
proportion_AAAA_drougth <- Drought_fish %>% filter(., hapstr == "AAAA") %>% nrow()
# Proportion of Anadromous type in NON drought 
proportion_AAAA_NO_drougth <- Non_drought_fish %>% filter(., hapstr == "AAAA") %>% nrow()

# Total number of fish in drought and Non-drought 
Totfish_drought <- nrow(Drought_fish)
Totfish_NO_drought <- nrow(Non_drought_fish)

Drought_fish %>% count(., hapstr)
Non_drought_fish %>% count(., hapstr)

```

```{r}
Test_AAAA_Drought_vs_NOdrought <- prop.test(x = c(proportion_AAAA_drougth, proportion_AAAA_NO_drougth) , n = c(Totfish_drought, Totfish_NO_drought), alternative = "less")
Test_AAAA_Drought_vs_NOdrought
```
So yes, we have less Anadromous caught during the drought ! 

#### In YoYs only

Do we have the same effect in YoYs? 

> Prepare and test 

```{r}
Drought_fish_YOY <- Minimeta_V8_noDup %>% 
  filter(., !Coll_year > 2016) %>% 
  filter(., !Coll_year < 2012) %>% 
  filter(., !is.na(hapstr)) %>% 
  filter(., LENGTH <= 95)        # Select YoYs only

Non_drought_fish_YOY <- Minimeta_V8_noDup %>% 
  filter(., Coll_year > 2016 | Coll_year < 2012) %>% 
  filter(., !is.na(hapstr))  %>% 
  filter(., LENGTH <= 95)        # Select YoYs only

# Proportion of Anadromous type in drought 
proportion_AAAA_drougth_YOY <- Drought_fish_YOY %>% filter(., hapstr == "AAAA") %>% nrow()
# Proportion of Anadromous type in NON drought 
proportion_AAAA_NO_drougth_YOY <- Non_drought_fish_YOY %>% filter(., hapstr == "AAAA") %>% nrow()

# Total number of fish in drought and Non-drought 
Totfish_drought_YOY <- nrow(Drought_fish_YOY)
Totfish_NO_drought_YOY <- nrow(Non_drought_fish_YOY)

Drought_fish_YOY %>% count(., hapstr)
Non_drought_fish_YOY %>% count(., hapstr)

```

```{r}
Test_AAAA_Drought_vs_NOdrought_YOY <- prop.test(x = c(proportion_AAAA_drougth_YOY, proportion_AAAA_NO_drougth_YOY) , n = c(Totfish_drought_YOY, Totfish_NO_drought_YOY), alternative = "less")
Test_AAAA_Drought_vs_NOdrought_YOY
```
So now we find the same pattern ! 

With YOY threshold 65 mm we used to have :
So for YoYs the pattern is the opposite, we had proportionally more YoYs with AAAA alleles during the drought than outside the drought. Maybe it's because of our sampling also, I'm not sure.


###♥ 2) Family size change during drought
      
      So the thing is it would be completely biased by the distribution of fish per year in our dataset. 
      In years for which we have more fish we increase the probabilities of detecting offsprings and parents. 
      Maybe a way around that would be to subset ~100 (That's all we have for 2016) random fish per year several times and do a parentage on them but the results would be very poor. Any idea ? 
      
So first check if family size is related to number of fish caught per year.       
```{r}
Family_sizes <- SibsAndParentage_V3 %>% 
  ungroup() %>% 
  distinct(., FamIndex_per_year, .keep_all = T)  %>% 
  select(.,FamIndex_per_year, FamilySize_SPtrio , Family_minYear, TRIOorSP) %>% 
  mutate(., Drought_family = ifelse(Family_minYear %in% ))


FamSizes_temporal <- ggplot(Family_sizes) +
 aes(x = Family_minYear, y = FamilySize_SPtrio) +
 geom_boxplot(fill = "#0c4c8a") +
 labs(x = "Collection year of offsprings", y = "Family size") +
 theme_minimal()

ggplot(Family_sizes) +
 aes(x = Family_minYear, y = FamilySize_SPtrio) +
 geom_boxplot(fill = "#0c4c8a") +
 labs(x = "Collection year of offsprings", y = "Family size") +
 theme_minimal()

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/FigureS4.png", plot = FamSizes_temporal, dpi = 300, width = 10)

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/FigureS4.svg", plot = FamSizes_temporal, dpi = 300, width = 10)
```

```{r}
# Check number of fish caught each year
Numfish_per_year <- Minimeta_V8_noDup %>% 
  group_by(., Coll_year) %>% 
  add_count() %>% 
  select(., Coll_year, n) %>% 
  distinct(., Coll_year, .keep_all = T) %>% 
  rename(., numfish = "n")

# Average family size per year
FamilySizes_averaged_by_year <- SibsAndParentage_V3 %>% 
  ungroup() %>% 
  distinct(., FamIndex_per_year, .keep_all = T)  %>% 
  select(.,FamIndex_per_year, FamilySize_SPtrio , Family_minYear, TRIOorSP) %>% 
  group_by(., Family_minYear) %>%  # Group by year 
  mutate(., AverFamilySize = mean(FamilySize_SPtrio)) %>% 
  distinct(., Family_minYear, .keep_all = T) %>% 
  select(., Family_minYear, AverFamilySize) %>% 
  rename(., Coll_year = "Family_minYear") %>% 
  left_join(., Numfish_per_year, by = "Coll_year" )
  

shapiro.test(FamilySizes_averaged_by_year$numfish)
shapiro.test(FamilySizes_averaged_by_year$AverFamilySize)

cor.test(x = FamilySizes_averaged_by_year$numfish, y = FamilySizes_averaged_by_year$AverFamilySize, alternative = "two.sided", method = "spearman")
 

```
There is a very strong correlation between the number of fish caught and the size of the families ! 
 
###♥ 3) Sibship size change during drought
 
```{r}
Sibsizes_temporal <- Filtered_Fullsibs %>% 
  ungroup() %>% 
  distinct(., FullSibshipIndex, .keep_all = T) %>% 
  select(., -c(YearYOYclone, YOY, Sex, Coll_year, Coll_month, Coll_day, LENGTH, WEIGHT, AGE, Indiv, hapstr, HasYOYclone, HasRemovedClone))

Sibsizes_temporal_plot <- ggplot(Sibsizes_temporal) +
 aes(x = Sibship_minYear, y = Sibsize) +
 geom_boxplot(fill = "#0c4c8a") +
 labs(x = "Approxmate birth year of full sibship group", y = "Sibship size") +
 theme_minimal()

Sibsizes_temporal_plot

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/FigureS3.png", plot = Sibsizes_temporal_plot, dpi = 300, width = 10)

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/FigureS3.svg", plot = Sibsizes_temporal_plot, dpi = 300, width = 10)
```


      
### ♥ 4) Number of fish caught during drought  
      
      Well, we just need to relate that to the drought data. I mean it is pretty obvious already on the plot of fish caught per year, assuming that the sampling campaigns were done with the same sampling effort. 
      
      But let's test it anyway:
```{r}
Fish_caught_during_drought <- Drought_fish %>% 
  group_by(., Coll_year) %>% 
  add_count() %>% 
  distinct(Coll_year, .keep_all = T) %>% 
  select(., Coll_year, n)

Fish_caught_beforeANDafter_drought <- Non_drought_fish %>% 
  group_by(., Coll_year) %>% 
  add_count() %>% 
  distinct(Coll_year, .keep_all = T) %>% 
  select(., Coll_year, n)

t.test(x = Fish_caught_during_drought$n, y = Fish_caught_beforeANDafter_drought$n, alternative = "less", paired = F)

```
# PROBLEM HERE
      
The thing is, there is no significant difference between the mean of fish caught during VS outside the drought period. However, it is clear on the data that the number of fish caught decreases as the drought goes on. How should we test this ?



## E) Summary statistics


### 1) Prepare genotype

Reduce the 1995 fish dataset to non duplicated only and change the indiv.ID to Sample_ID format. 
```{r}
genotypes_AllNonDup_fish <- gtseq7.12_ubc_hap2col_current_vcf.txt %>% 
  left_join(., Key_BC_V1, by = "indiv.ID") %>% 
  filter(., Sample_ID %in% Distances_1809_fish$Sample_ID) %>%  # To make sure you remove duplicates.
  select(., - c(indiv.ID, group)) 
```

### 3) Add leading zeros to get a  three digits format ! 

```{r}
genotypes_AllNonDup_fish_two_digits <- data.frame(lapply(genotypes_AllNonDup_fish, function(x){
  gsub("^([0-9]){1}$", "0\\1", x) 
  }))
genotypes_AllNonDup_fish_three_digits <- data.frame(lapply(genotypes_AllNonDup_fish_two_digits, function(x){
  gsub("^([0-9]{2})$", "0\\1", x) 
  }))

colnames(genotypes_AllNonDup_fish_three_digits) <- gsub("^tag_id_([0-9]{1,6}.[0-9]{1})$", "\\1", colnames(genotypes_AllNonDup_fish_three_digits))
colnames(genotypes_AllNonDup_fish_three_digits) <- gsub("^([0-9]{1,6}).([0-9]{1})$", "\\1_\\2", colnames(genotypes_AllNonDup_fish_three_digits))

```

 A couple of checks about missing data and identical rows ... 

```{r}
genotypes_AllNonDup_fish_three_digits_HowManyNA <- genotypes_AllNonDup_fish_three_digits %>% 
  mutate( NAs= rowSums(is.na(genotypes_AllNonDup_fish_three_digits)))


nrow(genotypes_AllNonDup_fish_three_digits_HowManyNA)
Check_identical_GenoYoy <- genotypes_AllNonDup_fish_three_digits_HowManyNA %>% 
  select(., -c(NAs, Sample_ID)) %>% 
  distinct()
nrow(Check_identical_GenoYoy) == nrow(genotypes_AllNonDup_fish_three_digits_HowManyNA)
```
If true you have no identical rows ! 


### 4) Replace NAs with "na"

 Ya une sombre histoire avec les NA ici. En gros mieux vaut remplacer par "na"

```{r}
i <- sapply(genotypes_AllNonDup_fish_three_digits, is.factor) # Identify all factor variables in your data
genotypes_AllNonDup_fish_three_digits[i] <- lapply(genotypes_AllNonDup_fish_three_digits[i], as.character) # Convert factors to character variables
genotypes_AllNonDup_fish_three_digits[is.na(genotypes_AllNonDup_fish_three_digits)] <- "na" # Replace NAs with "NA", as shown in Example 1
genotypes_AllNonDup_fish_three_digits[i] <- lapply(genotypes_AllNonDup_fish_three_digits[i], as.factor) # Convert character columns back to factors
```



### 5) From Two to One column per locus 

Merge columns together for conversion to genind
We need the one row/loci format ! 
```{r}
genotypes_AllNonDup_fish_3digs_oneColformat <- genotypes_AllNonDup_fish_three_digits %>% 
  gather(., Loci, Allele, -Sample_ID, na.rm = F) %>% 
  mutate(., Unified_Loci = gsub( x = Loci, "^([0-9]{1,6}).[0-9]{1}$", "\\1" )) %>%
  ungroup()  %>% 
  group_by(., Sample_ID, Unified_Loci) %>% 
  mutate(., two_alleles = paste0(Allele, collapse = "/")) %>% 
  select(., -c(Loci, Allele)) %>% 
  group_by(., Sample_ID) %>% 
  distinct(., Unified_Loci, .keep_all = T ) %>% 
  spread(., key = Unified_Loci, value = two_alleles) %>% 
  ungroup()

```

### 6) Now convert in genind format ! 
```{r}
# Before remove unused columns 
genotypes_AllNonDup_fish_3digs_oneColformat_forConversion <-  genotypes_AllNonDup_fish_3digs_oneColformat %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID") 

Pops <- genotypes_AllNonDup_fish_3digs_oneColformat_forConversion %>% 
  mutate(., Population = "Big_Creek")

ncol(genotypes_AllNonDup_fish_3digs_oneColformat_forConversion)

genind_genotypes_AllNonDup_fish_three_digits_forGenepop <- df2genind(X = genotypes_AllNonDup_fish_3digs_oneColformat_forConversion , sep = "/", NA.char = "na", pop = Pops$Population)

genind_genotypes_AllNonDup_fish_three_digits_forGenepop
``` 


### 7) Convert to genepop 

```{r}
#writeGenPop(gi = genind_genotypes_AllNonDup_fish_three_digits_forGenepop, file.name = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Analysis/Summary_stats/genpop_genotypes_AllNonDup_fish_three_digits_forGenepop.gen", comment = "Hello Noe")
```
### 8) diveRsity: BasicStats 

WARNING: Here you have to open the file created above and create a fake second pop just with a couple of individuals, otherwise the command won't launch. 
 
```{r}
# Takes some time so un# if needed. 
# Stats_BigCreek_Alltabs <- basicStats(infile = "Summary_stats/genpop_genotypes_AllNonDup_fish_three_digits_forGenepop.gen", 
           outfile = "Summary_stats/BigCreek_NoDuplicates", fis_ci = T, fis_boots = 1000, mc_reps = 10000)

Stats_BigCreek_Maintab <- Stats_BigCreek_Alltabs[["main_tab"]][["SH_1258"]]
Stats_BigCreek_Maintab
Stats_BigCreek_Overall <- Stats_BigCreek_Maintab %>% 
  select(., overall)
```
  
## F) Omy5 analysis

1) Check Omy5 HWE the overall population, in residents, in anadromous, in Female, in Males, in big and small fish.

2) Old fish : What Omy5 ?

> Hypothesis The big-tagged individuals that are >150mm are RESIDENTS.

  - You should see a bias towards: 
      a) RR genotypes should be residents
      b) AA genotypes should be anadromous (i.e absent in >150mm individuals)
      c) AR genotypes should be biased towards :
          1) Females anadromous
          2) Resident males
          
3) What is the ditribution of Omy5 genotypes in adults vs youngs ?
    --> Espect a residency effect.
  - Juvenile RR families will be rare and small (and we may find a resident mother), 
    while AR individuals and families will be excessively common.
  - Does Omy5 genotype (i.e anadromous behavior) influence family size?
  - Does Omy5 genotype influence lifetime reproductive success? 
    ** Just for individuals that we see as YOY and don't appear after (i.e dead) **
    ** Maybe mostly resident males ? ** 

4) Relation between length and distance and Omy5 genotypes ?

Omy5 -- Hypotheses:

 -We will identify many more fathers than mothers among the residents.
    -- this follows from the known female bias in andromy.
    -- sex ratios in various cohorts also interesting to compare.

 Siblings will be spatially clustered by reach within the creek.
    --the Upper Big creek reach is 750m, diveded into 25m shocking sections.

  The most interesting inference will come from comparing distributions of Omy05 genotypes among residents (>150 or 180mm) vs. juveniles, and comparing both with HWE expectations. Omy5 genotypes will reflect sex-dependent dominance of anadomy—Females residents will almost all be RR. Juvenile RR families will be rare and small (and we may find a resident mother), while AR individuals and families will be excessively common.
  
   Remember we don't have any anadromous female in this dataset, so all of our potential mothers are residents no matter what their Omy05 genotype is  



### 1) Omy5 HWE in different groups.

```{r}
library(HardyWeinberg)
```

See some documentation : https://cran.r-project.org/web/packages/HardyWeinberg/vignettes/HardyWeinberg.pdf 

#### a) Prepare info
```{r}
OmyTotal_1809 <- Minimeta_V8 %>% 
  filter(., Sample_ID %in% Distances_1809_fish$Sample_ID) %>%  # To make sure you remove duplicates.
  select(., c(Sample_ID, hapstr, Sex)) %>%  
  filter(., !is.na(hapstr)) %>% 
  mutate(., hapstr2dig = if_else(hapstr == "AAAA", "AA", if_else(hapstr == "RRRR", "RR", "AR"))) %>% 
  select(., -hapstr)
nrow(OmyTotal_1809)
```
 REPORT : Some fish removed for test since no Omy5 Haplotype info. 

#### b) HWE (Omy5 marker only): Overall, males, females

Split the dataset in the different categories and test ! 

##### ♣ > Overall Population

```{r}
OmyTotal_1809_overall <- OmyTotal_1809 %>% 
  add_count(., hapstr2dig, name = "Hapstr_count") %>% 
  distinct(., Hapstr_count, .keep_all = T) %>% 
  select(., -c(Sex, Sample_ID)) 

OmyTotal_1809_overall_vector <- c(OmyTotal_1809_overall$Hapstr_count)
names(OmyTotal_1809_overall_vector) <- c(OmyTotal_1809_overall$hapstr2dig)

OmyTotal_1809_overall_vector
```

Test on overall populations :
```{r}
HWAlltests(OmyTotal_1809_overall_vector, include.permutation.test = T ,verbose=TRUE)
```

##### ♣ > Males 

```{r}
OmyTotal_1809_males <- OmyTotal_1809 %>% 
  filter(., Sex == "M") %>% 
  add_count(., hapstr2dig, name = "Hapstr_count") %>% 
  distinct(., Hapstr_count, .keep_all = T) %>% 
  select(., -c(Sex, Sample_ID)) 

OmyTotal_1809_males_vector <- c(OmyTotal_1809_males$Hapstr_count)
names(OmyTotal_1809_males_vector) <- c(OmyTotal_1809_males$hapstr2dig)

OmyTotal_1809_males_vector
```

Test on males in population :
```{r}
HWAlltests(OmyTotal_1809_males_vector,verbose=TRUE)
```

##### ♣ > females 

```{r}
OmyTotal_1809_females <- OmyTotal_1809 %>% 
  filter(., Sex == "F") %>% 
  add_count(., hapstr2dig, name = "Hapstr_count") %>% 
  distinct(., Hapstr_count, .keep_all = T) %>% 
  select(., -c(Sex, Sample_ID)) 

OmyTotal_1809_females_vector <- c(OmyTotal_1809_females$Hapstr_count)
names(OmyTotal_1809_females_vector) <- c(OmyTotal_1809_females$hapstr2dig)

OmyTotal_1809_females_vector
```

Test on females in population :
```{r}
HWAlltests(OmyTotal_1809_females_vector,verbose=TRUE)
```
 
##### ♣ > BIG males
 
```{r}
OmyTotal_94Big_males <- OmyTotal_1809 %>% 
  filter(., Sex == "M") %>% 
  filter(., Sample_ID %in% Big_fish_list_withOmy5$Sample_ID) %>%  
  # The dataset here is computed below ... Not best practice but it's ok. 
  add_count(., hapstr2dig, name = "Hapstr_count") %>% 
  distinct(., Hapstr_count, .keep_all = T) %>% 
  select(., -c(Sex, Sample_ID)) 

OmyTotal_94Big_males_vector <- c(OmyTotal_94Big_males$Hapstr_count)
names(OmyTotal_94Big_males_vector) <- c(OmyTotal_94Big_males$hapstr2dig)

OmyTotal_94Big_males_vector
```
Test on big females in population :
```{r}
HWAlltests(OmyTotal_94Big_males_vector,verbose=TRUE)
``` 
 
##### ♣ > BIG females
 
```{r}
OmyTotal_94Big_females <- OmyTotal_1809 %>% 
  filter(., Sex == "F") %>% 
  filter(., Sample_ID %in% Big_fish_list_withOmy5$Sample_ID) %>%  # The dataset here is computed below ... Not best practice but it's ok. 
  add_count(., hapstr2dig, name = "Hapstr_count") %>% 
  distinct(., Hapstr_count, .keep_all = T) %>% 
  select(., -c(Sex, Sample_ID)) 

OmyTotal_94Big_females_vector <- c(OmyTotal_94Big_females$Hapstr_count)
names(OmyTotal_94Big_females_vector) <- c(OmyTotal_94Big_females$hapstr2dig)

OmyTotal_94Big_females_vector
```
Test on big females in population :
```{r}
HWAlltests(OmyTotal_94Big_females_vector,verbose=TRUE)
```
  
  
   
#### c) HWE (all markers) vs Omy5 haplotypes

Check HWE for all other markers when grouping for Omy5 in residents, in anadromous,
  
  We follow the procedure used to calculate basic population statistics!  

##### ♠ REPORT ALL BELOW

#####♠ Anadromous 

> List of anadromous fish

```{r}
Anadromous_fish <- OmyTotal_1809 %>% 
  filter(., hapstr2dig == "AA")
```

> Now convert in genind format ! 

```{r}
# Before remove unused columns 
genotypes_anadromous_3digs_oneColformat_forConversion <-  genotypes_AllNonDup_fish_3digs_oneColformat %>%
  filter(., Sample_ID %in% Anadromous_fish$Sample_ID) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID") 

Pops <- genotypes_anadromous_3digs_oneColformat_forConversion %>% 
  mutate(., Population = "Big_Creek")

ncol(genotypes_anadromous_3digs_oneColformat_forConversion)

genind_genotypes_anadromous_three_digits_forGenepop <- df2genind(X = genotypes_anadromous_3digs_oneColformat_forConversion , sep = "/", NA.char = "na", pop = Pops$Population)

genind_genotypes_anadromous_three_digits_forGenepop
``` 


> Convert to genepop 

```{r}
writeGenPop(gi = genind_genotypes_anadromous_three_digits_forGenepop, file.name = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Analysis/Summary_stats/genpop_genotypes_anadromous_three_digits_forGenepop.gen", comment = "Hello Noe")
```

> diveRsity: BasicStats 

WARNING: Here you have to open the file created above and create a fake second pop just with a couple of individuals, otherwise the command won't launch. 
 
```{r}
# Takes some time so un# if needed. 
# Stats_Anadromous_Alltabs <- basicStats(infile = "Summary_stats/genpop_genotypes_anadromous_three_digits_forGenepop.gen", outfile = "Summary_stats/BigCreek_Anadromous", fis_ci = T, fis_boots = 1000, mc_reps = 10000)

Stats_Anadromous_Maintab <- Stats_Anadromous_Alltabs[["main_tab"]][["SH_1267"]]
Stats_Anadromous_Maintab
Stats_Anadromous_Overall <- Stats_Anadromous_Maintab %>% 
  select(., overall)
```
   
#####♠ Residents

> List of residents fish

```{r}
residents_fish <- OmyTotal_1809 %>% 
  filter(., hapstr2dig == "RR")
nrow(residents_fish)
```

> Now convert in genind format ! 

```{r}
# Before remove unused columns 
genotypes_residents_3digs_oneColformat_forConversion <-  genotypes_AllNonDup_fish_3digs_oneColformat %>%
  filter(., Sample_ID %in% residents_fish$Sample_ID) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID") 

Pops <- genotypes_residents_3digs_oneColformat_forConversion %>% 
  mutate(., Population = "Big_Creek")

ncol(genotypes_residents_3digs_oneColformat_forConversion)

genind_genotypes_residents_three_digits_forGenepop <- df2genind(X = genotypes_residents_3digs_oneColformat_forConversion , sep = "/", NA.char = "na", pop = Pops$Population)

genind_genotypes_residents_three_digits_forGenepop
``` 


> Convert to genepop 

```{r}
writeGenPop(gi = genind_genotypes_residents_three_digits_forGenepop, file.name = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Analysis/Summary_stats/genpop_genotypes_residents_three_digits_forGenepop.gen", comment = "Hello Noe")
```

> diveRsity: BasicStats 

WARNING: Here you have to open the file created above and create a fake second pop just with a couple of individuals, otherwise the command won't launch. 
 
```{r}
# Takes some time so un# if needed. 
#Stats_residents_Alltabs <- basicStats(infile = "Summary_stats/genpop_genotypes_residents_three_digits_forGenepop.gen", outfile = "Summary_stats/BigCreek_residents", fis_ci = T, fis_boots = 1000, mc_reps = 10000)

Stats_residents_Maintab <- Stats_residents_Alltabs[["main_tab"]][["SH_1258"]]
Stats_residents_Maintab
Stats_residents_Overall <- Stats_residents_Maintab %>% 
  select(., overall)
```
   
#####♠ Heterozygotes

> List of heterozygotes fish

```{r}
heterozygotes_fish <- OmyTotal_1809 %>% 
  filter(., hapstr2dig == "AR")
nrow(heterozygotes_fish)
```

> Now convert in genind format ! 

```{r}
# Before remove unused columns 
genotypes_heterozygotes_3digs_oneColformat_forConversion <-  genotypes_AllNonDup_fish_3digs_oneColformat %>%
  filter(., Sample_ID %in% heterozygotes_fish$Sample_ID) %>% 
  arrange(., Sample_ID) %>% 
  column_to_rownames(., "Sample_ID") 

Pops <- genotypes_heterozygotes_3digs_oneColformat_forConversion %>% 
  mutate(., Population = "Big_Creek")

ncol(genotypes_heterozygotes_3digs_oneColformat_forConversion)

genind_genotypes_heterozygotes_three_digits_forGenepop <- df2genind(X = genotypes_heterozygotes_3digs_oneColformat_forConversion , sep = "/", NA.char = "na", pop = Pops$Population)

genind_genotypes_heterozygotes_three_digits_forGenepop
``` 


> Convert to genepop 

```{r}
writeGenPop(gi = genind_genotypes_heterozygotes_three_digits_forGenepop, file.name = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Analysis/Summary_stats/genpop_genotypes_heterozygotes_three_digits_forGenepop.gen", comment = "Hello Noe")
```

> diveRsity: BasicStats 

WARNING: Here you have to open the file created above and create a fake second pop just with a couple of individuals, otherwise the command won't launch. 
 
```{r}
# Takes some time so un# if needed. 
# Stats_heterozygotes_Alltabs <- basicStats(infile = "Summary_stats/genpop_genotypes_heterozygotes_three_digits_forGenepop.gen", outfile = "Summary_stats/BigCreek_heterozygotes", fis_ci = T, fis_boots = 1000, mc_reps = 10000)

Stats_heterozygotes_Maintab <- Stats_heterozygotes_Alltabs[["main_tab"]][["SH_1259"]]
Stats_heterozygotes_Maintab
Stats_heterozygotes_Overall <- Stats_heterozygotes_Maintab %>% 
  select(., overall)
```   
   
As a conclusion, here, I see no deviation at all from HWE, in all the detasets ...    
   
#### d) HWE (Omy5 only): Big and small 

Do we see a HW disequilibrium in Omy5 marker in small (<150mm) or big (>150mm) fish ? 
So we keep only big or small fish in each dataset. 
Then we calculate the counts of Omy5 haplotypes.
Then we use the HWE test function (HWAlltests).

#####♠ Small fish 

Prepare info to group by length.
```{r}
Small_fish_list_withOmy5 <- Minimeta_V8 %>% 
  filter(., Sample_ID %in% Distances_1809_fish$Sample_ID) %>%  # To make sure you remove duplicates.
  filter(., LENGTH < 150)

Small_fish_list_withOmy5 %>% count(LENGTH > 150) 
```

```{r}
OmyTotal_1809_Small <- OmyTotal_1809 %>% 
  filter(., Sample_ID %in% Small_fish_list_withOmy5$Sample_ID) %>%  # KEEP ONLY SMALL FISH
  add_count(., hapstr2dig, name = "Hapstr_count") %>%               # Count the haplotypes 
  distinct(., Hapstr_count, .keep_all = T) %>%                      # Just keep interesting values
  select(., -c(Sex, Sample_ID)) 

OmyTotal_1809_Small_vector <- c(OmyTotal_1809_Small$Hapstr_count)
names(OmyTotal_1809_Small_vector) <- c(OmyTotal_1809_Small$hapstr2dig)

OmyTotal_1809_Small_vector
```

Test on small fish population :
```{r}
HWAlltests(OmyTotal_1809_Small_vector,verbose=TRUE)
```


#####♠ Big fish 

Prepare info to group by length.
```{r}
Big_fish_list_withOmy5 <- Minimeta_V8 %>% 
  filter(., Sample_ID %in% Distances_1809_fish$Sample_ID) %>%  # To make sure you remove duplicates.
  filter(., LENGTH >= 150)

Big_fish_list_withOmy5 %>% count(LENGTH < 150)
```
   
```{r}
OmyTotal_1809_Big <- OmyTotal_1809 %>% 
  filter(., Sample_ID %in% Big_fish_list_withOmy5$Sample_ID) %>%  # KEEP ONLY Big FISH
  add_count(., hapstr2dig, name = "Hapstr_count") %>%               # Count the haplotypes 
  distinct(., Hapstr_count, .keep_all = T) %>%                      # Just keep interesting values
  select(., -c(Sex, Sample_ID)) 

OmyTotal_1809_Big_vector <- c(OmyTotal_1809_Big$Hapstr_count)
names(OmyTotal_1809_Big_vector) <- c(OmyTotal_1809_Big$hapstr2dig)

OmyTotal_1809_Big_vector
```

Test on Big fish population :
```{r}
HWAlltests(OmyTotal_1809_Big_vector,verbose=TRUE)
```
 

   
### 2) Old fish : What Omy5 ?

> Hypothesis The big-tagged individuals that are >150mm are RESIDENTS.

  - You should see a bias towards: 
      a) AA genotypes should be anadromous (i.e absent in >150mm individuals)
      b) RR genotypes should be residents
      c) AR genotypes should be biased towards :
          1) Females anadromous
          2) Resident males
      d) Relation between length and distance and Omy5 genotypes ?
      
      
      
The dataset needed is simply a minimeta with length and hapstr (i.e Omy5 haplotype string)  

#### a) AA genotypes should be anadromous

```{r}
 NoDupfish_and_Omy5 <- Minimeta_V8 %>% 
  ungroup() %>% 
  filter(., Sample_ID %in% For_Colony_Sibship_Noduplicates$Sample_ID) %>% 
  filter(., !is.na(hapstr))
```


```{r}
#esquisser(NoDupfish_and_Omy5)

# LENGTH vs Hapstr plot V2

ggplot(NoDupfish_and_Omy5) +
 aes(x = LENGTH, fill = Coll_year) +
 geom_histogram(bins = 30L) +
 scale_fill_hue() +
 theme_minimal() +
 facet_wrap(vars(hapstr))

# LENGTH vs Hapstr plot V3

ggplot(NoDupfish_and_Omy5) +
 aes(x = LENGTH, fill = Coll_year) +
 geom_histogram(bins = 30L) +
 scale_fill_hue() +
 theme_minimal() +
 facet_wrap(vars(hapstr), scales = "free_y")

# LENGTH vs Hapstr plot V4

ggplot(NoDupfish_and_Omy5) +
 aes(x = LENGTH, fill = Sex) +
 geom_histogram(bins = 30L) +
 scale_fill_hue() +
 theme_minimal() +
 facet_wrap(vars(hapstr))

```


> So, as planned, we see that anadromous fish are almost absent from 150+ length fish!

But, really, we want to test it: 
http://www.sthda.com/english/wiki/two-proportions-z-test-in-r 

So let's do a Z-test (To test differences in proportions).
First we need to compute proportions, haplotype per haplotype: i.e the test will ask for example "is there a difference in the proportions of AAAA between the two groups?"

*AAAA*
```{r}

Big_fish_and_Omy5 <- NoDupfish_and_Omy5 %>% 
    filter(., LENGTH >= 150) 

Small_fish_and_Omy5 <- NoDupfish_and_Omy5 %>% 
    filter(., LENGTH < 150) 

# Now the proportions
Big_PropAAAA_nrow <- Big_fish_and_Omy5 %>% filter(., hapstr == "AAAA")
Big_PropAAAA <- nrow(Big_PropAAAA_nrow)
Big_fish_and_Omy5 %>% 
  count(., hapstr)
```

```{r}
Small_PropAAAA_nrow <- Small_fish_and_Omy5 %>% filter(., hapstr == "AAAA")
Small_PropAAAA <- nrow(Small_PropAAAA_nrow)
Small_fish_and_Omy5 %>% 
  count(., hapstr)
```

```{r}
Test_AAAA_BigvsSmallfish <- prop.test(x = c(Big_PropAAAA, Small_PropAAAA) , n = c(nrow(Big_fish_and_Omy5), nrow(Small_fish_and_Omy5)), alternative = "less")
Test_AAAA_BigvsSmallfish
```
Ouh la chiquita ! We have a p-value of 0.002107, so there are significantly less AAAA fish in the 150+ group! 
(Approx. half of what they have in <150 length fish group)

####b) RR genotypes should be residents

*RRRR*
Now let's test if there are more RRRR in the 150+ fish! 
```{r}
# The proportions
Big_PropRRRR_nrow <- Big_fish_and_Omy5 %>% filter(., hapstr == "RRRR")
Big_PropRRRR <- nrow(Big_PropRRRR_nrow)
Big_fish_and_Omy5 %>% 
  count(., hapstr)
```

```{r}
Small_PropRRRR_nrow <- Small_fish_and_Omy5 %>% filter(., hapstr == "RRRR")
Small_PropRRRR <- nrow(Small_PropRRRR_nrow)
Small_fish_and_Omy5 %>% 
  count(., hapstr)
```

```{r}
Test_RRRR_BigvsSmallfish <- prop.test(x = c(Big_PropRRRR, Small_PropRRRR) , n = c(nrow(Big_fish_and_Omy5), nrow(Small_fish_and_Omy5)), alternative = "greater")
Test_RRRR_BigvsSmallfish
```
Ouh la chiquita ! We have a p-value of 0.002807, so there are significantly more RRRR fish in the 150+ group! 
They have 0.4168937 of RRRR in <150 length fish group) and 0.5068493 in the 150+ length group. 

#### c) AR genotypes and sex dominance

> Hypothesis: AR genotypes should be biased towards :
          1) Resident males
          2) Females anadromous

Let's explore
```{r}
ggplot(NoDupfish_and_Omy5) +
 aes(x = LENGTH, fill = hapstr) +
 geom_histogram(bins = 30L) +
 scale_fill_hue() +
 labs(title = "Omy5 haplotype distribution with length (1760 fish Bigc Creek)", fill = "Omy5 Haplotype") +
 theme_minimal() +
 facet_wrap(vars(Sex))
```
Let's keep the heterozygotes only
```{r}
HHHH_NoDupfish_and_Omy5 <- NoDupfish_and_Omy5 %>%
  filter(., hapstr == "HHHH")

Big_fish_and_Omy5_HHHH <- HHHH_NoDupfish_and_Omy5 %>% 
    filter(., LENGTH >= 150) 

Small_fish_and_Omy5_HHHH <- HHHH_NoDupfish_and_Omy5 %>% 
    filter(., LENGTH < 150) 

HHHH_NoDupfish_and_Omy5 %>% count(., hapstr)
```
```{r}
HHHH_NoDupfish_and_Omy5 %>% count(., Sex)
```
There is actually no sex bias overall ! 

```{r}
HHHH_NoDupfish_and_Omy5 %>% filter(., LENGTH > 150) %>% count(., Sex)
```
But there is a bias in Big fish !
```{r}
HHHH_NoDupfish_and_Omy5 %>% filter(., LENGTH < 150) %>% count(., Sex)
```
And not in small fish !


```{r}
ggplot(HHHH_NoDupfish_and_Omy5) +
 aes(x = LENGTH, fill = Sex) +
 geom_histogram(bins = 30L) +
 scale_fill_hue() +
 labs(title = "HHHH Omy5 genotypes, length vs Sex", subtitle = "(We can see that 150+
 fish are male-biased!)") +
 theme_minimal()
```

So, again, let's test it ! 

*Less females in 150+ fish ?*
Now let's test if there are less females in the 150+ fish! 
```{r}
# The proportions
Big_PropHHHHfemales_nrow <- Big_fish_and_Omy5_HHHH %>% filter(., Sex == "F")
Big_PropHHHHfemales <- nrow(Big_PropHHHHfemales_nrow)
Big_fish_and_Omy5_HHHH %>% 
  count(.,Sex)
```

```{r}
Small_PropHHHHfemales_nrow <- Small_fish_and_Omy5_HHHH %>% filter(., Sex == "F")
Small_PropHHHHfemales <- nrow(Small_PropHHHHfemales_nrow)
Small_fish_and_Omy5_HHHH %>% 
  count(., Sex)
```

```{r}
Test_HHHHfemales_BigvsSmallfish <- prop.test(x = c(Big_PropHHHHfemales, Small_PropHHHHfemales) , n = c(nrow(Big_fish_and_Omy5_HHHH), nrow(Small_fish_and_Omy5_HHHH)), alternative = "less")
Test_HHHHfemales_BigvsSmallfish
```
Alt. Hypothesis: There are proportionally less females in big heterozygote fish than in small heterozygote fish. 
Boom! There are significantly less females in 150+ length fish heterozygotes. 


*More males in 150+ fish ?* --> i.e the opposite question of above ?

```{r}
# The proportions
Big_PropHHHHmales_nrow <- Big_fish_and_Omy5_HHHH %>% filter(., Sex == "M")
Big_PropHHHHmales <- nrow(Big_PropHHHHmales_nrow)
Big_fish_and_Omy5_HHHH %>% 
  count(.,Sex)
```

```{r}
Small_PropHHHHmales_nrow <- Small_fish_and_Omy5_HHHH %>% filter(., Sex == "M")
Small_PropHHHHmales <- nrow(Small_PropHHHHmales_nrow)
Small_fish_and_Omy5_HHHH %>% 
  count(., Sex)
```

```{r}
Test_HHHHmales_BigvsSmallfish <- prop.test(x = c(Big_PropHHHHmales, Small_PropHHHHmales) , n = c(nrow(Big_fish_and_Omy5_HHHH), nrow(Small_fish_and_Omy5_HHHH)), alternative = "greater")
Test_HHHHmales_BigvsSmallfish
```


### 3) What is the ditribution of Omy5 genotypes in adults vs youngs ?

    --> Espect a residency effect.
  A) Juvenile RR families will be rare and small (and we may find a resident mother), 
    while AR individuals and families will be excessively common.
  B) Does Omy5 genotype (i.e anadromous behavior) influence family size?
  C) Does Omy5 genotype influence lifetime reproductive success? 
    ** Just for individuals that we see as YOY and don't appear after (i.e dead) **
    ** Maybe mostly resident males ? ** 


#### a) Juvenile RR families will be rare and small (and we may find a resident mother), 
    while AR individuals and families will be excessively common.

```{r}
# Number of YoY families
Filtered_YOY_Fullsibs %>%  distinct(FullSibshipIndex) %>% nrow()
```

Now check the number and size of RRRR YoY fullsibs families
```{r}
RRRR_yoyfams <- Filtered_YOY_Fullsibs %>% 
  group_by(., FullSibshipIndex) %>% 
  filter(., !is.na(hapstr)) %>% 
  mutate(., zgego = n_distinct(hapstr)) %>% 
  filter(., zgego == 1) %>% 
  filter(., hapstr == "RRRR") %>% 
  distinct(., FullSibshipIndex, .keep_all = T) %>% 
  select(., FullSibshipIndex, YOY_sibsize_AllYears, hapstr)
```

Same with the HHHH, which are expected to be bigger and more numerous.
```{r}
HHHH_yoyfams <- Filtered_YOY_Fullsibs %>% 
  group_by(., FullSibshipIndex) %>% 
  filter(., !is.na(hapstr)) %>% 
  mutate(., zgego = n_distinct(hapstr)) %>% 
  filter(., zgego == 1) %>% 
  filter(., hapstr == "HHHH") %>% 
  distinct(., FullSibshipIndex, .keep_all = T) %>% 
  select(., FullSibshipIndex, YOY_sibsize_AllYears, hapstr)
```

```{r}
nrow(HHHH_yoyfams)
nrow(RRRR_yoyfams)
```


```{r}
t.test(RRRR_yoyfams$YOY_sibsize_AllYears,  HHHH_yoyfams$YOY_sibsize_AllYears, alternative = "less")
```

CONCLUSION: 

IF YOU TAKE ONLY THE PURE HHHH FAMILIES TO COMPARE, 
THERE IS NO SIGNFICANT DIFFERENCES IN NUMBER AND SIZE OF RRRR AND HHHH YOY FAMILIES.


#### b) Omy5 genotype influences family size?


```{r}
CorrOmy5Famsize <- SibsAndParentage_V3 %>% 
  distinct(., FamIndex_per_year, .keep_all =  T) %>% 
  select(., FamIndex_per_year, Proportion_A_alleles_Family, FamilySize_SPtrio)

cor.test(CorrOmy5Famsize$Proportion_A_alleles_Family, CorrOmy5Famsize$FamilySize_SPtrio, alternative = "two.sided", method = "pearson")
```

CONCLUSION :  NO CORRELATION BETWEEN NUMBER OF ANADROMOUS ALLELES AND FAMILISIZE ! 

***
WARNING
***

This model below is a bit dodgy since the family size is duplicated for each kid, while the best would have been to compare family size and "averaged" Omy5 type of the family ! 
```{r}

model_FamilySize_Hapstr <- lm( FamilySize_SPtrio ~ hapstr_kid , SibsAndParentage_V3)
summary(model_FamilySize_Hapstr)
```

#### c) Omy5 influences reproductive success?


```{r}

Dads_SibsAndParentage_V3 <- SibsAndParentage_V3 %>% 
  filter(., !is.na(Dad)) %>% 
  distinct(., Dad, .keep_all = T) 

Moms_SibsAndParentage_V3 <- SibsAndParentage_V3 %>% 
  filter(., !is.na(Mom)) %>% 
  distinct(., Mom, .keep_all = T) 

Moms_AAAA <- Moms_SibsAndParentage_V3 %>%  filter(., MomOmy5 == "AAAA")
Moms_HHHH <- Moms_SibsAndParentage_V3 %>%  filter(., MomOmy5 == "HHHH")
Moms_RRRR <- Moms_SibsAndParentage_V3 %>%  filter(., MomOmy5 == "RRRR")


#▲ Test normality
shapiro.test(Moms_SibsAndParentage_V3$Number_of_kids_Mom)
shapiro.test(Dads_SibsAndParentage_V3$Number_of_kids_Dad)




library(tidyverse)
library(ggpubr)
library(rstatix)
library(broom)
library(car)

 
patate <- SibsAndParentage_V3 %>% 
  select(., Mom, Number_of_kids_Mom, MomOmy5, Momsize, Reprod_events_Mom) %>% 
  mutate(., sex = "F") %>% 
  rename(., Sample_ID = "Mom", Number_of_kids = "Number_of_kids_Mom", Omy5 = "MomOmy5", Length = "Momsize", Repro_events = "Reprod_events_Mom") %>% 
  filter(., !is.na(Sample_ID)) %>% 
  distinct(., Sample_ID, .keep_all = T)

Lard <- SibsAndParentage_V3 %>% 
  select(., Dad, Number_of_kids_Dad, DadOmy5, Dadsize, Reprod_events_Dad) %>% 
  mutate(., sex = "M") %>% 
  rename(., Sample_ID = "Dad", Number_of_kids = "Number_of_kids_Dad", Omy5 = "DadOmy5", Length = "Dadsize", Repro_events = "Reprod_events_Dad")%>% 
  filter(., !is.na(Sample_ID)) %>% 
  distinct(., Sample_ID, .keep_all = T)

patatolard <- rbind(patate, Lard)

res.kruskal_1 <- patatolard %>% kruskal_test(Number_of_kids ~ Omy5 )
res.kruskal_2 <- patatolard %>% kruskal_test(Omy5 ~ Number_of_kids)

res.kruskal_1
res.kruskal_2

res.kruskal_F <- patatolard %>% 
                filter(., sex == "F") %>% 
                kruskal_test(Omy5 ~ Number_of_kids) 

res.kruskal_F

res.kruskal_M <- patatolard %>% 
                filter(., sex == "M") %>% 
                kruskal_test(Omy5 ~ Number_of_kids) 

res.kruskal_M
```


Maybe significant in big parents ? 

```{r}
Big_res.kruskal_1 <- patatolard %>% filter(., Length > 100) %>% kruskal_test(Number_of_kids ~ Omy5 )
Big_res.kruskal_2 <- patatolard %>% filter(., Length > 100) %>% kruskal_test(Omy5 ~ Number_of_kids)

Big_res.kruskal_1
Big_res.kruskal_2

Big_res.kruskal_F <- patatolard %>% 
                filter(., sex == "F") %>% 
                filter(., Length > 100) %>% 
                kruskal_test(Omy5 ~ Number_of_kids) 

Big_res.kruskal_F

Big_res.kruskal_M <- patatolard %>% 
                filter(., sex == "M") %>% 
                filter(., Length > 100) %>% 
                kruskal_test(Omy5 ~ Number_of_kids) 

Big_res.kruskal_M
```


Let's compare some models using Floriane's code: 

```{r}
# Numkids ~ Omy5 interaction with SEX
model_ancF <- lm(Number_of_kids ~ Omy5 * sex , data= patatolard) # with interaction
summary(model_ancF)
summary.aov(model_ancF)
```
```{r}
# Numkids ~ Omy5 WITHOUT interaction with SEX
model_ancF2 <- lm(Number_of_kids ~ Omy5 + sex , data= patatolard) # without interaction
summary(model_ancF2)
summary.aov(model_ancF2)
```
Without sex
```{r}
# Numkids ~ Omy5 WITHOUT interaction 
model_ancF3 <- lm(Number_of_kids ~ Omy5, data= patatolard) 
summary(model_ancF3)
summary.aov(model_ancF3)
```

Et on compare tout ça avec une anova
```{r}
anova(model_ancF, model_ancF2) # interaction not significant
```
autre facon de comparer les models
```{r}
# AIC selction model #
stepAIC(model_ancF, direction = 'backward')
stepAIC(model_ancFempt, direction = 'forward')
stepAIC(model_ancF, direction = 'both')

```


Et si t'avais eu des trucs significatifs t'aurait pu tester les hypothèses : 
```{r}
#verif hypotheses
# a) autocorrelation of residuals #
 car::durbinWatsonTest(model_ancF) # autocorrelation of residuals
 car::durbinWatsonTest(model_ancF2)

  # same test with another package #
 dwtest(model_ancF)
 dwtest(model_ancF2)
 
 # b) residuals normality #
 
shapiro.test(model_ancF$residuals) 
shapiro.test(model_ancF2$residuals)


 # c) variances homogeneity #

bartlett.test(Number_of_kids ~ Omy5 , data=patatolard)




bartlett.test(residuals(model_ancF)~ patatolard$sex) # Marche pas nono
car::leveneTest(model_ancF, data=all_breed_dataF_test)

levene_test(model_ancF$residuals~PlateMorph)
autoplot
condition_F <- autoplot(model_ancF, which = 1:6, label.size = 3, 
         colour = 'PlateMorph')
ggsave(condition_F, file="condition_F.tiff")

```
#### d) Omy5 proportions in SINGLE vs MULTIPLE mating parents

This patatolard dataset is actually quite useful !

***** MULTIPLE MATING PARENTS ***** 
```{r}
Multiple patatolard %>% filter(., Repro_events > 1) %>% count(Omy5)
```

80% R and 20% H in multiple mating parents



***** SINGLE MATING PARENTS ***** 
```{r}
patatolard %>% filter(., Repro_events == 1) %>% count(Omy5)
```
  4.71% A 43.53% R and 51.76% H in single mating parents


### 4) Relation between length and distance and Omy5 genotypes ?

First exploration ... not very conclusive 

```{r}
ggplot(NoDupfish_and_Omy5) +
 aes(x = distance, y = LENGTH) +
 geom_point(size = 1L, colour = "#0c4c8a") +
 theme_minimal() +
 facet_wrap(vars(hapstr))
```

https://statistique-et-logiciel-r.com/introduction-aux-glm/

#### a) Correlation Length - distance ? 

In trios and single-pairs, for all fish

```{r}
# Not significant
cor.test(SibsAndParentage_V3$LENGTH_kid, SibsAndParentage_V3$kid_distance, alternative = "two.sided", method = "pearson")
# Not significant 
cor.test(SibsAndParentage_V3$Dadsize, SibsAndParentage_V3$Dad_distance, alternative = "two.sided", method = "pearson")

# WE HAVE SOMETHING between Mom length and distance
cor.test(SibsAndParentage_V3$Momsize, SibsAndParentage_V3$Mom_distance, alternative = "two.sided", method = "pearson")
```



#### b) Correlation Familisize - distance *sex ? 

The family size is increasing with distance of mom !! 
```{r}
cor.test(SibsAndParentage_V3$FamilySize_SPtrio, SibsAndParentage_V3$Mom_distance, alternative = "two.sided", method = "pearson")
```

For dads it is significant too, but negative ... 
```{r}
cor.test(SibsAndParentage_V3$FamilySize_SPtrio, SibsAndParentage_V3$Dad_distance, alternative = "two.sided", method = "pearson")
```


Obviously for kids it's not significant !
```{r}
cor.test(SibsAndParentage_V3$FamilySize_SPtrio, SibsAndParentage_V3$kid_distance, alternative = "two.sided", method = "pearson")
```


, for young offsprings






```{r}
LGT_plus_Hapstr_explDist <- lm(  distance ~ LENGTH * hapstr , NoDupfish_and_Omy5)
summary(LGT_plus_Hapstr_explDist)
```



Hah ! We can see that there are some bigger residents upstream, right ? :D 
 



  
### 5) Relation mean variance of distance ~ % of A alleles ? 


```{r}

Filtered_Fullsibs_distVar <- Filtered_Fullsibs %>% 
                         left_join(., Minidistance_V1, by = c("Sibship_Member" = "Sample_ID")) %>% 
                         group_by(FullSibshipIndex) %>% 
                         mutate(., varianceDist = var(distance)) %>% 
                         mutate(., meanDist = mean(distance)) %>% 
                         ungroup()

Proportions_of_AAAA_per_SIBSHIP <- Filtered_Fullsibs_distVar %>% 
  group_by(., FullSibshipIndex) %>% 
  filter(., !hapstr == "?") %>% 
  mutate(., A_count = if_else( hapstr == "AAAA", 2, if_else(hapstr == "HHHH", 1, if_else(hapstr == "RRRR", 0, 999999999999999 )) )) %>% 
  mutate(., Totsib_A_count = sum(A_count, na.rm = T)) %>% 
  add_count() %>%                  
  mutate(., Proportion_A_alleles_Sibship = Totsib_A_count/(2*Sibsize)) %>% 
  ungroup() 


# To test the relation between sibship Variance in distance and proportion of A alleles 

VarDist_AAAA <- Proportions_of_AAAA_per_SIBSHIP %>% 
  select(., FullSibshipIndex, Proportion_A_alleles_Sibship, varianceDist, meanDist) %>% 
  distinct(., FullSibshipIndex, .keep_all = T)


```

   Some normality checks
   
```{r}
shapiro.test(VarDist_AAAA$Proportion_A_alleles_Sibship)
```
```{r}
shapiro.test(VarDist_AAAA$varianceDist)
```
   
   Normality ok 
   
   
```{r}
cor.test(x = VarDist_AAAA$Proportion_A_alleles_Sibship, y = VarDist_AAAA$varianceDist, alternative = "two.sided", method = "pearson")
```
   
### 6) Relation mean distance ~ % of A alleles ? 
 
   To check if anadromous fish go far in stream ? 

(Represented in offsprings)

```{r}
shapiro.test(VarDist_AAAA$meanDist)
```
```{r}
cor.test(x = VarDist_AAAA$Proportion_A_alleles_Sibship, y = VarDist_AAAA$meanDist, alternative = "two.sided", method = "pearson")
```
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
############################################################################################################   
   
   
   
   
   

The following plots are relating Mom's and Dad's sizes to Omy5 genotypes.

```{r}

DadsizeXomy5 <- ggplot(data = Omy5_per_Year) +
  aes(x = DadOmy5, y = Dadsize) +
  geom_boxplot(fill = "#b2df8a") +
  labs(title = "Boxplots of the length of fathers (from parentage trios or single-pairs) for different Omy5 genotypes",
    x = "\"Omy 5\" anadromy related marker's genotypes ",
    y = "Father's size (mm)",
    caption = "AAAA = Correlated to anadromous life history / RRRR = Correlated to resident life history / HHHH = Heterozygous") +
  theme_minimal()

MomsizeXomy5 <- ggplot(data = Omy5_per_Year) +
  aes(x = MomOmy5, y = Momsize) +
  geom_boxplot(fill = "#b2df8a") +
  labs(title = "Boxplots of the length of mothers (from parentage trios or single-pairs) for different Omy5 genotypes",
    x = "\"Omy 5\" anadromy related marker's genotypes ",
    y = "Mother's size (mm)",
    caption = "AAAA = Correlated to anadromous life history / RRRR = Correlated to resident life history / HHHH = Heterozygous") +
  theme_minimal()


```

 
## G)  Numbers about the parentage in general 

### 1) Average of number of kids per Mom

```{r}
Moms_only <- SibsAndParentage_V3 %>% filter(., !is.na(Mom)) %>% distinct(., Mom, .keep_all = T) 
mean(tartiflette$Number_of_kids_Mom, na.rm = T)
```

### 2) Average of number of kids per Dad

```{r}
Dads_only <- SibsAndParentage_V3 %>% filter(., !is.na(Dad)) %>% distinct(., Dad, .keep_all = T) 
mean(tartiflette$Number_of_kids_Dad, na.rm = T)
```
Are they different ? 
```{r}
t.test(tartiflette$Number_of_kids_Dad, tartiflette$Number_of_kids_Mom, alternative = "two.sided")
```

### 3) Variance in reproductive success in males and females ? 

A thing that we find often in the litterature is the variance in repro success per sex. Let's try it quickly.

```{r}
# Select the right columns
Var_in_repro_SuccSex <- SibsAndParentage_V3 %>% 
  select(., Mom, Dad, Number_of_kids_Mom, Number_of_kids_Dad)

# Now divide per sex and keep one occurence per fish
Var_in_repro_SuccSex_Moms <- Var_in_repro_SuccSex %>% 
  select(., Mom, Number_of_kids_Mom) %>% 
  distinct(., Mom, .keep_all = T)%>% 
  filter(., !is.na(Mom))

Var_in_repro_SuccSex_Dads <- Var_in_repro_SuccSex %>% 
  select(., Dad, Number_of_kids_Dad) %>% 
  distinct(., Dad, .keep_all = T) %>% 
  filter(., !is.na(Dad))

# Now check the variances
var(Var_in_repro_SuccSex_Moms$Number_of_kids_Mom)
var(Var_in_repro_SuccSex_Dads$Number_of_kids_Dad)

# Test for a significant difference.
shapiro.test(Var_in_repro_SuccSex_Dads$Number_of_kids_Dad)
shapiro.test(Var_in_repro_SuccSex_Moms$Number_of_kids_Mom)

var.test(x = Var_in_repro_SuccSex_Dads$Number_of_kids_Dad, y =  Var_in_repro_SuccSex_Moms$Number_of_kids_Mom, alternative = "greater")

```


## H) Antennas - PitTag - Rundio

This is the message I got from Dave about this data, read it !

Here are 2 files with the antenna detections for these fish -- one file for detections on the beach antenna (36 fish) and another for detections at the bottom of Upper Big Creek (51 fish). Most, but not all, fish detected at the beach were detected on the UBC antenna (detection rate is < 100% even when they are running, plus they get knocked out during storms etc.).

The data fields I've added are:

- fish_num: the unique identifier for our capture/antenna database

- fixed_antenna_id: "bt" in beach file, "dc" in UBC file (same reader at the confluence of UBC and Devils Creek runs loops on both reaches)

- MinDetectDate: the date of first antenna detection

- MaxDetectDate: the date of the last antenna detection

- MaxCaptureDate: the date of the last capture during efishing surveys


Some caution needs to used for these raw detection data, as detection at either antenna (beach or at mouth of UBC) does not necessarily mean that the fish left the stream or UBC. For example, fish_num 27411 was captured efishing 6 weeks AFTER its last detection on the beach antenna, so obviously it had not gone to the ocean. And some fish bounce back and forth between the beach and confluence antennas indicating that a few fish make impressive movements within the study area. For the Pearse et al. NEE paper we came up with additional criteria and screens using the full efishing and antenna data to identify likely smolts on the beach antenna, so we would probably want to do the same if there's a story here and these data are included in the paper.




### 0) Attach some metadata

IN THESE YOU HAVE DUPLICATED OBSERVATIONS : Some fish have been detected in both antennas.

```{r}
AntennaFish <- rbind(UBC_antenna_detections_microhaps_big_fish_23Oct2020, UBC_beach_antenna_detections_microhaps_big_fish_23Oct2020)

AntennaFishMeta <- AntennaFish %>% 
  left_join(., Minimeta_V8_noDup, by = "Sample_ID")
```

Ok so all the detected fish are BIG FISH


Are there common fish? How many? 
```{r}
Commonfish <- AntennaFishMeta %>% group_by(Sample_ID) %>%  add_count() %>% filter(., n >= 2) 

# How many common fish ? 
nrow(Commonfish)/2
```

### 1) UBC antenna

```{r}
library(readxl)
UBC_antenna_detections_microhaps_big_fish_23Oct2020 <- read_excel("Antenna_detection_Rundio/UBC_microhaps_big fish_UBC antenna detections_23Oct2020.xlsx")
```

### 2) Beach antenna

```{r}
UBC_beach_antenna_detections_microhaps_big_fish_23Oct2020 <- read_excel("Antenna_detection_Rundio/UBC_microhaps_big fish_beach antenna detections_23Oct2020.xlsx")
```

### 3) What can we do with this? 

- a) Check if more females are detected at beach antenna compared to UBC antenna
- b) Check Omy5 ratios at the two antennas
- c) Check "sex-dominance" in HHHH that are detected downstream (beach) compared to UBC antenna

- e) Check if the fish detected have any particular features: From big families, or had a large amount of offsprings, or in sibships, are they in sibships with high "estimated dispersal".

#### a) (BIG FISH ONLY) Check if more females are detected at beach antenna compared to UBC antenna

```{r}
# Sex ratio in total dataset (BIG FISH ONLY)

Minimeta_V8_noDup_Big_Fish %>% 
  group_by(., Sex) %>% 
  summarise(Numfishpersex=n()) %>% 
  mutate(., Ratio_sex = Numfishpersex/nrow(Minimeta_V8_noDup_Big_Fish))

# In UBC antenna
UBC_antenna_detections_microhaps_big_fish_23Oct2020 %>% 
  group_by(., Sex) %>% 
  summarise(Numfishpersex=n()) %>% 
  mutate(., Ratio_sex = Numfishpersex/nrow(UBC_antenna_detections_microhaps_big_fish_23Oct2020))


# In Beach antenna
UBC_beach_antenna_detections_microhaps_big_fish_23Oct2020 %>% 
  group_by(., Sex) %>% 
  summarise(Numfishpersex=n()) %>% 
  mutate(., Ratio_sex = Numfishpersex/nrow(UBC_beach_antenna_detections_microhaps_big_fish_23Oct2020))

```

#### b) (BIG FISH ONLY) Check Omy5 ratios at the two antennas


```{r}
# OMY5 ratio in total dataset (BIG FISH ONLY)

Minimeta_V8_noDup_Big_Fish %>% 
  group_by(., hapstr) %>% 
  summarise(NumfishperOmy5=n()) %>% 
  mutate(., Ratio_Omy5 = NumfishperOmy5/nrow(Minimeta_V8_noDup_Big_Fish))

# In UBC antenna
UBC_antenna_detections_microhaps_big_fish_23Oct2020 %>% 
  group_by(., hapstr) %>% 
  summarise(NumfishperOmy5=n()) %>% 
  mutate(., Ratio_Omy5 = NumfishperOmy5/nrow(UBC_antenna_detections_microhaps_big_fish_23Oct2020))


# In Beach antenna
UBC_beach_antenna_detections_microhaps_big_fish_23Oct2020 %>% 
  group_by(., hapstr) %>% 
  summarise(NumfishperOmy5=n()) %>% 
  mutate(., Ratio_Omy5 = NumfishperOmy5/nrow(UBC_beach_antenna_detections_microhaps_big_fish_23Oct2020))

```
#### c) (BIG FISH ONLY) Check "sex-dominance" in HHHH that are detected downstream (beach) compared to UBC antenna

```{r}
# OMY5 ratio in total dataset (BIG FISH ONLY)

Minimeta_V8_noDup_Big_Fish %>% 
  filter(., hapstr == "HHHH") %>% 
  add_count(., name = "Total_HHHHfishcount" ) %>% 
  group_by(., Sex) %>% 
  add_count(., name = "Persex_HHHHfishcount" ) %>% 
  mutate(., Ratio_Sex_inHHHH = Persex_HHHHfishcount/Total_HHHHfishcount) %>% 
  summarise(ratio = c(Ratio_Sex_inHHHH), N = n()) %>% 
  distinct()

# In UBC antenna
UBC_antenna_detections_microhaps_big_fish_23Oct2020 %>% 
  filter(., hapstr == "HHHH") %>% 
  add_count(., name = "Total_HHHHfishcount" ) %>% 
  group_by(., Sex) %>% 
  add_count(., name = "Persex_HHHHfishcount" ) %>% 
  mutate(., Ratio_Sex_inHHHH = Persex_HHHHfishcount/Total_HHHHfishcount) %>% 
  summarise(ratio = c(Ratio_Sex_inHHHH), N = n())  %>% 
  distinct()


# In Beach antenna
UBC_beach_antenna_detections_microhaps_big_fish_23Oct2020 %>% 
  filter(., hapstr == "HHHH") %>% 
  add_count(., name = "Total_HHHHfishcount" ) %>% 
  group_by(., Sex) %>% 
  add_count(., name = "Persex_HHHHfishcount" ) %>% 
  mutate(., Ratio_Sex_inHHHH = Persex_HHHHfishcount/Total_HHHHfishcount) %>% 
  summarise(ratio = c(Ratio_Sex_inHHHH), N = n()) %>% 
  distinct() 

```

```{r}
esquisse::esquisser(UBC_antenna_detections_microhaps_big_fish_23Oct2020)
```






## I) The "missing mom effect"

The question here is 'What if you compare families with only a father assigned (so likely Andromous mother carrying AA or AR) vs sibships with a mother assigned (either singly or in a trio)?' 

I (Devon) think I would predict that sibships with only fathers would have 1) larger sibships and 2) more A alleles, than the sibships with mothers. But it depends on if the moms are residents or anadromous that we sampled as juveniles.

*Do sibships with only fathers have larger sibships than a) sibships with a mother + a father assigned or b) just a mother assigned ?*

SibsAndParentage_V3 is the one we need.
Filtered_Fullsibs_V3 is what we use to check alleles stuff because it still has the sibships of size 2!

```{r}
# a) sibships with a mother + a father assigned

Divorced_dads <-  SibsAndParentage_V3 %>% 
  filter(., is.na(Mom)) %>%                      # To make sure we have single pairs only
  filter(., !is.na(Kid_Fullsibship_Index))       # To make sure all these dads have sibships assigned
        
Complete_couples <- SibsAndParentage_V3 %>% 
  filter(., !is.na(Mom)) %>% 
  filter(., !is.na(Dad)) %>%
  filter(., !is.na(Kid_Fullsibship_Index))
  
Sibships_of_divorced_dads <- Filtered_Fullsibs_V3 %>% 
  filter(., FullSibshipIndex %in% Divorced_dads$Kid_Fullsibship_Index) %>% 
  select(., -c(Sex, Coll_year, Coll_month, Coll_day, LENGTH, WEIGHT, AGE, Indiv, Population, hapstr, YearYOYclone, YOY, HasRemovedClone, HasYOYclone, distance)) %>% 
  distinct(., FullSibshipIndex, .keep_all = T)
 
Sibships_of_Complete_Couples <- Filtered_Fullsibs_V3 %>% 
  filter(., FullSibshipIndex %in% Complete_couples$Kid_Fullsibship_Index) %>% 
  select(., -c(Sex, Coll_year, Coll_month, Coll_day, LENGTH, WEIGHT, AGE, Indiv, Population, hapstr, YearYOYclone, YOY, HasRemovedClone, HasYOYclone, distance)) %>% 
  distinct(., FullSibshipIndex, .keep_all = T)


shapiro.test(Sibships_of_divorced_dads$Sibsize)
# Ok data is anormal so we witch to a wilcox test on medians

wilcox.test(x = Sibships_of_divorced_dads$Sibsize, y = Sibships_of_Complete_Couples$Sibsize, alternative = "greater" )


t.test(Sibships_of_divorced_dads$Sibsize, y = Sibships_of_non_divorced_dads$Sibsize , alternative = "greater")
```

```{r}
# b) just a mother assigned

Divorced_Moms <-  SibsAndParentage_V3 %>% 
  filter(., is.na(Dad)) %>%                  # To make sure we have single pairs only
  filter(., !is.na(Kid_Fullsibship_Index))   # To make sure all these dads have sibships    

Sibships_of_Divorced_Moms <- Filtered_Fullsibs_V3 %>% 
  filter(., FullSibshipIndex %in% Divorced_Moms$Kid_Fullsibship_Index) %>% 
  select(., -c(Sex, Coll_year, Coll_month, Coll_day, LENGTH, WEIGHT, AGE, Indiv, Population, hapstr, YearYOYclone, YOY, HasRemovedClone, HasYOYclone, distance)) %>% 
  distinct(., FullSibshipIndex, .keep_all = T)

wilcox.test(x = Sibships_of_divorced_dads$Sibsize, y = Sibships_of_Divorced_Moms$Sibsize, alternative = "greater" )


t.test(Sibships_of_divorced_dads$Sibsize, y = Sibships_of_Divorced_Moms$Sibsize , alternative = "greater")

```


*Do sibships with only fathers contain more A alleles than c) sibships with a mother + a father assigned or d) just a mother assigned ?*
```{r}
# C) sibships with a mother + a father assigned

wilcox.test(x = Sibships_of_divorced_dads$Proportion_A_alleles_Sibship, y = Sibships_of_Complete_Couples$Proportion_A_alleles_Sibship, alternative = "greater" )


t.test(x = Sibships_of_divorced_dads$Proportion_A_alleles_Sibship, y = Sibships_of_Complete_Couples$Proportion_A_alleles_Sibship, alternative = "greater")
```
```{r}
# D) sibships with just a mother assigned

wilcox.test(x = Sibships_of_divorced_dads$Proportion_A_alleles_Sibship, y = Sibships_of_Divorced_Moms$Proportion_A_alleles_Sibship, alternative = "greater" )


t.test(x = Sibships_of_divorced_dads$Proportion_A_alleles_Sibship, y = Sibships_of_Divorced_Moms$Proportion_A_alleles_Sibship, alternative = "greater")
```






















# End of script ! 
Well done ! 




 ########################## ########################## ########################## ##########################































































# BONUS 1: Details & questions

I'll put TEMPORARILY here stuff that I have "-- TO DO" in the "additions to BigCreek project" google doc. 

## I) Table -- TO DO

Also need a Table so we can see distribution of samples across years and size classes. and a Figure showing length distributions.

### A) Table of distribution of samples across years and size classes.


### B) Length distributions


### C) Omy5 Distribution in Young and Old fish

Version below is simpler, for paper: 
Omy5 haplotype distribution with length (1760 fish Big Creek)
```{r}
ggplot(NoDupfish_and_Omy5) +
 aes(x = LENGTH, fill = hapstr) +
 geom_histogram(bins = 30L) +
 labs(x = "Fork length (mm)", y = "Individuals count", fill = "Omy5 Haplotype") +
   scale_fill_manual(values = c(c("#00AFBB", "#E7B800", "#FC4E07")), labels = c("Anadromous (A)", 
                                   "Heterozygous (H)", 
                                   "Resident (R)")) +
  theme_minimal()

PlotS1 <- ggplot(NoDupfish_and_Omy5) +
 aes(x = LENGTH, fill = hapstr) +
 geom_histogram(bins = 30L) +
 labs(x = "Fork length (mm)", y = "Individuals count", fill = "Omy5 Haplotype") +
   scale_fill_manual(values = c(c("#00AFBB", "#E7B800", "#FC4E07")), labels = c("Anadromous (A)", 
                                   "Heterozygous (H)", 
                                   "Resident (R)")) +
  theme_minimal()

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/PlotS1.png", plot = PlotS1, dpi = 300)

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/PlotS1.svg", plot = PlotS1, dpi = 300)
```

```{r}
ForThisPlot <- NoDupfish_and_Omy5 %>% 
  mutate(YOYorADULTS= if_else(condition = LENGTH >= 100, true = "Adults", false = "Juveniles")) 

ForThisPlot <- within(ForThisPlot, 
                   YOYorADULTS <- factor(YOYorADULTS, 
                                      levels=names(sort(table(YOYorADULTS), 
                                                        decreasing=TRUE))))

ggplot(ForThisPlot) +
 aes(x = YOYorADULTS, fill = hapstr) +
 geom_bar(width = 0.4) +
 scale_fill_hue() +
 labs(x = "Lifestage category", y = "Individuals count", fill = "Omy 5 Haplotype") +
   scale_fill_manual(values = c(c("#00AFBB", "#E7B800", "#FC4E07")), labels = c("Anadromous (A)", 
                                   "Heterozygous (H)", 
                                   "Resident (R)")) +
 theme_minimal() 



Omy5xAge <- ggplot(ForThisPlot) +
 aes(x = YOYorADULTS, fill = hapstr) +
 geom_bar(width = 0.4) +
 scale_fill_hue() +
 labs(x = "Lifestage category", y = "Individuals count", fill = "Omy5 Haplotype") +
   scale_fill_manual(values = c(c("#00AFBB", "#E7B800", "#FC4E07")), labels = c("Anadromous (A)", 
                                   "Heterozygous (H)", 
                                   "Resident (R)")) +
  theme_minimal() 

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/Omy5xAge.png", plot = Omy5xAge, dpi = 300)

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/Omy5xAge.svg", plot = Omy5xAge, dpi = 300)
```


Version below is for Supplementary materials 
```{r}
ggplot(NoDupfish_and_Omy5) +
 aes(x = LENGTH, fill = hapstr) +
 geom_histogram(bins = 30L) +
 labs(title = "Omy5 haplotype distribution with length (1760 fish Big Creek)", fill = "Omy5 Haplotype") +
 scale_fill_manual(values = c(c("#00AFBB", "#E7B800", "#FC4E07"))) +
  theme_minimal()
```


### D) Distance distribution of fish per year per sex 

Use Minimeta_V8

#### One) All years: ALl individuals, YoYs, big fish, bigger fish.


Distribution of individuals across years, by sex

```{r}
library(ggplot2)

ggplot(Minimeta_V8) +
 aes(x = distance, fill = Sex) +
 geom_histogram(bins = 30L) +
 scale_fill_hue() +
 theme_minimal()
```

Distribution of individuals across years, by length class

```{r}

Forplot_here <- Minimeta_V8 %>% 
  mutate(., Length_class = ifelse(LENGTH>150, "Bigger than 150mm","Smaller than 100mm" ))

library(ggplot2)

ggplot(Forplot_here) +
 aes(x = Coll_year, fill = Length_class) +
 geom_bar() +
 scale_fill_hue() +
 theme_minimal()
```


```{r}
ggplot(Minimeta_V8) +
 aes(x = distance) +
 geom_histogram(bins = 30L, fill = "#0c4c8a") +
 labs(x = "Distance from river mouth (m)", y = "Counts of individuals ", title = "Position of all individuals of this study (females and males) in Big Creek river (All years)") +
 theme_minimal() +
 facet_wrap(vars(Sex))
```
```{r}
Minimeta_V8 %>%
 filter(LENGTH >= 47L & LENGTH <= 100L) %>%
 ggplot() +
 aes(x = distance) +
 geom_histogram(bins = 30L, fill = "#0c4c8a") +
 labs(x = "Distance from river mouth (m)", y = "Counts of individuals ", title = "Position of small (< 100 mm length) individuals of this study \n (females and males) in Big Creek river (All years)") +
 theme_minimal() +
 facet_wrap(vars(Sex))
```

```{r}
Minimeta_V8 %>%
 filter(LENGTH > 100L) %>%
 ggplot() +
 aes(x = distance) +
 geom_histogram(bins = 30L, fill = "#0c4c8a") +
 labs(x = "Distance from river mouth (m)", y = "Counts of individuals ", title = "Position of all big (> 100 mm length) individuals of this study \n (females and males) in Big Creek river (All years)") +
 theme_minimal() +
 facet_wrap(vars(Sex))
```

```{r}
Minimeta_V8 %>%
 filter(LENGTH > 150L) %>%
 ggplot() +
 aes(x = distance) +
 geom_histogram(bins = 30L, fill = "#0c4c8a") +
 labs(x = "Distance from river mouth (m)", y = "Counts of individuals ", title = "Position of all bigger (> 150 mm length) individuals of this study \n (females and males) in Big Creek river (all years)") +
 theme_minimal() +
 facet_wrap(vars(Sex))
```

#### Two) Small fish X Years

```{r}
Minimeta_V8 %>%
 filter(LENGTH >= 47L & LENGTH <= 100L) %>%
  filter(Sex == "F") %>%
 ggplot() +
 aes(x = distance) +
 geom_histogram(bins = 30L, fill = "#0c4c8a") +
 labs(x = "Distance from river mouth (m)", y = "Counts of individuals ", title = "Position of small (< 100 mm length) FEMALES in Big Creek river") +
 theme_minimal() +
 facet_wrap(vars(Coll_year))
```

```{r}
Minimeta_V8 %>%
 filter(LENGTH >= 47L & LENGTH <= 100L) %>%
  filter(Sex == "M") %>%
 ggplot() +
 aes(x = distance) +
 geom_histogram(bins = 30L, fill = "#0c4c8a") +
 labs(x = "Distance from river mouth (m)", y = "Counts of individuals ", title = "Position of small (< 100 mm length) MALES in Big Creek river") +
 theme_minimal() +
 facet_wrap(vars(Coll_year))
```


#### Three) Big fish X Years


```{r}
Minimeta_V8 %>%
 filter(LENGTH > 100L) %>%
  filter(Sex == "F") %>%
 ggplot() +
 aes(x = distance) +
 geom_histogram(bins = 30L, fill = "#0c4c8a") +
 labs(x = "Distance from river mouth (m)", y = "Counts of individuals ", title = "Position of big (> 100 mm length) FEMALES in Big Creek river") +
 theme_minimal() +
 facet_wrap(vars(Coll_year))
```


```{r}
Minimeta_V8 %>%
 filter(LENGTH > 100L) %>%
  filter(Sex == "M") %>%
 ggplot() +
 aes(x = distance) +
 geom_histogram(bins = 30L, fill = "#0c4c8a") +
 labs(x = "Distance from river mouth (m)", y = "Counts of individuals ", title = "Position of big (> 100 mm length) MALES in Big Creek river") +
 theme_minimal() +
 facet_wrap(vars(Coll_year))
```


## II) Prepare a figure that shows the read distribution of 2Sexy_locus -- DONE

The idea being to be prepared for reviewers questions.
The dataset used here is : Run7to12_sex_infoV2
And is found in : Script 1, around line 340, in chunk called "2SexyReady_reads".

```{r}
ggplot(Run7to12_sex_infoV2) +
 aes(x = Sex, y = sexreads) +
 geom_boxplot(fill = "#0c4c8a") +
 labs(x = "Inffered sex", y = "Number of reads", title = "Sex inferred by number of read in 2-sexy locus") +
 theme_minimal()
```
 
 And check this one too : 
```{r}
ggplot(Run7to12_sex_infoV2) +
 aes(x = sexreads, fill = Sex) +
 geom_histogram(bins = 50L) +
 scale_fill_hue() +
 labs(x = "Number of reads", y = "Counts", title = "Sex inferred by number of read in 2-sexy locus", fill = "Inffered sex") +
  theme_minimal()
```
 

## III) How many potential parents had zero assigned kids? 

The potential parents can be found by taking all the fish appart from the YoYs from 2017. 

Among all the many potentials parents in the dataset, only 117 had kids assigned (for 1682 with non assigned). 

```{r}

Potential_parents <- Minimeta_V8_noDup %>% 
  filter(., !c(Coll_year == 2017 & LENGTH <= 95))

# Parents with NO assigned kids
Minimeta_V8_noDup %>% 
  filter(., !c(Coll_year == 2017 & LENGTH <= 95)) %>% 
  filter(., !c(Sample_ID %in% SibsAndParentage_V3$Mom | Sample_ID %in% SibsAndParentage_V3$Dad)) %>% 
  nrow()

# Parents with assigned kids
Minimeta_V8_noDup %>% 
  filter(., !c(Coll_year == 2017 & LENGTH <= 95)) %>% 
  filter(., c(Sample_ID %in% SibsAndParentage_V3$Mom | Sample_ID %in% SibsAndParentage_V3$Dad)) %>% 
  nrow()


```

And among the big residents ? (i.e fish of length > 150)

```{r}

# Parents with NO assigned kids
Minimeta_V8_noDup %>% 
  filter(., !LENGTH < 150) %>% 
  filter(., !c(Sample_ID %in% SibsAndParentage_V3$Mom | Sample_ID %in% SibsAndParentage_V3$Dad)) %>% 
  nrow()

# Parents with assigned kids
Minimeta_V8_noDup %>% 
  filter(., !LENGTH < 150) %>% 
  filter(., c(Sample_ID %in% SibsAndParentage_V3$Mom | Sample_ID %in% SibsAndParentage_V3$Dad)) %>% 
  nrow()
```

## IV) Do we find more heterozygous offspring in Single pairs than in trios? 

```{r}
Trios_Bonus4 <- Enriched_nicerun_V3 %>% filter(., TRIOorSP == "Trio")
SP_Bonus4 <- Enriched_nicerun_V3 %>% filter(., TRIOorSP == "Single_Pair")

Trios_Bonus4 %>% count(., hapstr_kid) # 20.63492 % heterozygotes
SP_Bonus4 %>% count(., hapstr_kid) # 34.30421 % heterozygotes

# Does it make a difference if the mom or the dad misses? 

SP_Bonus4 %>% filter(., is.na(Mom)) %>% count(., hapstr_kid)
NoMomHapstrCount <- SP_Bonus4 %>% filter(., is.na(Mom)) 
# 75/(12+75+109)*100 = 38.26 % heterozygotes

SP_Bonus4 %>% filter(., is.na(Dad)) %>% count(., hapstr_kid) 
NoDadHapstrCount <- SP_Bonus4 %>% filter(., is.na(Dad))  
# 31/(8+31+74)*100 = 27.43 % heterozygotes

prop.test(x = c(75, 31), n = c(196, 114), alternative = "greater")

# Bottom line is: There are more heteros in offsprings when Moms are missing. 

# Now what if we take the RRRR single parents only? 
SP_Bonus4 %>% 
  filter(., hapstr_parent_1 == "RRRR") %>%  
  filter(., is.na(Mom)) %>% 
  count(., hapstr_kid) 
# 32.28346 % heterozygotes

SP_Bonus4 %>% 
  filter(., hapstr_parent_1 == "RRRR") %>%  
  filter(., is.na(Dad)) %>% 
  count(., hapstr_kid)
# 15.51724 % heterozygotes

prop.test(x = c(41, 9), n = c(127, 68), alternative = "greater")

```

In the overall dataset (Trios + SP)
```{r}
Trios_and_SP_Bonus4 <- Enriched_nicerun_V3 

# Now what if we take the RRRR single parents only? 
Trios_and_SP_Bonus4 %>% 
  filter(., MomOmy5 == "RRRR") %>%  
  count(., hapstr_kid) 
# 10 % heterozygotes for Moms

Trios_and_SP_Bonus4 %>% 
  filter(., DadOmy5 == "RRRR") %>%  
  count(., hapstr_kid)
# 26.43678 % heterozygotes
```



## V) Do we find disassortative mating in heterozygous parents? 

First in trios:
Look at HHHH moms and see who are their partners! 
Then do the same for HHH dads.
If there is a "sex-dependent dominance" disassortative mating you should see HHHH moms mating with more "RRRR" dads, and vice versa.

Most likely you won't find anything JUST BECAUSE "A" are missing so much !!
```{r}
# First moms
Trios_Bonus5_Moms <- Enriched_nicerun_V3 %>% 
  filter(., TRIOorSP == "Trio") %>% 
  filter(., !is.na(Mom)) %>% 
  filter(., MomOmy5 == "HHHH")
Trios_Bonus5_Moms %>% count(., DadOmy5) # 12% A / 20% H / 68% R

# Second Dads
Trios_Bonus5_Dads <- Enriched_nicerun_V3 %>% 
  filter(., TRIOorSP == "Trio") %>% 
  filter(., !is.na(Dad)) %>% 
  filter(., DadOmy5 == "HHHH")
Trios_Bonus5_Dads %>% count(., MomOmy5) # 41.6% A / 41.6% H / 16.6% R

```

Ok maybe it makes more sense to check in the overall population instead:
Filter "H" moms and see what are the offsprings compositions.
Then same for dads, as simple as that! 
```{r}
Overall_Bonus5_Moms <- Enriched_nicerun_V3 %>% 
  filter(., !is.na(Mom)) %>% 
  filter(., MomOmy5 == "HHHH") 

Overall_Bonus5_Moms %>% 
  count(., hapstr_kid)

Number_of_A_Bonus5_Moms <- 9
Number_of_R_Bonus5_Moms <- 29

# Result: 
# 40.84507 % of RRRR offsprings.
# 46.47887 % of HHHH offsprings.
# 12.67606 % of AAAA offsprings.
```

Now for "H" dads:
```{r}
Overall_Bonus5_Dads <- Enriched_nicerun_V3 %>% 
  filter(., !is.na(Dad)) %>% 
  filter(., DadOmy5 == "HHHH") 

Overall_Bonus5_Dads %>% 
  count(., hapstr_kid)

Number_of_A_Bonus5_Dads <- 15
Number_of_R_Bonus5_Dads <- 23

# Result: 
# 30.26316 % of RRRR offsprings.
# 50.0     % of HHHH offsprings.
# 19.73684 % of AAAA offsprings.
```

Let's test this, using the whole pool of offspring to make the comparison:
```{r}
Test_AAAA_Offspring_MalesvsFemales <- prop.test(x = c(Number_of_A_Bonus5_Moms, Number_of_A_Bonus5_Dads) , n = c(nrow(Overall_Bonus5_Moms), nrow(Overall_Bonus5_Dads)), alternative = "less", correct = F)

Test_AAAA_Offspring_MalesvsFemales
```
Same test as above but excluding heterozygous offsprings:
```{r}
Test_AAAA_Offspring_MalesvsFemales <- prop.test(x = c(Number_of_A_Bonus5_Moms, Number_of_A_Bonus5_Dads) , n = c((Number_of_A_Bonus5_Moms + Number_of_R_Bonus5_Moms), (Number_of_A_Bonus5_Dads + Number_of_R_Bonus5_Dads)), alternative = "less", correct = F)

Test_AAAA_Offspring_MalesvsFemales
```
Now test if moms produce more "R" offsprings than dads, using all offsprings for the proportion test: 
```{r}
Test_RRRR_Offspring_MalesvsFemales <- prop.test(x = c(Number_of_R_Bonus5_Moms, Number_of_R_Bonus5_Dads) , n = c(nrow(Overall_Bonus5_Moms), nrow(Overall_Bonus5_Dads)), alternative = "greater", correct = F)

Test_RRRR_Offspring_MalesvsFemales
```
And the same excluding heterozygotes: 
```{r}
Test_RRRR_Offspring_MalesvsFemales <- prop.test(x = c(Number_of_R_Bonus5_Moms, Number_of_R_Bonus5_Dads) , n = c((Number_of_A_Bonus5_Moms + Number_of_R_Bonus5_Moms), (Number_of_A_Bonus5_Dads + Number_of_R_Bonus5_Dads)), alternative = "greater", correct = F)

Test_RRRR_Offspring_MalesvsFemales
```

## VI) Regression - Distance from mouth / Prop. of anadromous alleles

Let's make this by 25m bins, as this is all we have

```{r}
Regression_Omy5_StreamDistance <- Minimeta_V8_noDup %>% 
  ungroup() %>% 
  filter(., !is.na(hapstr)) %>% 
  group_by(., distance, hapstr) %>% 
  summarise(hapstr_count = n()) %>% 
  mutate(Prop_Omy5_perDistanceBin = hapstr_count / sum(hapstr_count)) %>% 
  arrange(desc(Prop_Omy5_perDistanceBin)) %>% 
  ungroup()
```

```{r}
Omy5_Regression_Stream <- ggplot(Regression_Omy5_StreamDistance) +
 aes(x = distance, y = Prop_Omy5_perDistanceBin, colour = hapstr) +
 geom_point(size = 1.5) +
 scale_color_hue() +
 labs(x = "Distance from stream mouth (m)", y = "Genotype proportions", title ="Omy5 haplotype distribution in Big Creek River", color="Omy5 Haplotype") +
 scale_color_manual(values = c("#00AFBB", "#E7B800", "#FC4E07"), labels = c("Anadromous", "Heterozygous", "Resident")) +
 theme_minimal()  + 
  geom_smooth(method='lm', formula= y~x)
Omy5_Regression_Stream

 
ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/Omy5_Regression_Stream.svg", plot = Omy5_Regression_Stream, dpi = 300)
```
```{r}
Regression_stream_AAAA <- lm(formula = Prop_Omy5_perDistanceBin ~ distance , data = Regression_Omy5_StreamDistance, subset = (hapstr == "AAAA"))
summary(Regression_stream_AAAA)
```
```{r}
Regression_stream_HHHH <- lm(formula = Prop_Omy5_perDistanceBin ~ distance , data = Regression_Omy5_StreamDistance, subset = (hapstr == "HHHH"))
summary(Regression_stream_HHHH)
```
```{r}
Regression_stream_RRRR <- lm(formula = Prop_Omy5_perDistanceBin ~ distance , data = Regression_Omy5_StreamDistance, subset = (hapstr == "RRRR"))
summary(Regression_stream_RRRR)
```


# BONUS 2 : Numbers to report ! 
 
## Sex ratio in YoY vs BigFish of overall dataset


```{r}
Minimeta_V8_noDup %>% filter(., LENGTH <= 95) %>% count(., Sex)
```


```{r}
Minimeta_V8_noDup %>% filter(., LENGTH <= 100) %>% count(., Sex)
```


```{r}
Minimeta_V8_noDup %>% filter(., LENGTH >= 150) %>% count(., Sex)
```
0.32::0.68 F::M ratio in big fish


## Numbers about fullsibships 

Number of sibships including the sibships of size 1
```{r}
UBC_run1_SibSize_META_Probfiltered %>% filter(., `Prob(Inc.)` >= 0.90) %>%  ungroup() %>% distinct(., FullSibshipIndex) %>% nrow()

nrow(UBC_run1_SibSize_META_Probfiltered)
```

Number of sibships with size 2+
```{r}
nrow(Mini_Summary_per_Sibgroup_Allfish_uncorrected)
```

Composed by that many individuals
```{r}
nrow(Filtered_Fullsibs)
```

Sibships distribution in years: 
```{r}
Mini_Summary_per_Sibgroup_Allfish_uncorrected %>% count(Collyear_Sibship_corrected)
```

Sibsize distribution:
```{r}
Mini_Summary_per_Sibgroup_Allfish_uncorrected %>% count(Size_class) %>% mutate(., perc_n = (n/nrow(Mini_Summary_per_Sibgroup_Allfish_uncorrected))*100)
```



```{r}
Mini_Summary_per_Sibgroup_Allfish_uncorrected$Size_class <- ordered(Mini_Summary_per_Sibgroup_Allfish_uncorrected$Size_class, levels = c("2-5","6-10","11-15","16-20","21-25","26-30","31+"))

ggplot(Mini_Summary_per_Sibgroup_Allfish_uncorrected) +
 aes(x = Collyear_Sibship_corrected) +
 geom_bar(fill = "#0c4c8a") +
 labs(title = "Count of sibships by collection year, by size classes (sibship size)") +
 theme_minimal() +
 facet_wrap(vars(Size_class))
```

## Numbers about parents

### How many parents

```{r}
Moms_list <- SibsAndParentage_V3 %>% 
  filter(., !is.na(Mom)) %>% 
  distinct(., Mom, .keep_all = T)

Dads_list <- SibsAndParentage_V3 %>% 
  filter(., !is.na(Dad)) %>% 
  distinct(., Dad, .keep_all = T)

# Number of parents is 
nrow(Dads_list) + nrow(Moms_list)
```


### How many Big parents

Do the addition of :  Moms with length >= 150mm + Dads with length >= 150mm
```{r}
BigMoms <- SibsAndParentage_V3 %>% 
  filter(., Momsize >= 150) %>% 
  distinct(., Mom, .keep_all = T)

BigDads <- SibsAndParentage_V3 %>% 
  filter(., Dadsize >= 150) %>% 
  distinct(., Dad, .keep_all = T)

nrow(BigMoms)
nrow(BigDads)
```

### How many small parents

Do the addition of :  Moms with length < 100mm + Dads with length < 100mm
```{r}
SmallMoms <- SibsAndParentage_V3 %>% 
  filter(., Momsize < 100) %>% 
  distinct(., Mom, .keep_all = T)

SmallDads <- SibsAndParentage_V3 %>% 
  filter(., Dadsize < 100) %>% 
  distinct(., Dad, .keep_all = T)

nrow(SmallMoms)
nrow(SmallDads)
```

### Which parent missing in SP of whole dataset? 

Are females missing more often in SP than males? 

```{r}
SibsAndParentage_V3 %>% 
  filter(., TRIOorSP == "Single_Pair") %>% 
  count(is.na(Mom))
```
Moms are missing in 196 SP while males are missing in 114 SP. 
In % this is 63.22 missing moms and 36.77 missing males.

## Figure S1: Number of samples per year:

```{r}
library(ggplot2)

ggplot(Minimeta_V8_noDup) +
 aes(x = Coll_year, fill = YOY) +
 scale_fill_manual(values = c("#F8766D", "#00A5FF"), labels = c("No", "Yes")) +
 geom_bar() +
 labs(x = "Collection year", y = "Counts", title = "Annual distribution of sample size in this study", fill = "Young-of-Year") +
 theme_minimal()

FigureS1 <- ggplot(Minimeta_V8_noDup) +
 aes(x = Coll_year, fill = YOY) +
 scale_fill_manual(values = c("#F8766D", "#00A5FF"), labels = c("No", "Yes")) +
 geom_bar() +
 labs(x = "Collection year", y = "Counts", title = "Annual distribution of sample size in this study", fill = "Young-of-Year") +
 theme_minimal()

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/FigureS1.svg", plot = FigureS1, dpi = 300, width = 10)

```

## Figure sex reads: 

Use "Run7to12_sex_infoV2", a piece of data created in script 1
```{r}
library(dplyr)
library(ggplot2)

esquisser(Run7to12_sex_infoV2)

Run7to12_sex_infoV2 %>%
 filter(sexreads >= 0L & sexreads <= 100L) %>%
 ggplot() +
 aes(x = sexreads, fill = Sex) +
 geom_histogram(bins = 30L) +
 scale_fill_brewer(palette = "Set1") +
 labs(x = "Reads depth at the genetic sex locus", y = "Number of individuals", fill = "Assigned sex") +
 theme_minimal()

paste("We excluded", round(length(which(Run7to12_sex_infoV2$sexreads > 100)) / nrow(Run7to12_sex_infoV2), 4) * 100, "% of the data, with more than 100 reads")
```
```{r}
Figure_SexReads <- Run7to12_sex_infoV2 %>%
 filter(sexreads >= 0L & sexreads <= 100L) %>%
 ggplot() +
 aes(x = sexreads, fill = Sex) +
 geom_histogram(bins = 30L) +
 scale_fill_brewer(palette = "Set1") +
 labs(x = "Reads depth at the genetic sex locus", y = "Number of individuals", fill = "Assigned sex") +
 theme_minimal()

ggsave(filename = "D:/Nonopov_travail/Santa_Cruz_internship/New stage/Noe/BigCreek project/Results/Plots/Figure_SexReads.svg", plot = Figure_SexReads, dpi = 300, width = 10)
```



# BONUS 3 : Extra datasets to look at 

```{r}
# 2) Big Ck 2008-2015 YOY sex and Omy5 proportions
# This dataset contains a summary of samples for analysis of whether juvenile growth differs with respec to sex and Omy5.There is a sheet of data and one with plenty of small tables that devon did I think, plenty of things to look at!  So here we take only the data sheet  Explore the minitables in excel !  

Big_Ck_2008_2015_YOY_sex_and_Omy5_proportions <- read_excel("Summary_tables/Big Ck 2008-2015 YOY sex and Omy5 proportions.xlsx", sheet = "data")
View(Big_Ck_2008_2015_YOY_sex_and_Omy5_proportions)
nrow(Big_Ck_2008_2015_YOY_sex_and_Omy5_proportions)

# 3) BigCreektissuesamples_Nov2017
# A table summarising the number of YOY, tagged, non tagged etc per year. Useful but no need to load in R. 

# 4) UBC_tissue_samples_2010_2017 
# The same as 1) but separated in 'YOY', Resident and others: useful ! 
# Contains the followin note in one sheet, that I don't really understand "fish_num refers to SQL database ID that is unique for each fish by Tagged or Non-tagged groups; in this set, there are no shared fish_num between Tagged and Non-tagged"

UBC_tissue_samples_2010_2017 <- read_excel("Summary_tables/UBC_tissue_samples_2010_2017.xlsx",sheet = "Residents>150")
  Rundio_Residents <- UBC_tissue_samples_2010_2017
  View(Rundio_Residents)

Rundio_YOY <- read_excel("Summary_tables/UBC_tissue_samples_2010_2017.xlsx", sheet = "YOY<95mm")
View(Rundio_YOY)

Rundio_Undetermined <- read_excel("Summary_tables/UBC_tissue_samples_2010_2017.xlsx", sheet = "other_samples")
View(Rundio_Undetermined)
```



















